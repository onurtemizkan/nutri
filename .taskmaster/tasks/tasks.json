{
  "master": {
    "tasks": [
      {
        "id": "2",
        "title": "Implement Real Food Classification ML Model",
        "description": "Replace the mock food classifier in ml-service/app/services/food_analysis_service.py with a real CNN model (EfficientNet or ResNet) trained on food image datasets.",
        "details": "1. Create a new module `ml-service/app/ml_models/food_classifier.py` with:\n   - Load pre-trained EfficientNet-B0 or ResNet-50 from torchvision\n   - Fine-tune on Food-101 dataset or custom food dataset\n   - Implement proper image preprocessing pipeline matching ImageNet stats\n   - Support for GPU inference if available (auto-detect CUDA)\n\n2. Update `food_analysis_service.py`:\n   - Replace `NUTRITION_DATABASE` with a proper food database (USDA FoodData Central API integration)\n   - Update `_classify_food()` to use real model inference instead of random selection\n   - Add model loading with caching to avoid reloading on each request\n   - Implement top-5 predictions with confidence scores\n\n3. Add model versioning:\n   - Store model checkpoints in `ml-service/models/food_classifier/`\n   - Add `model_version` field to responses\n   - Implement A/B testing capability by loading multiple model versions\n\n4. Extend nutrition database:\n   - Expand from current 6 items to 100+ common foods\n   - Structure: JSON file or SQLite database with USDA data\n   - Include serving size variations (small, medium, large)\n\nPseudo-code for classifier:\n```python\nclass FoodClassifier:\n    def __init__(self, model_path: str = None):\n        self.model = self._load_model(model_path)\n        self.classes = self._load_class_labels()\n    \n    def _load_model(self, path):\n        model = torchvision.models.efficientnet_b0(pretrained=True)\n        model.classifier[-1] = nn.Linear(1280, num_food_classes)\n        if path:\n            model.load_state_dict(torch.load(path))\n        model.eval()\n        return model\n    \n    async def classify(self, image: np.ndarray) -> List[Tuple[str, float]]:\n        tensor = self._preprocess(image)\n        with torch.no_grad():\n            outputs = self.model(tensor)\n            probs = torch.softmax(outputs, dim=1)\n        return self._get_top_k(probs, k=5)\n```",
        "testStrategy": "1. Unit tests for model loading and inference\n2. Test classification accuracy on held-out test set (target >80% top-5)\n3. Integration test: POST /api/food/analyze with real food images\n4. Performance test: Inference time <3s per image\n5. Test model fallback when GPU not available",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "3",
        "title": "Build Health Metrics Mobile UI Screens",
        "description": "Create mobile screens for viewing and manually entering health metrics (RHR, HRV, sleep, recovery). Backend API is complete at /api/health-metrics.",
        "details": "1. Create new screens in `app/` directory:\n   - `app/health/index.tsx` - Health metrics dashboard/list\n   - `app/health/[id].tsx` - Detail view for specific metric\n   - `app/health/add.tsx` - Manual entry form\n\n2. Health Dashboard (`app/health/index.tsx`):\n   - Display today's key metrics in cards (RHR, HRV, Sleep, Recovery)\n   - Time range selector: Today, Week, Month\n   - Pull-to-refresh functionality\n   - Navigate to detail view on tap\n\n3. Metric Detail View (`app/health/[id].tsx`):\n   - Line chart showing metric over time (use react-native-chart-kit or Victory Native)\n   - Statistics: avg, min, max, trend arrow\n   - Data source indicator (Apple Health, Fitbit, Manual)\n   - Date range filter\n\n4. Manual Entry Form (`app/health/add.tsx`):\n   - Metric type picker (dropdown with all HealthMetricType enum values)\n   - Value input with unit display (bpm, ms, hours, %)\n   - Date/time picker (defaults to now)\n   - Source set to 'MANUAL'\n   - Validation: min/max ranges per metric type\n\n5. Create API client in `lib/api/health-metrics.ts`:\n```typescript\nexport const healthMetricsApi = {\n  getAll: (params: { startDate?: string; endDate?: string; metricType?: string }) => \n    apiClient.get('/health-metrics', { params }),\n  getById: (id: string) => apiClient.get(`/health-metrics/${id}`),\n  create: (data: CreateHealthMetricInput) => apiClient.post('/health-metrics', data),\n  getDailySummary: (date: string) => apiClient.get(`/health-metrics/daily/${date}`),\n}\n```\n\n6. Add navigation:\n   - Add 'Health' tab to bottom navigation in `app/(tabs)/_layout.tsx`\n   - Use health heart icon from @expo/vector-icons",
        "testStrategy": "1. Component tests for each screen using react-native-testing-library\n2. Test form validation for manual entry\n3. Test API integration with mock server\n4. Visual regression tests for chart rendering\n5. Test pull-to-refresh behavior\n6. Test empty state when no health data exists",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "4",
        "title": "Build Activity Tracking Mobile UI Screens",
        "description": "Create mobile screens for viewing and manually logging activities. Backend API is complete at /api/activities.",
        "details": "1. Create new screens in `app/` directory:\n   - `app/activity/index.tsx` - Activity list/history\n   - `app/activity/[id].tsx` - Activity detail view\n   - `app/activity/add.tsx` - Manual activity entry form\n\n2. Activity List (`app/activity/index.tsx`):\n   - Weekly summary card: total minutes, calories, workout count\n   - Filter by activity type (All, Cardio, Strength, Flexibility)\n   - List of recent activities with icon, duration, calories\n   - Floating action button to add new activity\n   - Pull-to-refresh\n\n3. Activity Detail View (`app/activity/[id].tsx`):\n   - Display all activity fields: type, duration, intensity, calories\n   - Heart rate data if available (avg, max)\n   - Distance and steps for applicable activities\n   - Notes field\n   - Edit/Delete buttons\n\n4. Manual Entry Form (`app/activity/add.tsx`):\n   - Activity type picker (21 types from ActivityType enum)\n   - Intensity picker (Low, Moderate, High, Maximum)\n   - Duration input (hours:minutes picker)\n   - Date/time pickers for start time\n   - Optional fields: calories, heart rate, distance, notes\n   - Validation: duration > 0, end time > start time\n\n5. Create API client in `lib/api/activities.ts`:\n```typescript\nexport const activitiesApi = {\n  getAll: (params?: { activityType?: string; startDate?: string }) =>\n    apiClient.get('/activities', { params }),\n  getById: (id: string) => apiClient.get(`/activities/${id}`),\n  create: (data: CreateActivityInput) => apiClient.post('/activities', data),\n  update: (id: string, data: Partial<CreateActivityInput>) =>\n    apiClient.put(`/activities/${id}`, data),\n  delete: (id: string) => apiClient.delete(`/activities/${id}`),\n  getWeeklySummary: () => apiClient.get('/activities/weekly-summary'),\n}\n```\n\n6. Add activity icons mapping for different activity types",
        "testStrategy": "1. Component tests for each screen\n2. Test form validation (duration, time constraints)\n3. Test activity type filtering\n4. Test CRUD operations with mock API\n5. Test weekly summary calculation display\n6. Test edit/delete flows with confirmation dialogs",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Implement Apple HealthKit Integration",
        "description": "Enable automatic sync of comprehensive health data from Apple HealthKit including cardiovascular metrics (RHR, Heart Rate, HRV SDNN/RMSSD), sleep quality metrics (duration, deep sleep, REM, efficiency, score), respiratory data (respiratory rate, oxygen saturation), and VO2Max.",
        "status": "in-progress",
        "dependencies": [
          "3",
          "4"
        ],
        "priority": "medium",
        "details": "1. Install and configure react-native-health (recommended for Expo managed workflow):\n   - Add `react-native-health` to package.json dependencies\n   - Configure `app.json` with NSHealthShareUsageDescription and NSHealthUpdateUsageDescription\n   - Add HealthKit entitlement to iOS build configuration\n   - Request HealthKit permissions on iOS for all metric types\n\n2. **Schema Consideration**: The existing Prisma HealthMetricType enum in `server/prisma/schema.prisma` already supports:\n   - Cardiovascular: `RESTING_HEART_RATE`, `HEART_RATE_VARIABILITY_SDNN`, `HEART_RATE_VARIABILITY_RMSSD`\n   - Respiratory: `RESPIRATORY_RATE`, `OXYGEN_SATURATION`, `VO2_MAX`\n   - Sleep: `SLEEP_DURATION`, `DEEP_SLEEP_DURATION`, `REM_SLEEP_DURATION`, `SLEEP_EFFICIENCY`, `SLEEP_SCORE`\n   - NOTE: Consider adding `HEART_RATE` (instantaneous/average HR, separate from resting) if needed for workout HR data\n\n3. Create health sync service in `lib/services/healthkit.ts`:\n```typescript\nexport interface HealthKitConfig {\n  permissions: {\n    read: HealthKitPermission[];\n    write?: HealthKitPermission[];\n  };\n}\n\nexport const healthKitService = {\n  // Initialize and request permissions\n  requestPermissions: () => Promise<boolean>,\n  isAvailable: () => Promise<boolean>,\n  \n  // Sync cardiovascular data\n  syncCardiovascularMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKQuantityTypeIdentifierRestingHeartRate → RESTING_HEART_RATE\n  // - HKQuantityTypeIdentifierHeartRate → instantaneous HR samples\n  // - HKQuantityTypeIdentifierHeartRateVariabilitySDNN → HEART_RATE_VARIABILITY_SDNN\n  // - HKQuantityTypeIdentifier.heartRateVariabilityRMSSD (if available)\n  \n  // Sync respiratory data\n  syncRespiratoryMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKQuantityTypeIdentifierRespiratoryRate → RESPIRATORY_RATE\n  // - HKQuantityTypeIdentifierOxygenSaturation → OXYGEN_SATURATION\n  // - HKQuantityTypeIdentifierVO2Max → VO2_MAX\n  \n  // Sync sleep data\n  syncSleepMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKCategoryTypeIdentifierSleepAnalysis → parse into:\n  //   - SLEEP_DURATION (total sleep time)\n  //   - DEEP_SLEEP_DURATION (deep/core sleep stages)\n  //   - REM_SLEEP_DURATION (REM stages)\n  //   - SLEEP_EFFICIENCY (time asleep / time in bed)\n  //   - SLEEP_SCORE (if available from source)\n  \n  // Sync activity data\n  syncActivityMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKQuantityTypeIdentifierStepCount → STEPS\n  // - HKQuantityTypeIdentifierActiveEnergyBurned → ACTIVE_CALORIES\n  // - HKWorkoutType → Activity model with exercise HR data\n  \n  // Background sync\n  setupBackgroundSync: () => void,\n}\n```\n\n4. HealthKit type identifiers mapping:\n```typescript\nconst HEALTHKIT_TYPE_MAP = {\n  // Cardiovascular\n  HKQuantityTypeIdentifierRestingHeartRate: 'RESTING_HEART_RATE',\n  HKQuantityTypeIdentifierHeartRateVariabilitySDNN: 'HEART_RATE_VARIABILITY_SDNN',\n  // Note: RMSSD might need manual calculation from RR intervals\n  \n  // Respiratory\n  HKQuantityTypeIdentifierRespiratoryRate: 'RESPIRATORY_RATE',\n  HKQuantityTypeIdentifierOxygenSaturation: 'OXYGEN_SATURATION',\n  HKQuantityTypeIdentifierVO2Max: 'VO2_MAX',\n  \n  // Sleep (requires parsing HKCategoryTypeIdentifierSleepAnalysis)\n  // Sleep stages: inBed, asleepUnspecified, awake, asleepCore, asleepDeep, asleepREM\n  \n  // Activity\n  HKQuantityTypeIdentifierStepCount: 'STEPS',\n  HKQuantityTypeIdentifierActiveEnergyBurned: 'ACTIVE_CALORIES',\n};\n```\n\n5. Implement data transformation layer:\n   - Convert HealthKit units to API units (bpm, ms, %, steps, kcal, etc.)\n   - Match existing Zod validation schemas in `server/src/validation/schemas.ts`\n   - Use source: 'apple_health' to match healthMetricSourceSchema\n   - Include device metadata: {device: \"Apple Watch\", quality: \"high\"}\n\n6. Create sync flow:\n   - Initial sync: Fetch last 30 days of data on first connect\n   - Incremental sync: Fetch data since last sync timestamp\n   - Store lastSyncTimestamp in Expo SecureStore (per metric type for efficiency)\n   - Batch API calls using bulkCreateHealthMetricsSchema (50 items per request)\n   - Handle timezone conversions (HealthKit returns local time, API expects UTC)\n\n7. Handle data deduplication:\n   - Use existing (userId, metricType, recordedAt, source) unique constraint in schema\n   - Server handles conflicts via upsert\n   - Store sourceId from HealthKit sample UUID for traceability\n\n8. Add sync UI in profile settings (app/profile.tsx or new app/settings/health.tsx):\n   - Connect/Disconnect Apple Health button\n   - Permission status for each metric category\n   - Last sync timestamp display (per category)\n   - Manual sync button with progress indicator\n   - Sync status indicator (syncing, synced, error)\n   - Data preview showing recently synced metrics\n\n9. Handle background sync (future enhancement):\n   - Configure iOS background fetch capability\n   - Sync when app becomes active via AppState listener\n   - Respect battery and data usage settings\n   - Consider using HealthKit's HKObserverQuery for real-time updates",
        "testStrategy": "1. Unit tests for HealthKit service:\n   - Mock react-native-health module for simulator testing\n   - Test permission request flow and error handling\n   - Test data transformation for each metric type (HK format → API format)\n   - Test unit conversions (HK units → standard units)\n\n2. Test cardiovascular data sync:\n   - Mock RHR samples → verify RESTING_HEART_RATE records\n   - Mock HRV samples → verify HEART_RATE_VARIABILITY_SDNN records\n   - Test edge cases: missing data, invalid values\n\n3. Test respiratory data sync:\n   - Mock respiratory rate → verify RESPIRATORY_RATE records\n   - Mock SpO2 → verify OXYGEN_SATURATION records\n   - Mock VO2Max → verify VO2_MAX records\n\n4. Test sleep data parsing:\n   - Mock sleep analysis categories → verify correct stage classification\n   - Test sleep efficiency calculation (time asleep / time in bed)\n   - Test sleep duration aggregation across fragmented sleep\n\n5. Test sync error handling and retry logic:\n   - Network errors during bulk upload\n   - Partial failures in batch operations\n   - Permission denied scenarios\n\n6. Test deduplication with existing data:\n   - Re-sync same data → verify no duplicates\n   - Test sourceId matching\n\n7. Test UI state updates during sync:\n   - Loading states\n   - Progress indication\n   - Error display\n\n8. Manual testing on physical device:\n   - Test with real Apple Watch data\n   - Verify data accuracy against Health app\n   - Test permission prompts\n   - Test background sync behavior",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure react-native-health package",
            "description": "Add react-native-health dependency and configure iOS build settings with proper entitlements and Info.plist descriptions",
            "dependencies": [],
            "details": "Install react-native-health via npm/yarn. Update app.json with NSHealthShareUsageDescription explaining why the app needs read access to health data. Add HealthKit entitlement. Configure iOS build to include HealthKit framework. Test that the package builds correctly on iOS simulator/device.",
            "status": "pending",
            "testStrategy": "Verify package installs without errors. Confirm iOS build succeeds. Check Info.plist contains correct health usage descriptions.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create HealthKit permission management system",
            "description": "Implement permission request flow for all required HealthKit data types including cardiovascular, respiratory, and sleep metrics",
            "dependencies": [
              1
            ],
            "details": "Create lib/services/healthkit/permissions.ts. Define permission sets for each metric category. Implement isAvailable() check for HealthKit. Implement requestPermissions() with granular permission requests. Handle partial permission grants gracefully. Store permission status in context/state.",
            "status": "pending",
            "testStrategy": "Mock HealthKit permissions. Test all permission states (granted, denied, not determined). Test partial permission scenarios.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement cardiovascular metrics sync (RHR, HR, HRV)",
            "description": "Create sync functions for Resting Heart Rate, Heart Rate samples, and Heart Rate Variability (SDNN and RMSSD)",
            "dependencies": [
              2
            ],
            "details": "Implement syncCardiovascularMetrics() in healthkit.ts. Query HKQuantityTypeIdentifierRestingHeartRate for RHR. Query HKQuantityTypeIdentifierHeartRateVariabilitySDNN for HRV. Transform HealthKit samples to match HealthMetric API format. Handle unit conversions (HK returns bpm/ms). Include device metadata from sample source.",
            "status": "pending",
            "testStrategy": "Mock HK cardiovascular queries. Verify correct transformation to RESTING_HEART_RATE and HEART_RATE_VARIABILITY_SDNN types. Test unit handling.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement respiratory metrics sync (respiratory rate, SpO2, VO2Max)",
            "description": "Create sync functions for respiratory rate, oxygen saturation, and VO2Max data from HealthKit",
            "dependencies": [
              2
            ],
            "details": "Implement syncRespiratoryMetrics() in healthkit.ts. Query HKQuantityTypeIdentifierRespiratoryRate, HKQuantityTypeIdentifierOxygenSaturation, and HKQuantityTypeIdentifierVO2Max. Transform to RESPIRATORY_RATE, OXYGEN_SATURATION, and VO2_MAX metric types. Handle different sample frequencies (VO2Max is less frequent).",
            "status": "pending",
            "testStrategy": "Mock HK respiratory queries. Verify correct transformation to API format. Test handling of sparse VO2Max data.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement sleep metrics sync with stage classification",
            "description": "Create sync function for sleep analysis including duration, deep sleep, REM, and efficiency calculations",
            "dependencies": [
              2
            ],
            "details": "Implement syncSleepMetrics() in healthkit.ts. Query HKCategoryTypeIdentifierSleepAnalysis. Parse sleep stages (asleepCore→DEEP_SLEEP, asleepDeep→DEEP_SLEEP, asleepREM→REM_SLEEP). Calculate total SLEEP_DURATION. Calculate SLEEP_EFFICIENCY (asleep time / in bed time). Handle fragmented sleep sessions.",
            "status": "pending",
            "testStrategy": "Mock HK sleep analysis with various stage combinations. Verify correct duration calculations. Test efficiency calculation accuracy. Test fragmented sleep handling.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement activity metrics sync (steps, active calories)",
            "description": "Create sync function for daily activity data including step count and active energy burned",
            "dependencies": [
              2
            ],
            "details": "Implement syncActivityMetrics() in healthkit.ts. Query HKQuantityTypeIdentifierStepCount and HKQuantityTypeIdentifierActiveEnergyBurned. Aggregate daily totals. Transform to STEPS and ACTIVE_CALORIES metric types. Handle timezone boundaries for daily aggregation.",
            "status": "pending",
            "testStrategy": "Mock HK activity queries. Verify daily aggregation logic. Test timezone handling for day boundaries.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Create batch sync orchestration with API integration",
            "description": "Implement the main sync orchestration that coordinates all metric syncs and uploads to the backend API",
            "dependencies": [
              3,
              4,
              5,
              6
            ],
            "details": "Create syncAllHealthData() coordinator function. Implement incremental sync using stored lastSyncTimestamp from SecureStore. Batch API uploads using bulkCreateHealthMetricsSchema (50 items per request). Handle partial failures and retry logic. Update lastSyncTimestamp per metric category on success.",
            "status": "pending",
            "testStrategy": "Test full sync orchestration flow. Verify batch chunking at 50 items. Test incremental sync with stored timestamps. Test error handling and retry.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Build HealthKit settings UI with sync controls",
            "description": "Create the user interface for managing HealthKit connection, viewing sync status, and triggering manual syncs",
            "dependencies": [
              7
            ],
            "details": "Create app/settings/health.tsx screen or add section to app/profile.tsx. Display Connect/Disconnect Apple Health button. Show permission status per metric category with toggle indicators. Display last sync timestamp and synced data counts. Add manual Sync Now button with progress indicator. Show sync status (syncing/synced/error) with appropriate feedback.",
            "status": "pending",
            "testStrategy": "Test UI component rendering. Test connect/disconnect flow. Test sync button interaction and loading states. Test error state display.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down the Apple HealthKit integration into implementation phases:\n\n1. **Library Setup & Configuration**: Install react-native-health or expo-health-connect, configure iOS entitlements in app.json (NSHealthShareUsageDescription), and set up the Expo plugin. Research which library works best with Expo SDK 52.\n\n2. **HealthKit Service Core**: Create `lib/services/healthkit.ts` with typed interfaces matching the existing TypeScript patterns in `lib/types/index.ts`. Implement the base service structure with permission request methods.\n\n3. **Data Fetching Implementation**: Implement data fetching for each metric type mapping HealthKit identifiers to the existing HealthMetricType enum (RESTING_HEART_RATE, HEART_RATE_VARIABILITY_SDNN, SLEEP_DURATION, STEPS, ACTIVE_CALORIES). Note: Add ACTIVE_HEART_RATE to schema.prisma for instantaneous HR.\n\n4. **Activity Sync Implementation**: Map HKWorkoutType to the existing ActivityType enum (RUNNING, CYCLING, SWIMMING, etc.) in schema.prisma. Handle activity data transformation.\n\n5. **Sync Logic & State Management**: Implement initial sync (30 days), incremental sync with lastSyncTimestamp stored in SecureStore (pattern from lib/api/client.ts), batch API calls (50 items/request), and leverage the existing bulk endpoint at `/api/health-metrics/bulk`.\n\n6. **Profile UI Integration**: Extend the existing `app/(tabs)/profile.tsx` with a Health Integration section. Add Connect/Disconnect Apple Health button, sync status indicators, last sync timestamp display, and manual sync button following the existing design patterns.\n\n7. **Testing & Error Handling**: Mock HealthKit data for simulator, test permission flows, data transformation, sync error handling/retry logic, and UI state updates. Follow existing error handling patterns in lib/utils/errorHandling.ts.",
        "updatedAt": "2025-12-04T21:22:52.954Z"
      },
      {
        "id": "6",
        "title": "Train and Deploy LSTM Models for Health Predictions",
        "description": "Train LSTM models for RHR and HRV prediction using the existing model architecture in ml-service/app/ml_models/lstm.py and make them production-ready.",
        "details": "1. Create training pipeline in `ml-service/app/services/model_training.py`:\n   - Already has TrainModelRequest/Response schemas\n   - Implement data loading from database\n   - Create training/validation split (80/20)\n   - Add early stopping with patience=10\n   - Save model checkpoints and metadata\n\n2. Training data preparation:\n   - Use FeatureEngineeringService to generate features\n   - Create sliding window sequences (30-day windows)\n   - Normalize features using StandardScaler (save scaler with model)\n   - Handle missing data: forward-fill then drop incomplete sequences\n\n3. Training configuration:\n   - RHR model: hidden_dim=128, num_layers=2, dropout=0.2\n   - HRV model: hidden_dim=128, num_layers=2, dropout=0.2\n   - Batch size: 32, learning rate: 0.001\n   - Use Adam optimizer, MSE loss\n   - Train for max 100 epochs with early stopping\n\n4. Model evaluation metrics:\n   - MAE (Mean Absolute Error)\n   - RMSE (Root Mean Square Error)\n   - R² score (>0.5 for production)\n   - MAPE (Mean Absolute Percentage Error, <15% for production)\n\n5. Update PredictionService in `ml-service/app/services/prediction.py`:\n   - Load trained model from disk\n   - Load corresponding scaler\n   - Prepare input sequence from recent features\n   - Run inference and denormalize output\n   - Calculate confidence intervals\n\n6. Model storage structure:\n```\nml-service/models/\n  {user_id}_{metric}_{timestamp}/\n    model.pt              # PyTorch model weights\n    scaler.pkl           # Feature scaler\n    metadata.pkl         # Training config and metrics\n```\n\n7. Add minimum data requirements:\n   - At least 30 days of health data\n   - At least 21 days of nutrition data\n   - Check requirements before training",
        "testStrategy": "1. Unit tests for data preparation pipeline\n2. Test training with synthetic data (verify loss decreases)\n3. Test model save/load roundtrip\n4. Test prediction accuracy on held-out test set\n5. Integration test: full train -> predict flow\n6. Test minimum data requirement validation\n7. Test early stopping triggers correctly",
        "priority": "high",
        "dependencies": [
          "3",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Create Predictions Visualization Mobile UI",
        "description": "Build mobile screens to display ML predictions (RHR, HRV forecasts) with confidence intervals and historical context.",
        "details": "1. Create new screens:\n   - `app/predictions/index.tsx` - Predictions dashboard\n   - `app/predictions/[metric].tsx` - Detailed prediction view\n\n2. Predictions Dashboard (`app/predictions/index.tsx`):\n   - Card for each predictable metric (RHR, HRV)\n   - Display: predicted value, confidence score, direction indicator\n   - Comparison to 30-day average\n   - 'No prediction available' state if model not trained\n   - Pull-to-refresh to get latest predictions\n\n3. Detailed Prediction View (`app/predictions/[metric].tsx`):\n   - Chart showing:\n     - Historical values (last 30 days)\n     - Predicted value for tomorrow\n     - Confidence interval as shaded region\n   - Interpretation text (AI-generated explanation)\n   - Recommendation based on prediction\n   - Feature importance breakdown (what drove this prediction)\n\n4. Create API client in `lib/api/predictions.ts`:\n```typescript\nexport const predictionsApi = {\n  predict: (metric: string, targetDate: string) =>\n    apiClient.post('/api/predictions/predict', { metric, target_date: targetDate }),\n  batchPredict: (metrics: string[], targetDate: string) =>\n    apiClient.post('/api/predictions/batch-predict', { metrics, target_date: targetDate }),\n  listModels: () => apiClient.get('/api/predictions/models'),\n}\n```\n\n5. Chart implementation:\n   - Use Victory Native or react-native-chart-kit\n   - Line chart for historical + predicted\n   - Shaded area for confidence interval\n   - Animate prediction point\n\n6. Handle states:\n   - Loading: Show skeleton\n   - No model trained: Show CTA to collect more data\n   - Prediction available: Show full UI\n   - Error: Show error message with retry",
        "testStrategy": "1. Component tests for dashboard and detail screens\n2. Test chart rendering with mock data\n3. Test loading/error/empty states\n4. Test confidence interval visualization\n5. Test API integration with mock responses\n6. Snapshot tests for consistent UI",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "Implement ML Insights Engine and Recommendations",
        "description": "Build the insights generation system that analyzes correlations and generates personalized nutrition recommendations stored in MLInsight model.",
        "details": "1. Create insights service in `ml-service/app/services/insights_engine.py`:\n```python\nclass InsightsEngine:\n    async def generate_insights(self, user_id: str) -> List[MLInsight]:\n        correlations = await self._get_significant_correlations(user_id)\n        predictions = await self._get_recent_predictions(user_id)\n        anomalies = await self._detect_anomalies(user_id)\n        \n        insights = []\n        insights.extend(self._correlation_insights(correlations))\n        insights.extend(self._prediction_insights(predictions))\n        insights.extend(self._anomaly_insights(anomalies))\n        insights.extend(self._goal_progress_insights(user_id))\n        \n        return self._prioritize_and_limit(insights, max_insights=5)\n```\n\n2. Insight types to implement:\n   - CORRELATION: 'Your protein intake correlates with better HRV (+0.65)'\n   - PREDICTION: 'Tomorrow's RHR is predicted higher than average'\n   - ANOMALY: 'Your sleep duration last night was unusually low'\n   - RECOMMENDATION: 'Try eating dinner earlier to improve sleep quality'\n   - GOAL_PROGRESS: 'You're 80% of the way to your protein goal this week'\n   - PATTERN_DETECTED: 'You tend to eat more carbs on weekends'\n\n3. Correlation-based recommendations:\n   - Use CorrelationEngineService to find significant correlations\n   - Filter by correlation strength (|r| > 0.5)\n   - Generate natural language recommendations\n   - Example: If protein ↔ HRV has r=0.7, recommend 'Increasing protein may improve your HRV'\n\n4. Anomaly detection:\n   - Z-score based detection (>2 std from 30-day mean)\n   - Detect unusual: meal timing, calorie intake, sleep duration\n   - Generate alerts for negative anomalies\n\n5. Create API endpoints in `ml-service/app/api/insights.py`:\n   - GET /api/insights - List user's active insights\n   - POST /api/insights/generate - Trigger insight generation\n   - PUT /api/insights/{id}/viewed - Mark as viewed\n   - PUT /api/insights/{id}/dismissed - Dismiss insight\n   - PUT /api/insights/{id}/feedback - Submit helpful/not helpful\n\n6. Store insights in database using MLInsight model (already defined in Prisma schema)",
        "testStrategy": "1. Unit tests for each insight type generator\n2. Test insight prioritization logic\n3. Test anomaly detection thresholds\n4. Test natural language generation\n5. Integration test: end-to-end insight generation\n6. Test user feedback tracking\n7. Test insight expiration handling",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Build Insights Feed Mobile UI",
        "description": "Create mobile screens to display ML-generated insights, recommendations, and allow user feedback.",
        "details": "1. Create new screens:\n   - `app/insights/index.tsx` - Insights feed/dashboard\n   - `app/insights/[id].tsx` - Detailed insight view\n\n2. Insights Feed (`app/insights/index.tsx`):\n   - List of insight cards sorted by priority and recency\n   - Card components per insight type:\n     - Correlation: Show correlation strength badge\n     - Prediction: Show predicted value and arrow\n     - Anomaly: Show warning indicator\n     - Recommendation: Show actionable tip\n   - Swipe to dismiss functionality\n   - Pull-to-refresh to generate new insights\n   - Empty state: 'Keep logging meals to unlock insights'\n\n3. Insight Card Design:\n```typescript\ninterface InsightCard {\n  icon: string;           // Based on insightType\n  title: string;          // From insight.title\n  description: string;    // Truncated insight.description\n  priority: 'high' | 'medium' | 'low'; // Color coding\n  correlation?: number;   // Show badge if correlation insight\n  timestamp: Date;        // When generated\n}\n```\n\n4. Detailed Insight View (`app/insights/[id].tsx`):\n   - Full description text\n   - Recommendation with call-to-action\n   - Supporting chart/data if applicable\n   - 'Was this helpful?' feedback buttons\n   - Share insight button (future)\n\n5. Create API client in `lib/api/insights.ts`:\n```typescript\nexport const insightsApi = {\n  getAll: () => apiClient.get('/api/insights'),\n  getById: (id: string) => apiClient.get(`/api/insights/${id}`),\n  markViewed: (id: string) => apiClient.put(`/api/insights/${id}/viewed`),\n  dismiss: (id: string) => apiClient.put(`/api/insights/${id}/dismissed`),\n  submitFeedback: (id: string, helpful: boolean) =>\n    apiClient.put(`/api/insights/${id}/feedback`, { helpful }),\n}\n```\n\n6. Add insights badge to tab bar showing unread count",
        "testStrategy": "1. Component tests for insight cards\n2. Test swipe-to-dismiss interaction\n3. Test feedback submission flow\n4. Test empty and loading states\n5. Test priority-based sorting\n6. Visual regression tests for card styles",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Implement AR Portion Size Measurement",
        "description": "Add AR capability to measure food portion dimensions and improve nutrition estimation accuracy.",
        "details": "1. Install AR dependencies:\n   - expo-three (already installed - three.js is in dependencies)\n   - expo-gl (already installed)\n   - @react-three/fiber for React Native\n\n2. Create AR measurement component in `lib/components/ARPortionMeasure.tsx`:\n   - Initialize AR session with plane detection\n   - Render measurement guides on detected surfaces\n   - Allow user to place measurement points\n   - Calculate bounding box dimensions (width, height, depth)\n   - Return dimensions in centimeters\n\n3. Update food scanning flow (`app/scan-food.tsx`):\n   - Add 'Measure with AR' button after capturing photo\n   - Launch AR measurement overlay\n   - Pass dimensions to food analysis API\n   - Update `mockMeasurements` with real AR data\n\n4. AR measurement flow:\n   1. User captures food photo\n   2. User taps 'Measure Portion'\n   3. AR view opens with plane detection\n   4. User taps to place corner points (4 points for bounding box)\n   5. App calculates volume and converts to portion weight\n   6. Dimensions sent to /api/food/analyze\n\n5. Dimension to weight conversion (in food_analysis_service.py):\n   - Already implemented in `_estimate_portion_from_dimensions()`\n   - Uses food density estimates\n   - Returns estimated weight in grams\n\n6. Calibration feature:\n   - Include reference object option (credit card, hand)\n   - Use known dimensions to calibrate scale\n   - Improve accuracy for subsequent measurements\n\n7. Fallback handling:\n   - If AR not supported (older devices), show manual size picker\n   - Options: Small, Medium, Large with example photos",
        "testStrategy": "1. Unit tests for dimension calculation\n2. Test AR component mounting/unmounting\n3. Test plane detection callbacks\n4. Integration test with mock AR data\n5. Test fallback to manual size picker\n6. Manual testing on physical device with AR support\n7. Test calibration accuracy with known objects",
        "priority": "low",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install AR Dependencies and Configure Native Modules",
            "description": "Add required AR dependencies for React Native/Expo including @react-three/fiber, react-three-fiber, and configure native AR capabilities for iOS (ARKit) and Android (ARCore).",
            "dependencies": [],
            "details": "1. Install @react-three/fiber and react-three-fiber packages\n2. Configure expo plugins for AR in app.json (expo-camera already configured)\n3. Set up iOS ARKit permissions in Info.plist (NSCameraUsageDescription already exists)\n4. Configure Android ARCore requirements in AndroidManifest.xml\n5. Verify expo-gl and three.js integration\n6. Create basic AR session test to verify setup\n7. Document AR capability requirements for devices (iOS 11+, ARCore-compatible Android)",
            "status": "done",
            "testStrategy": "1. Test package installation with npm/yarn\n2. Verify expo-gl renders basic 3D scene\n3. Test AR session initialization on iOS simulator (limited) and physical device\n4. Verify ARKit permissions prompt\n5. Test Android ARCore availability detection",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T19:10:26.758Z"
          },
          {
            "id": 2,
            "title": "Create Interactive AR Measurement Component",
            "description": "Build the core ARPortionMeasure component that allows users to tap 4 corner points to create a bounding box and measure food portion dimensions in real-world coordinates.",
            "dependencies": [
              1
            ],
            "details": "1. Create lib/components/ARPortionMeasure.tsx component\n2. Initialize AR session with plane detection enabled\n3. Implement tap-to-place point placement (4 corners for bounding box)\n4. Convert screen coordinates to world coordinates using AR raycasting\n5. Calculate real-world dimensions (width, height, depth) from placed points\n6. Display visual guides showing detected plane surface\n7. Render bounding box overlay with dimension labels\n8. Add point placement indicators and connection lines\n9. Implement reset/undo functionality for point placement\n10. Return ARMeasurement type with confidence scoring based on plane detection quality\n11. Handle edge cases: insufficient plane detection, invalid point placement",
            "status": "done",
            "testStrategy": "1. Unit tests for coordinate conversion calculations\n2. Component tests for point placement state management\n3. Test bounding box dimension calculations with known distances\n4. Test plane detection callbacks and state updates\n5. Integration test with mock AR session data\n6. Manual testing on physical device with various surfaces\n7. Test reset/undo functionality",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T19:16:24.790Z"
          },
          {
            "id": 3,
            "title": "Build AR Measurement Modal/Overlay Screen",
            "description": "Create the modal screen (app/ar-measure-portion.tsx) that launches the AR measurement experience with user instructions and controls.",
            "dependencies": [
              2
            ],
            "details": "1. Create app/ar-measure-portion.tsx as a modal screen\n2. Integrate ARPortionMeasure component into modal\n3. Design instruction UI:\n   - Step-by-step guide for users (detect plane, place 4 corners)\n   - Visual indicators for current step\n   - Progress indicator during plane detection\n4. Add control buttons:\n   - Confirm measurement (validates 4 points placed)\n   - Cancel and return to scan screen\n   - Reset measurement (clear all points)\n5. Display real-time measurement quality indicator\n6. Show current dimensions as user places points\n7. Handle AR session lifecycle (start on mount, cleanup on unmount)\n8. Add error states: no plane detected, AR not supported\n9. Implement navigation: return measured dimensions to caller",
            "status": "done",
            "testStrategy": "1. Component mounting/unmounting tests\n2. Test navigation with expo-router params\n3. Test confirm button validation (requires 4 points)\n4. Test cancel navigation back to scan screen\n5. Test reset functionality clears all state\n6. Integration test: full flow from scan to measurement to confirmation",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T19:22:51.508Z"
          },
          {
            "id": 4,
            "title": "Integrate AR Measurement into Food Scanning Flow",
            "description": "Update scan-food.tsx to include 'Measure with AR' button after photo capture, launch the AR measurement modal, and pass captured dimensions to the food analysis API.",
            "dependencies": [
              3
            ],
            "details": "1. Update scan-food.tsx after photo capture (line 114 area)\n2. Add 'Measure with AR' button alongside 'Analyze Food' button\n3. Implement AR measurement flow:\n   - Launch ar-measure-portion modal\n   - Receive ARMeasurement result from modal\n   - Store measurements in component state\n4. Update foodAnalysisApi.analyzeFood() call to include measurements\n5. Replace mockMeasurements with real AR data\n6. Display measurement quality indicator in UI (high/medium/low badge)\n7. Show captured dimensions in preview (width x height x depth)\n8. Allow re-measurement before final analysis\n9. Handle AR not available gracefully (hide button, show alternative)\n10. Update UI flow: Photo → Measure (optional) → Analyze → Results",
            "status": "pending",
            "testStrategy": "1. Test button visibility after photo capture\n2. Test modal launch with expo-router\n3. Test receiving ARMeasurement data from modal\n4. Test API call includes measurements in request\n5. Test UI updates with measurement quality indicator\n6. Integration test: full scan flow with AR measurement\n7. Test fallback when AR not available",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Reference Object Calibration Feature",
            "description": "Build calibration wizard allowing users to use a credit card or other reference object to improve AR measurement accuracy.",
            "dependencies": [
              2
            ],
            "details": "1. Create lib/components/ARCalibration.tsx component\n2. Implement credit card calibration mode:\n   - Standard dimensions: 85.60mm × 53.98mm\n   - AR measurement of credit card\n   - Calculate calibration factor: measured/actual\n3. Build calibration wizard UI:\n   - Introduction screen explaining calibration\n   - Place credit card on surface instructions\n   - Measure card with AR (4 corner points)\n   - Validation: check if dimensions are reasonable (within 20% of standard)\n   - Success/failure feedback\n4. Store calibration factor in AsyncStorage/SecureStore\n5. Apply calibration to subsequent measurements (multiply by factor)\n6. Add calibration status indicator in AR measurement screen\n7. Optional: Allow re-calibration from settings\n8. Optional: Support other reference objects (smartphone, hand span)\n9. Create lib/utils/calibration.ts for storage and retrieval",
            "status": "pending",
            "testStrategy": "1. Test calibration factor calculation\n2. Test storage and retrieval of calibration data\n3. Test validation of measured card dimensions\n4. Test applying calibration to measurements\n5. Component tests for calibration wizard\n6. Integration test: calibrate then measure food\n7. Test calibration persistence across app restarts",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create Fallback Manual Size Picker for Non-AR Devices",
            "description": "Build a manual size selection UI for devices without AR/LiDAR support, providing Small/Medium/Large presets with visual references.",
            "dependencies": [],
            "details": "1. Create lib/components/ManualSizePicker.tsx component\n2. Implement size selector options:\n   - Small (e.g., 5cm × 5cm × 5cm → ~87g assuming 0.7 density)\n   - Medium (e.g., 10cm × 10cm × 10cm → ~700g)\n   - Large (e.g., 15cm × 15cm × 15cm → ~2.3kg)\n   - Custom (slider input for each dimension)\n3. Add visual reference images for each size:\n   - Small: Size of a golf ball\n   - Medium: Size of a baseball\n   - Large: Size of a grapefruit\n4. Implement custom slider:\n   - Width slider (1-30cm)\n   - Height slider (1-30cm)\n   - Depth slider (1-30cm)\n   - Real-time volume calculation display\n5. Convert selected size to ARMeasurement type:\n   - Set confidence: 'low' (manual estimate)\n   - Set planeDetected: false\n   - Set distance, width, height, depth\n6. Integrate into scan-food.tsx as fallback when AR unavailable\n7. Show manual picker when device lacks AR support or user declines AR permissions",
            "status": "done",
            "testStrategy": "1. Component tests for size selection state\n2. Test dimension calculations for presets\n3. Test slider value updates and bounds\n4. Test conversion to ARMeasurement format\n5. Test integration with scan flow\n6. Visual regression tests for UI\n7. Test device AR capability detection",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T18:02:37.997Z"
          },
          {
            "id": 7,
            "title": "Add Dimension-to-Weight Conversion Utilities",
            "description": "Create client-side utilities for volume calculation, food density lookup, and weight estimation to complement the ML service's backend estimation.",
            "dependencies": [],
            "details": "1. Create lib/utils/portion-estimation.ts utility file\n2. Implement volume calculation:\n   - volumeFromDimensions(width, height, depth): cm³\n   - applyShapeFactor(volume, shapeFactor): adjusted cm³\n3. Create food density lookup table:\n   - Common foods with g/cm³ density values\n   - Categorized by food type (fruits, vegetables, proteins, grains)\n   - Default density for unknown foods\n4. Implement weight estimation:\n   - estimateWeight(volume, foodType): grams\n   - Confidence score based on food type match\n   - Apply min/max bounds (1g - 5000g)\n5. Add unit conversion helpers:\n   - cmToInches(cm), inchesToCm(inches)\n   - gramsToOz(grams), ozToGrams(oz)\n   - volumeCm3ToMl(cm3), mlToVolumeCm3(ml)\n6. Create TypeScript interfaces for density data\n7. Export utility functions for use in components",
            "status": "done",
            "testStrategy": "1. Unit tests for volume calculations with known dimensions\n2. Test shape factor application\n3. Test density lookup for various food types\n4. Test weight estimation accuracy\n5. Test unit conversions (bidirectional)\n6. Test bounds enforcement (min/max weight)\n7. Test confidence scoring logic",
            "updatedAt": "2025-12-05T17:51:26.304Z",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Write Comprehensive Tests for AR Measurement System",
            "description": "Create unit, component, and integration tests covering the entire AR measurement feature including edge cases and device compatibility.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "1. Unit tests for dimension calculations:\n   - Test bounding box calculation from 4 points\n   - Test coordinate conversion (screen to world)\n   - Test volume and weight calculations\n   - Test calibration factor application\n2. Component tests for ARPortionMeasure:\n   - Test point placement state management\n   - Test plane detection callbacks\n   - Test measurement completion validation\n   - Test reset functionality\n3. Component tests for ar-measure-portion modal:\n   - Test modal lifecycle (mount, unmount)\n   - Test navigation with params\n   - Test instruction UI state transitions\n4. Integration tests for measurement flow:\n   - Test full flow: scan → measure → analyze\n   - Test with calibration applied\n   - Test fallback to manual picker\n   - Test error handling (no plane, invalid points)\n5. Mock tests for devices without AR:\n   - Mock AR availability check\n   - Test manual picker display\n   - Test manual measurements passed to API\n6. Test calibration accuracy:\n   - Test with known reference object dimensions\n   - Test calibration persistence\n   - Test validation logic\n7. Add test fixtures:\n   - Mock ARMeasurement data\n   - Mock AR session responses\n   - Mock plane detection results\n8. Create test documentation in README or docs/testing.md",
            "status": "done",
            "testStrategy": "1. Run full test suite with jest\n2. Verify 80%+ code coverage for AR modules\n3. Test on iOS simulator (limited AR)\n4. Test on physical iOS device with ARKit\n5. Test on Android device with ARCore\n6. Test on older devices without AR support\n7. Regression testing after changes",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T19:45:52.543Z"
          }
        ],
        "updatedAt": "2025-12-05T19:45:57.388Z"
      },
      {
        "id": "11",
        "title": "Generate OpenAPI Documentation and Polish Production Readiness",
        "description": "Add comprehensive API documentation, perform security audit, and optimize performance for production deployment.",
        "details": "1. Generate OpenAPI/Swagger documentation:\n   - Backend (Express): Add swagger-jsdoc and swagger-ui-express\n   - ML Service (FastAPI): Already has built-in docs at /docs\n   - Document all endpoints with request/response schemas\n   - Add authentication requirements\n   - Include example requests and responses\n\n2. Express API documentation setup:\n```javascript\nimport swaggerJsdoc from 'swagger-jsdoc';\nimport swaggerUi from 'swagger-ui-express';\n\nconst options = {\n  definition: {\n    openapi: '3.0.0',\n    info: { title: 'Nutri API', version: '1.0.0' },\n    servers: [{ url: '/api' }],\n    components: {\n      securitySchemes: {\n        bearerAuth: { type: 'http', scheme: 'bearer' }\n      }\n    }\n  },\n  apis: ['./src/routes/*.ts'],\n};\n\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerJsdoc(options)));\n```\n\n3. Performance optimization:\n   - Add database query logging to identify slow queries\n   - Implement connection pooling for PostgreSQL\n   - Add Redis caching for frequently accessed data (user profile, daily summary)\n   - Compress API responses with compression middleware\n   - Optimize Prisma queries with select/include\n\n4. Security audit checklist:\n   - Review all authentication flows\n   - Verify rate limiting is effective\n   - Check for SQL injection (Prisma handles this)\n   - Verify XSS prevention in sanitize middleware\n   - Review CORS configuration\n   - Ensure sensitive data not logged\n   - Check JWT secret rotation capability\n\n5. Production configuration:\n   - Environment variable validation on startup\n   - Health check endpoints for load balancers\n   - Graceful shutdown handling\n   - Error tracking integration (Sentry ready)\n   - Logging configuration (structured JSON logs)\n\n6. Mobile app optimization:\n   - Review bundle size\n   - Implement proper loading states\n   - Add offline detection and handling\n   - Optimize image handling\n\n7. Create deployment documentation:\n   - Docker setup for backend and ML service\n   - Environment variables reference\n   - Database migration guide\n   - Monitoring recommendations",
        "testStrategy": "1. Validate OpenAPI spec with swagger-cli validate\n2. Load testing with k6 or artillery (100 concurrent users)\n3. Security scan with npm audit and OWASP ZAP\n4. Test rate limiting triggers correctly\n5. Test graceful shutdown\n6. Verify logging output format\n7. Test health check endpoints\n8. Performance benchmark for critical endpoints",
        "priority": "low",
        "dependencies": [
          "2",
          "3",
          "4",
          "6"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-05T19:45:57.393Z",
      "taskCount": 10,
      "completedCount": 1,
      "tags": [
        "master"
      ]
    }
  }
}