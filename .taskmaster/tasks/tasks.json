{
  "master": {
    "tasks": [
      {
        "id": 2,
        "title": "Implement Real Food Classification ML Model",
        "description": "Replace the mock food classifier in ml-service/app/services/food_analysis_service.py with a real CNN model (EfficientNet or ResNet) trained on food image datasets.",
        "details": "1. Create a new module `ml-service/app/ml_models/food_classifier.py` with:\n   - Load pre-trained EfficientNet-B0 or ResNet-50 from torchvision\n   - Fine-tune on Food-101 dataset or custom food dataset\n   - Implement proper image preprocessing pipeline matching ImageNet stats\n   - Support for GPU inference if available (auto-detect CUDA)\n\n2. Update `food_analysis_service.py`:\n   - Replace `NUTRITION_DATABASE` with a proper food database (USDA FoodData Central API integration)\n   - Update `_classify_food()` to use real model inference instead of random selection\n   - Add model loading with caching to avoid reloading on each request\n   - Implement top-5 predictions with confidence scores\n\n3. Add model versioning:\n   - Store model checkpoints in `ml-service/models/food_classifier/`\n   - Add `model_version` field to responses\n   - Implement A/B testing capability by loading multiple model versions\n\n4. Extend nutrition database:\n   - Expand from current 6 items to 100+ common foods\n   - Structure: JSON file or SQLite database with USDA data\n   - Include serving size variations (small, medium, large)\n\nPseudo-code for classifier:\n```python\nclass FoodClassifier:\n    def __init__(self, model_path: str = None):\n        self.model = self._load_model(model_path)\n        self.classes = self._load_class_labels()\n    \n    def _load_model(self, path):\n        model = torchvision.models.efficientnet_b0(pretrained=True)\n        model.classifier[-1] = nn.Linear(1280, num_food_classes)\n        if path:\n            model.load_state_dict(torch.load(path))\n        model.eval()\n        return model\n    \n    async def classify(self, image: np.ndarray) -> List[Tuple[str, float]]:\n        tensor = self._preprocess(image)\n        with torch.no_grad():\n            outputs = self.model(tensor)\n            probs = torch.softmax(outputs, dim=1)\n        return self._get_top_k(probs, k=5)\n```",
        "testStrategy": "1. Unit tests for model loading and inference\n2. Test classification accuracy on held-out test set (target >80% top-5)\n3. Integration test: POST /api/food/analyze with real food images\n4. Performance test: Inference time <3s per image\n5. Test model fallback when GPU not available",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Build Health Metrics Mobile UI Screens",
        "description": "Create mobile screens for viewing and manually entering health metrics (RHR, HRV, sleep, recovery). Backend API is complete at /api/health-metrics.",
        "details": "1. Create new screens in `app/` directory:\n   - `app/health/index.tsx` - Health metrics dashboard/list\n   - `app/health/[id].tsx` - Detail view for specific metric\n   - `app/health/add.tsx` - Manual entry form\n\n2. Health Dashboard (`app/health/index.tsx`):\n   - Display today's key metrics in cards (RHR, HRV, Sleep, Recovery)\n   - Time range selector: Today, Week, Month\n   - Pull-to-refresh functionality\n   - Navigate to detail view on tap\n\n3. Metric Detail View (`app/health/[id].tsx`):\n   - Line chart showing metric over time (use react-native-chart-kit or Victory Native)\n   - Statistics: avg, min, max, trend arrow\n   - Data source indicator (Apple Health, Fitbit, Manual)\n   - Date range filter\n\n4. Manual Entry Form (`app/health/add.tsx`):\n   - Metric type picker (dropdown with all HealthMetricType enum values)\n   - Value input with unit display (bpm, ms, hours, %)\n   - Date/time picker (defaults to now)\n   - Source set to 'MANUAL'\n   - Validation: min/max ranges per metric type\n\n5. Create API client in `lib/api/health-metrics.ts`:\n```typescript\nexport const healthMetricsApi = {\n  getAll: (params: { startDate?: string; endDate?: string; metricType?: string }) => \n    apiClient.get('/health-metrics', { params }),\n  getById: (id: string) => apiClient.get(`/health-metrics/${id}`),\n  create: (data: CreateHealthMetricInput) => apiClient.post('/health-metrics', data),\n  getDailySummary: (date: string) => apiClient.get(`/health-metrics/daily/${date}`),\n}\n```\n\n6. Add navigation:\n   - Add 'Health' tab to bottom navigation in `app/(tabs)/_layout.tsx`\n   - Use health heart icon from @expo/vector-icons",
        "testStrategy": "1. Component tests for each screen using react-native-testing-library\n2. Test form validation for manual entry\n3. Test API integration with mock server\n4. Visual regression tests for chart rendering\n5. Test pull-to-refresh behavior\n6. Test empty state when no health data exists",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Build Activity Tracking Mobile UI Screens",
        "description": "Create mobile screens for viewing and manually logging activities. Backend API is complete at /api/activities.",
        "details": "1. Create new screens in `app/` directory:\n   - `app/activity/index.tsx` - Activity list/history\n   - `app/activity/[id].tsx` - Activity detail view\n   - `app/activity/add.tsx` - Manual activity entry form\n\n2. Activity List (`app/activity/index.tsx`):\n   - Weekly summary card: total minutes, calories, workout count\n   - Filter by activity type (All, Cardio, Strength, Flexibility)\n   - List of recent activities with icon, duration, calories\n   - Floating action button to add new activity\n   - Pull-to-refresh\n\n3. Activity Detail View (`app/activity/[id].tsx`):\n   - Display all activity fields: type, duration, intensity, calories\n   - Heart rate data if available (avg, max)\n   - Distance and steps for applicable activities\n   - Notes field\n   - Edit/Delete buttons\n\n4. Manual Entry Form (`app/activity/add.tsx`):\n   - Activity type picker (21 types from ActivityType enum)\n   - Intensity picker (Low, Moderate, High, Maximum)\n   - Duration input (hours:minutes picker)\n   - Date/time pickers for start time\n   - Optional fields: calories, heart rate, distance, notes\n   - Validation: duration > 0, end time > start time\n\n5. Create API client in `lib/api/activities.ts`:\n```typescript\nexport const activitiesApi = {\n  getAll: (params?: { activityType?: string; startDate?: string }) =>\n    apiClient.get('/activities', { params }),\n  getById: (id: string) => apiClient.get(`/activities/${id}`),\n  create: (data: CreateActivityInput) => apiClient.post('/activities', data),\n  update: (id: string, data: Partial<CreateActivityInput>) =>\n    apiClient.put(`/activities/${id}`, data),\n  delete: (id: string) => apiClient.delete(`/activities/${id}`),\n  getWeeklySummary: () => apiClient.get('/activities/weekly-summary'),\n}\n```\n\n6. Add activity icons mapping for different activity types",
        "testStrategy": "1. Component tests for each screen\n2. Test form validation (duration, time constraints)\n3. Test activity type filtering\n4. Test CRUD operations with mock API\n5. Test weekly summary calculation display\n6. Test edit/delete flows with confirmation dialogs",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Apple HealthKit Integration",
        "description": "Enable automatic sync of comprehensive health data from Apple HealthKit including cardiovascular metrics (RHR, Heart Rate, HRV SDNN/RMSSD), sleep quality metrics (duration, deep sleep, REM, efficiency, score), respiratory data (respiratory rate, oxygen saturation), and VO2Max.",
        "status": "in-progress",
        "dependencies": [
          "3",
          "4"
        ],
        "priority": "medium",
        "details": "1. Install and configure react-native-health (recommended for Expo managed workflow):\n   - Add `react-native-health` to package.json dependencies\n   - Configure `app.json` with NSHealthShareUsageDescription and NSHealthUpdateUsageDescription\n   - Add HealthKit entitlement to iOS build configuration\n   - Request HealthKit permissions on iOS for all metric types\n\n2. **Schema Consideration**: The existing Prisma HealthMetricType enum in `server/prisma/schema.prisma` already supports:\n   - Cardiovascular: `RESTING_HEART_RATE`, `HEART_RATE_VARIABILITY_SDNN`, `HEART_RATE_VARIABILITY_RMSSD`\n   - Respiratory: `RESPIRATORY_RATE`, `OXYGEN_SATURATION`, `VO2_MAX`\n   - Sleep: `SLEEP_DURATION`, `DEEP_SLEEP_DURATION`, `REM_SLEEP_DURATION`, `SLEEP_EFFICIENCY`, `SLEEP_SCORE`\n   - NOTE: Consider adding `HEART_RATE` (instantaneous/average HR, separate from resting) if needed for workout HR data\n\n3. Create health sync service in `lib/services/healthkit.ts`:\n```typescript\nexport interface HealthKitConfig {\n  permissions: {\n    read: HealthKitPermission[];\n    write?: HealthKitPermission[];\n  };\n}\n\nexport const healthKitService = {\n  // Initialize and request permissions\n  requestPermissions: () => Promise<boolean>,\n  isAvailable: () => Promise<boolean>,\n  \n  // Sync cardiovascular data\n  syncCardiovascularMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKQuantityTypeIdentifierRestingHeartRate → RESTING_HEART_RATE\n  // - HKQuantityTypeIdentifierHeartRate → instantaneous HR samples\n  // - HKQuantityTypeIdentifierHeartRateVariabilitySDNN → HEART_RATE_VARIABILITY_SDNN\n  // - HKQuantityTypeIdentifier.heartRateVariabilityRMSSD (if available)\n  \n  // Sync respiratory data\n  syncRespiratoryMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKQuantityTypeIdentifierRespiratoryRate → RESPIRATORY_RATE\n  // - HKQuantityTypeIdentifierOxygenSaturation → OXYGEN_SATURATION\n  // - HKQuantityTypeIdentifierVO2Max → VO2_MAX\n  \n  // Sync sleep data\n  syncSleepMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKCategoryTypeIdentifierSleepAnalysis → parse into:\n  //   - SLEEP_DURATION (total sleep time)\n  //   - DEEP_SLEEP_DURATION (deep/core sleep stages)\n  //   - REM_SLEEP_DURATION (REM stages)\n  //   - SLEEP_EFFICIENCY (time asleep / time in bed)\n  //   - SLEEP_SCORE (if available from source)\n  \n  // Sync activity data\n  syncActivityMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKQuantityTypeIdentifierStepCount → STEPS\n  // - HKQuantityTypeIdentifierActiveEnergyBurned → ACTIVE_CALORIES\n  // - HKWorkoutType → Activity model with exercise HR data\n  \n  // Background sync\n  setupBackgroundSync: () => void,\n}\n```\n\n4. HealthKit type identifiers mapping:\n```typescript\nconst HEALTHKIT_TYPE_MAP = {\n  // Cardiovascular\n  HKQuantityTypeIdentifierRestingHeartRate: 'RESTING_HEART_RATE',\n  HKQuantityTypeIdentifierHeartRateVariabilitySDNN: 'HEART_RATE_VARIABILITY_SDNN',\n  // Note: RMSSD might need manual calculation from RR intervals\n  \n  // Respiratory\n  HKQuantityTypeIdentifierRespiratoryRate: 'RESPIRATORY_RATE',\n  HKQuantityTypeIdentifierOxygenSaturation: 'OXYGEN_SATURATION',\n  HKQuantityTypeIdentifierVO2Max: 'VO2_MAX',\n  \n  // Sleep (requires parsing HKCategoryTypeIdentifierSleepAnalysis)\n  // Sleep stages: inBed, asleepUnspecified, awake, asleepCore, asleepDeep, asleepREM\n  \n  // Activity\n  HKQuantityTypeIdentifierStepCount: 'STEPS',\n  HKQuantityTypeIdentifierActiveEnergyBurned: 'ACTIVE_CALORIES',\n};\n```\n\n5. Implement data transformation layer:\n   - Convert HealthKit units to API units (bpm, ms, %, steps, kcal, etc.)\n   - Match existing Zod validation schemas in `server/src/validation/schemas.ts`\n   - Use source: 'apple_health' to match healthMetricSourceSchema\n   - Include device metadata: {device: \"Apple Watch\", quality: \"high\"}\n\n6. Create sync flow:\n   - Initial sync: Fetch last 30 days of data on first connect\n   - Incremental sync: Fetch data since last sync timestamp\n   - Store lastSyncTimestamp in Expo SecureStore (per metric type for efficiency)\n   - Batch API calls using bulkCreateHealthMetricsSchema (50 items per request)\n   - Handle timezone conversions (HealthKit returns local time, API expects UTC)\n\n7. Handle data deduplication:\n   - Use existing (userId, metricType, recordedAt, source) unique constraint in schema\n   - Server handles conflicts via upsert\n   - Store sourceId from HealthKit sample UUID for traceability\n\n8. Add sync UI in profile settings (app/profile.tsx or new app/settings/health.tsx):\n   - Connect/Disconnect Apple Health button\n   - Permission status for each metric category\n   - Last sync timestamp display (per category)\n   - Manual sync button with progress indicator\n   - Sync status indicator (syncing, synced, error)\n   - Data preview showing recently synced metrics\n\n9. Handle background sync (future enhancement):\n   - Configure iOS background fetch capability\n   - Sync when app becomes active via AppState listener\n   - Respect battery and data usage settings\n   - Consider using HealthKit's HKObserverQuery for real-time updates",
        "testStrategy": "1. Unit tests for HealthKit service:\n   - Mock react-native-health module for simulator testing\n   - Test permission request flow and error handling\n   - Test data transformation for each metric type (HK format → API format)\n   - Test unit conversions (HK units → standard units)\n\n2. Test cardiovascular data sync:\n   - Mock RHR samples → verify RESTING_HEART_RATE records\n   - Mock HRV samples → verify HEART_RATE_VARIABILITY_SDNN records\n   - Test edge cases: missing data, invalid values\n\n3. Test respiratory data sync:\n   - Mock respiratory rate → verify RESPIRATORY_RATE records\n   - Mock SpO2 → verify OXYGEN_SATURATION records\n   - Mock VO2Max → verify VO2_MAX records\n\n4. Test sleep data parsing:\n   - Mock sleep analysis categories → verify correct stage classification\n   - Test sleep efficiency calculation (time asleep / time in bed)\n   - Test sleep duration aggregation across fragmented sleep\n\n5. Test sync error handling and retry logic:\n   - Network errors during bulk upload\n   - Partial failures in batch operations\n   - Permission denied scenarios\n\n6. Test deduplication with existing data:\n   - Re-sync same data → verify no duplicates\n   - Test sourceId matching\n\n7. Test UI state updates during sync:\n   - Loading states\n   - Progress indication\n   - Error display\n\n8. Manual testing on physical device:\n   - Test with real Apple Watch data\n   - Verify data accuracy against Health app\n   - Test permission prompts\n   - Test background sync behavior",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure react-native-health package",
            "description": "Add react-native-health dependency and configure iOS build settings with proper entitlements and Info.plist descriptions",
            "dependencies": [],
            "details": "Install react-native-health via npm/yarn. Update app.json with NSHealthShareUsageDescription explaining why the app needs read access to health data. Add HealthKit entitlement. Configure iOS build to include HealthKit framework. Test that the package builds correctly on iOS simulator/device.",
            "status": "pending",
            "testStrategy": "Verify package installs without errors. Confirm iOS build succeeds. Check Info.plist contains correct health usage descriptions.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create HealthKit permission management system",
            "description": "Implement permission request flow for all required HealthKit data types including cardiovascular, respiratory, and sleep metrics",
            "dependencies": [
              1
            ],
            "details": "Create lib/services/healthkit/permissions.ts. Define permission sets for each metric category. Implement isAvailable() check for HealthKit. Implement requestPermissions() with granular permission requests. Handle partial permission grants gracefully. Store permission status in context/state.",
            "status": "pending",
            "testStrategy": "Mock HealthKit permissions. Test all permission states (granted, denied, not determined). Test partial permission scenarios.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement cardiovascular metrics sync (RHR, HR, HRV)",
            "description": "Create sync functions for Resting Heart Rate, Heart Rate samples, and Heart Rate Variability (SDNN and RMSSD)",
            "dependencies": [
              2
            ],
            "details": "Implement syncCardiovascularMetrics() in healthkit.ts. Query HKQuantityTypeIdentifierRestingHeartRate for RHR. Query HKQuantityTypeIdentifierHeartRateVariabilitySDNN for HRV. Transform HealthKit samples to match HealthMetric API format. Handle unit conversions (HK returns bpm/ms). Include device metadata from sample source.",
            "status": "pending",
            "testStrategy": "Mock HK cardiovascular queries. Verify correct transformation to RESTING_HEART_RATE and HEART_RATE_VARIABILITY_SDNN types. Test unit handling.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement respiratory metrics sync (respiratory rate, SpO2, VO2Max)",
            "description": "Create sync functions for respiratory rate, oxygen saturation, and VO2Max data from HealthKit",
            "dependencies": [
              2
            ],
            "details": "Implement syncRespiratoryMetrics() in healthkit.ts. Query HKQuantityTypeIdentifierRespiratoryRate, HKQuantityTypeIdentifierOxygenSaturation, and HKQuantityTypeIdentifierVO2Max. Transform to RESPIRATORY_RATE, OXYGEN_SATURATION, and VO2_MAX metric types. Handle different sample frequencies (VO2Max is less frequent).",
            "status": "pending",
            "testStrategy": "Mock HK respiratory queries. Verify correct transformation to API format. Test handling of sparse VO2Max data.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement sleep metrics sync with stage classification",
            "description": "Create sync function for sleep analysis including duration, deep sleep, REM, and efficiency calculations",
            "dependencies": [
              2
            ],
            "details": "Implement syncSleepMetrics() in healthkit.ts. Query HKCategoryTypeIdentifierSleepAnalysis. Parse sleep stages (asleepCore→DEEP_SLEEP, asleepDeep→DEEP_SLEEP, asleepREM→REM_SLEEP). Calculate total SLEEP_DURATION. Calculate SLEEP_EFFICIENCY (asleep time / in bed time). Handle fragmented sleep sessions.",
            "status": "pending",
            "testStrategy": "Mock HK sleep analysis with various stage combinations. Verify correct duration calculations. Test efficiency calculation accuracy. Test fragmented sleep handling.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement activity metrics sync (steps, active calories)",
            "description": "Create sync function for daily activity data including step count and active energy burned",
            "dependencies": [
              2
            ],
            "details": "Implement syncActivityMetrics() in healthkit.ts. Query HKQuantityTypeIdentifierStepCount and HKQuantityTypeIdentifierActiveEnergyBurned. Aggregate daily totals. Transform to STEPS and ACTIVE_CALORIES metric types. Handle timezone boundaries for daily aggregation.",
            "status": "pending",
            "testStrategy": "Mock HK activity queries. Verify daily aggregation logic. Test timezone handling for day boundaries.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Create batch sync orchestration with API integration",
            "description": "Implement the main sync orchestration that coordinates all metric syncs and uploads to the backend API",
            "dependencies": [
              3,
              4,
              5,
              6
            ],
            "details": "Create syncAllHealthData() coordinator function. Implement incremental sync using stored lastSyncTimestamp from SecureStore. Batch API uploads using bulkCreateHealthMetricsSchema (50 items per request). Handle partial failures and retry logic. Update lastSyncTimestamp per metric category on success.",
            "status": "pending",
            "testStrategy": "Test full sync orchestration flow. Verify batch chunking at 50 items. Test incremental sync with stored timestamps. Test error handling and retry.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Build HealthKit settings UI with sync controls",
            "description": "Create the user interface for managing HealthKit connection, viewing sync status, and triggering manual syncs",
            "dependencies": [
              7
            ],
            "details": "Create app/settings/health.tsx screen or add section to app/profile.tsx. Display Connect/Disconnect Apple Health button. Show permission status per metric category with toggle indicators. Display last sync timestamp and synced data counts. Add manual Sync Now button with progress indicator. Show sync status (syncing/synced/error) with appropriate feedback.",
            "status": "pending",
            "testStrategy": "Test UI component rendering. Test connect/disconnect flow. Test sync button interaction and loading states. Test error state display.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down the Apple HealthKit integration into implementation phases:\n\n1. **Library Setup & Configuration**: Install react-native-health or expo-health-connect, configure iOS entitlements in app.json (NSHealthShareUsageDescription), and set up the Expo plugin. Research which library works best with Expo SDK 52.\n\n2. **HealthKit Service Core**: Create `lib/services/healthkit.ts` with typed interfaces matching the existing TypeScript patterns in `lib/types/index.ts`. Implement the base service structure with permission request methods.\n\n3. **Data Fetching Implementation**: Implement data fetching for each metric type mapping HealthKit identifiers to the existing HealthMetricType enum (RESTING_HEART_RATE, HEART_RATE_VARIABILITY_SDNN, SLEEP_DURATION, STEPS, ACTIVE_CALORIES). Note: Add ACTIVE_HEART_RATE to schema.prisma for instantaneous HR.\n\n4. **Activity Sync Implementation**: Map HKWorkoutType to the existing ActivityType enum (RUNNING, CYCLING, SWIMMING, etc.) in schema.prisma. Handle activity data transformation.\n\n5. **Sync Logic & State Management**: Implement initial sync (30 days), incremental sync with lastSyncTimestamp stored in SecureStore (pattern from lib/api/client.ts), batch API calls (50 items/request), and leverage the existing bulk endpoint at `/api/health-metrics/bulk`.\n\n6. **Profile UI Integration**: Extend the existing `app/(tabs)/profile.tsx` with a Health Integration section. Add Connect/Disconnect Apple Health button, sync status indicators, last sync timestamp display, and manual sync button following the existing design patterns.\n\n7. **Testing & Error Handling**: Mock HealthKit data for simulator, test permission flows, data transformation, sync error handling/retry logic, and UI state updates. Follow existing error handling patterns in lib/utils/errorHandling.ts.",
        "updatedAt": "2025-12-04T21:22:52.954Z"
      },
      {
        "id": 6,
        "title": "Train and Deploy LSTM Models for Health Predictions",
        "description": "Train LSTM models for RHR and HRV prediction using the existing model architecture in ml-service/app/ml_models/lstm.py and make them production-ready.",
        "details": "1. Create training pipeline in `ml-service/app/services/model_training.py`:\n   - Already has TrainModelRequest/Response schemas\n   - Implement data loading from database\n   - Create training/validation split (80/20)\n   - Add early stopping with patience=10\n   - Save model checkpoints and metadata\n\n2. Training data preparation:\n   - Use FeatureEngineeringService to generate features\n   - Create sliding window sequences (30-day windows)\n   - Normalize features using StandardScaler (save scaler with model)\n   - Handle missing data: forward-fill then drop incomplete sequences\n\n3. Training configuration:\n   - RHR model: hidden_dim=128, num_layers=2, dropout=0.2\n   - HRV model: hidden_dim=128, num_layers=2, dropout=0.2\n   - Batch size: 32, learning rate: 0.001\n   - Use Adam optimizer, MSE loss\n   - Train for max 100 epochs with early stopping\n\n4. Model evaluation metrics:\n   - MAE (Mean Absolute Error)\n   - RMSE (Root Mean Square Error)\n   - R² score (>0.5 for production)\n   - MAPE (Mean Absolute Percentage Error, <15% for production)\n\n5. Update PredictionService in `ml-service/app/services/prediction.py`:\n   - Load trained model from disk\n   - Load corresponding scaler\n   - Prepare input sequence from recent features\n   - Run inference and denormalize output\n   - Calculate confidence intervals\n\n6. Model storage structure:\n```\nml-service/models/\n  {user_id}_{metric}_{timestamp}/\n    model.pt              # PyTorch model weights\n    scaler.pkl           # Feature scaler\n    metadata.pkl         # Training config and metrics\n```\n\n7. Add minimum data requirements:\n   - At least 30 days of health data\n   - At least 21 days of nutrition data\n   - Check requirements before training",
        "testStrategy": "1. Unit tests for data preparation pipeline\n2. Test training with synthetic data (verify loss decreases)\n3. Test model save/load roundtrip\n4. Test prediction accuracy on held-out test set\n5. Integration test: full train -> predict flow\n6. Test minimum data requirement validation\n7. Test early stopping triggers correctly",
        "priority": "high",
        "dependencies": [
          "3",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create Predictions Visualization Mobile UI",
        "description": "Build mobile screens to display ML predictions (RHR, HRV forecasts) with confidence intervals and historical context.",
        "details": "1. Create new screens:\n   - `app/predictions/index.tsx` - Predictions dashboard\n   - `app/predictions/[metric].tsx` - Detailed prediction view\n\n2. Predictions Dashboard (`app/predictions/index.tsx`):\n   - Card for each predictable metric (RHR, HRV)\n   - Display: predicted value, confidence score, direction indicator\n   - Comparison to 30-day average\n   - 'No prediction available' state if model not trained\n   - Pull-to-refresh to get latest predictions\n\n3. Detailed Prediction View (`app/predictions/[metric].tsx`):\n   - Chart showing:\n     - Historical values (last 30 days)\n     - Predicted value for tomorrow\n     - Confidence interval as shaded region\n   - Interpretation text (AI-generated explanation)\n   - Recommendation based on prediction\n   - Feature importance breakdown (what drove this prediction)\n\n4. Create API client in `lib/api/predictions.ts`:\n```typescript\nexport const predictionsApi = {\n  predict: (metric: string, targetDate: string) =>\n    apiClient.post('/api/predictions/predict', { metric, target_date: targetDate }),\n  batchPredict: (metrics: string[], targetDate: string) =>\n    apiClient.post('/api/predictions/batch-predict', { metrics, target_date: targetDate }),\n  listModels: () => apiClient.get('/api/predictions/models'),\n}\n```\n\n5. Chart implementation:\n   - Use Victory Native or react-native-chart-kit\n   - Line chart for historical + predicted\n   - Shaded area for confidence interval\n   - Animate prediction point\n\n6. Handle states:\n   - Loading: Show skeleton\n   - No model trained: Show CTA to collect more data\n   - Prediction available: Show full UI\n   - Error: Show error message with retry",
        "testStrategy": "1. Component tests for dashboard and detail screens\n2. Test chart rendering with mock data\n3. Test loading/error/empty states\n4. Test confidence interval visualization\n5. Test API integration with mock responses\n6. Snapshot tests for consistent UI",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement ML Insights Engine and Recommendations",
        "description": "Build the insights generation system that analyzes correlations and generates personalized nutrition recommendations stored in MLInsight model.",
        "details": "1. Create insights service in `ml-service/app/services/insights_engine.py`:\n```python\nclass InsightsEngine:\n    async def generate_insights(self, user_id: str) -> List[MLInsight]:\n        correlations = await self._get_significant_correlations(user_id)\n        predictions = await self._get_recent_predictions(user_id)\n        anomalies = await self._detect_anomalies(user_id)\n        \n        insights = []\n        insights.extend(self._correlation_insights(correlations))\n        insights.extend(self._prediction_insights(predictions))\n        insights.extend(self._anomaly_insights(anomalies))\n        insights.extend(self._goal_progress_insights(user_id))\n        \n        return self._prioritize_and_limit(insights, max_insights=5)\n```\n\n2. Insight types to implement:\n   - CORRELATION: 'Your protein intake correlates with better HRV (+0.65)'\n   - PREDICTION: 'Tomorrow's RHR is predicted higher than average'\n   - ANOMALY: 'Your sleep duration last night was unusually low'\n   - RECOMMENDATION: 'Try eating dinner earlier to improve sleep quality'\n   - GOAL_PROGRESS: 'You're 80% of the way to your protein goal this week'\n   - PATTERN_DETECTED: 'You tend to eat more carbs on weekends'\n\n3. Correlation-based recommendations:\n   - Use CorrelationEngineService to find significant correlations\n   - Filter by correlation strength (|r| > 0.5)\n   - Generate natural language recommendations\n   - Example: If protein ↔ HRV has r=0.7, recommend 'Increasing protein may improve your HRV'\n\n4. Anomaly detection:\n   - Z-score based detection (>2 std from 30-day mean)\n   - Detect unusual: meal timing, calorie intake, sleep duration\n   - Generate alerts for negative anomalies\n\n5. Create API endpoints in `ml-service/app/api/insights.py`:\n   - GET /api/insights - List user's active insights\n   - POST /api/insights/generate - Trigger insight generation\n   - PUT /api/insights/{id}/viewed - Mark as viewed\n   - PUT /api/insights/{id}/dismissed - Dismiss insight\n   - PUT /api/insights/{id}/feedback - Submit helpful/not helpful\n\n6. Store insights in database using MLInsight model (already defined in Prisma schema)",
        "testStrategy": "1. Unit tests for each insight type generator\n2. Test insight prioritization logic\n3. Test anomaly detection thresholds\n4. Test natural language generation\n5. Integration test: end-to-end insight generation\n6. Test user feedback tracking\n7. Test insight expiration handling",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Build Insights Feed Mobile UI",
        "description": "Create mobile screens to display ML-generated insights, recommendations, and allow user feedback.",
        "details": "1. Create new screens:\n   - `app/insights/index.tsx` - Insights feed/dashboard\n   - `app/insights/[id].tsx` - Detailed insight view\n\n2. Insights Feed (`app/insights/index.tsx`):\n   - List of insight cards sorted by priority and recency\n   - Card components per insight type:\n     - Correlation: Show correlation strength badge\n     - Prediction: Show predicted value and arrow\n     - Anomaly: Show warning indicator\n     - Recommendation: Show actionable tip\n   - Swipe to dismiss functionality\n   - Pull-to-refresh to generate new insights\n   - Empty state: 'Keep logging meals to unlock insights'\n\n3. Insight Card Design:\n```typescript\ninterface InsightCard {\n  icon: string;           // Based on insightType\n  title: string;          // From insight.title\n  description: string;    // Truncated insight.description\n  priority: 'high' | 'medium' | 'low'; // Color coding\n  correlation?: number;   // Show badge if correlation insight\n  timestamp: Date;        // When generated\n}\n```\n\n4. Detailed Insight View (`app/insights/[id].tsx`):\n   - Full description text\n   - Recommendation with call-to-action\n   - Supporting chart/data if applicable\n   - 'Was this helpful?' feedback buttons\n   - Share insight button (future)\n\n5. Create API client in `lib/api/insights.ts`:\n```typescript\nexport const insightsApi = {\n  getAll: () => apiClient.get('/api/insights'),\n  getById: (id: string) => apiClient.get(`/api/insights/${id}`),\n  markViewed: (id: string) => apiClient.put(`/api/insights/${id}/viewed`),\n  dismiss: (id: string) => apiClient.put(`/api/insights/${id}/dismissed`),\n  submitFeedback: (id: string, helpful: boolean) =>\n    apiClient.put(`/api/insights/${id}/feedback`, { helpful }),\n}\n```\n\n6. Add insights badge to tab bar showing unread count",
        "testStrategy": "1. Component tests for insight cards\n2. Test swipe-to-dismiss interaction\n3. Test feedback submission flow\n4. Test empty and loading states\n5. Test priority-based sorting\n6. Visual regression tests for card styles",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement AR Portion Size Measurement",
        "description": "Add AR capability to measure food portion dimensions and improve nutrition estimation accuracy.",
        "details": "1. Install AR dependencies:\n   - expo-three (already installed - three.js is in dependencies)\n   - expo-gl (already installed)\n   - @react-three/fiber for React Native\n\n2. Create AR measurement component in `lib/components/ARPortionMeasure.tsx`:\n   - Initialize AR session with plane detection\n   - Render measurement guides on detected surfaces\n   - Allow user to place measurement points\n   - Calculate bounding box dimensions (width, height, depth)\n   - Return dimensions in centimeters\n\n3. Update food scanning flow (`app/scan-food.tsx`):\n   - Add 'Measure with AR' button after capturing photo\n   - Launch AR measurement overlay\n   - Pass dimensions to food analysis API\n   - Update `mockMeasurements` with real AR data\n\n4. AR measurement flow:\n   1. User captures food photo\n   2. User taps 'Measure Portion'\n   3. AR view opens with plane detection\n   4. User taps to place corner points (4 points for bounding box)\n   5. App calculates volume and converts to portion weight\n   6. Dimensions sent to /api/food/analyze\n\n5. Dimension to weight conversion (in food_analysis_service.py):\n   - Already implemented in `_estimate_portion_from_dimensions()`\n   - Uses food density estimates\n   - Returns estimated weight in grams\n\n6. Calibration feature:\n   - Include reference object option (credit card, hand)\n   - Use known dimensions to calibrate scale\n   - Improve accuracy for subsequent measurements\n\n7. Fallback handling:\n   - If AR not supported (older devices), show manual size picker\n   - Options: Small, Medium, Large with example photos",
        "testStrategy": "1. Unit tests for dimension calculation\n2. Test AR component mounting/unmounting\n3. Test plane detection callbacks\n4. Integration test with mock AR data\n5. Test fallback to manual size picker\n6. Manual testing on physical device with AR support\n7. Test calibration accuracy with known objects",
        "priority": "low",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Generate OpenAPI Documentation and Polish Production Readiness",
        "description": "Add comprehensive API documentation, perform security audit, and optimize performance for production deployment.",
        "details": "1. Generate OpenAPI/Swagger documentation:\n   - Backend (Express): Add swagger-jsdoc and swagger-ui-express\n   - ML Service (FastAPI): Already has built-in docs at /docs\n   - Document all endpoints with request/response schemas\n   - Add authentication requirements\n   - Include example requests and responses\n\n2. Express API documentation setup:\n```javascript\nimport swaggerJsdoc from 'swagger-jsdoc';\nimport swaggerUi from 'swagger-ui-express';\n\nconst options = {\n  definition: {\n    openapi: '3.0.0',\n    info: { title: 'Nutri API', version: '1.0.0' },\n    servers: [{ url: '/api' }],\n    components: {\n      securitySchemes: {\n        bearerAuth: { type: 'http', scheme: 'bearer' }\n      }\n    }\n  },\n  apis: ['./src/routes/*.ts'],\n};\n\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerJsdoc(options)));\n```\n\n3. Performance optimization:\n   - Add database query logging to identify slow queries\n   - Implement connection pooling for PostgreSQL\n   - Add Redis caching for frequently accessed data (user profile, daily summary)\n   - Compress API responses with compression middleware\n   - Optimize Prisma queries with select/include\n\n4. Security audit checklist:\n   - Review all authentication flows\n   - Verify rate limiting is effective\n   - Check for SQL injection (Prisma handles this)\n   - Verify XSS prevention in sanitize middleware\n   - Review CORS configuration\n   - Ensure sensitive data not logged\n   - Check JWT secret rotation capability\n\n5. Production configuration:\n   - Environment variable validation on startup\n   - Health check endpoints for load balancers\n   - Graceful shutdown handling\n   - Error tracking integration (Sentry ready)\n   - Logging configuration (structured JSON logs)\n\n6. Mobile app optimization:\n   - Review bundle size\n   - Implement proper loading states\n   - Add offline detection and handling\n   - Optimize image handling\n\n7. Create deployment documentation:\n   - Docker setup for backend and ML service\n   - Environment variables reference\n   - Database migration guide\n   - Monitoring recommendations",
        "testStrategy": "1. Validate OpenAPI spec with swagger-cli validate\n2. Load testing with k6 or artillery (100 concurrent users)\n3. Security scan with npm audit and OWASP ZAP\n4. Test rate limiting triggers correctly\n5. Test graceful shutdown\n6. Verify logging output format\n7. Test health check endpoints\n8. Performance benchmark for critical endpoints",
        "priority": "low",
        "dependencies": [
          "2",
          "3",
          "4",
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Comprehensive Supplement Tracking System",
        "description": "Add full supplement tracking functionality allowing users to log supplements on-the-spot or configure recurring schedules (daily, weekly, interval-based). Includes database schema, backend API, and mobile UI implementation.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement Prisma database schema for supplement tracking",
            "description": "Create comprehensive database models for Supplement, UserSupplement, SupplementLog, and SupplementSchedule with proper enums, relations, and indexes following existing schema patterns.",
            "dependencies": [],
            "details": "Add to server/prisma/schema.prisma:\n\n1. Create SupplementCategory enum:\n   - AMINO_ACID, VITAMIN, MINERAL, PERFORMANCE, HERBAL, PROTEIN, FATTY_ACID, PROBIOTIC, OTHER\n\n2. Create ScheduleType enum:\n   - ONE_TIME, DAILY, DAILY_MULTIPLE, WEEKLY, INTERVAL\n\n3. Create Supplement model (master list of supplements):\n   - id (String, @id, @default(cuid()))\n   - name (String, unique)\n   - category (SupplementCategory)\n   - description (String?, optional)\n   - defaultDosage (String?, e.g., \"5g\", \"1000mg\")\n   - defaultUnit (String?, e.g., \"g\", \"mg\", \"IU\")\n   - metadata (Json?, for additional info like benefits, side effects)\n   - createdAt, updatedAt (DateTime)\n   - Add relation to UserSupplement[]\n   - Add indexes on name and category\n\n4. Create UserSupplement model (user's configured supplements with schedules):\n   - id (String, @id, @default(cuid()))\n   - userId (String, relation to User)\n   - supplementId (String, relation to Supplement)\n   - dosage (String, e.g., \"5g\")\n   - unit (String, e.g., \"g\", \"mg\")\n   - scheduleType (ScheduleType)\n   - scheduleTimes (Json, array of time strings like [\"08:00\", \"20:00\"] for DAILY_MULTIPLE)\n   - weeklySchedule (Json?, for WEEKLY: {monday: [\"08:00\"], tuesday: [\"08:00\"]})\n   - intervalDays (Int?, for INTERVAL schedule)\n   - startDate (DateTime)\n   - endDate (DateTime?, optional for ongoing supplements)\n   - isActive (Boolean, @default(true))\n   - notes (String?, optional)\n   - createdAt, updatedAt (DateTime)\n   - Add relation to User and Supplement\n   - Add relation to SupplementLog[]\n   - Add composite index on [userId, isActive, startDate]\n   - Add index on [userId, supplementId]\n\n5. Create SupplementLog model (actual consumption logs):\n   - id (String, @id, @default(cuid()))\n   - userId (String, relation to User)\n   - userSupplementId (String?, relation to UserSupplement, nullable for one-time logs)\n   - supplementId (String, relation to Supplement)\n   - dosage (String)\n   - unit (String)\n   - takenAt (DateTime)\n   - source (String, e.g., \"scheduled\", \"manual\", \"quick_log\")\n   - notes (String?, optional)\n   - createdAt, updatedAt (DateTime)\n   - Add relations to User, UserSupplement, Supplement\n   - Add composite index on [userId, takenAt]\n   - Add index on [userId, supplementId, takenAt]\n\n6. Update User model to add relations:\n   - userSupplements UserSupplement[]\n   - supplementLogs SupplementLog[]\n\nFollow existing patterns:\n- Use cuid() for IDs\n- Include proper audit fields (createdAt, updatedAt)\n- Use onDelete: Cascade for user relations\n- Add performance indexes matching existing models\n- Use Json type for flexible schedule configurations",
            "status": "pending",
            "testStrategy": "1. Run `npm run db:generate` to ensure Prisma client generates successfully\n2. Validate schema with `npx prisma validate`\n3. Test migration creation with `npm run db:migrate` (dev environment)\n4. Verify all enums are properly defined\n5. Check that all relations are bidirectional\n6. Verify indexes are created for query optimization"
          },
          {
            "id": 2,
            "title": "Create database migration and seed common supplements",
            "description": "Generate Prisma migration for supplement schema and create seed data with popular supplements across all categories.",
            "dependencies": [
              1
            ],
            "details": "1. Generate migration:\n   - cd server\n   - Run: npm run db:push (for dev) or npm run db:migrate (for production)\n   - Migration name: \"add_supplement_tracking_system\"\n\n2. Create seed data in server/prisma/seed.ts (or create if doesn't exist):\n   - Seed at least 30 common supplements across all categories:\n\nAMINO_ACID category:\n- BCAA (Branched-Chain Amino Acids) - default: \"5g\"\n- L-Lysine - default: \"1000mg\"\n- L-Glutamine - default: \"5g\"\n- Beta-Alanine - default: \"3g\"\n- L-Citrulline - default: \"6g\"\n\nVITAMIN category:\n- Vitamin D3 - default: \"2000IU\"\n- Vitamin C - default: \"1000mg\"\n- Vitamin B12 - default: \"1000mcg\"\n- Vitamin B Complex - default: \"1 capsule\"\n- Vitamin E - default: \"400IU\"\n\nMINERAL category:\n- Magnesium Glycinate - default: \"400mg\"\n- Zinc - default: \"30mg\"\n- Calcium - default: \"1000mg\"\n- Iron - default: \"18mg\"\n- Potassium - default: \"99mg\"\n\nPERFORMANCE category:\n- Creatine Monohydrate - default: \"5g\"\n- Pre-Workout - default: \"1 scoop\"\n- Caffeine - default: \"200mg\"\n- Electrolytes - default: \"1 scoop\"\n\nFATTY_ACID category:\n- Omega-3 Fish Oil - default: \"1000mg\"\n- Krill Oil - default: \"500mg\"\n- Flaxseed Oil - default: \"1000mg\"\n\nPROTEIN category:\n- Whey Protein - default: \"30g\"\n- Casein Protein - default: \"30g\"\n- Plant Protein - default: \"30g\"\n\nHERBAL category:\n- Ashwagandha - default: \"600mg\"\n- Turmeric/Curcumin - default: \"500mg\"\n- Rhodiola - default: \"500mg\"\n\nPROBIOTIC category:\n- Multi-Strain Probiotic - default: \"10 billion CFU\"\n- Lactobacillus - default: \"1 capsule\"\n\nOTHER category:\n- Multivitamin - default: \"1 tablet\"\n- CoQ10 - default: \"100mg\"\n- Melatonin - default: \"5mg\"\n\n3. Add seed script to package.json if not present:\n   \"prisma\": { \"seed\": \"ts-node prisma/seed.ts\" }\n\n4. Run seed: npx prisma db seed\n\nFollow existing patterns:\n- Use Prisma client for seeding\n- Handle idempotent seeding (upsert, not create)\n- Log seeding progress",
            "status": "pending",
            "testStrategy": "1. Verify migration applies cleanly: npm run db:migrate\n2. Run seed script: npx prisma db seed\n3. Open Prisma Studio: npm run db:studio\n4. Verify all supplements are created in database\n5. Check that all categories have supplements\n6. Verify default dosages and units are populated\n7. Test re-running seed is idempotent (no duplicates)"
          },
          {
            "id": 3,
            "title": "Create Zod validation schemas for supplement endpoints",
            "description": "Add comprehensive Zod schemas for all supplement-related API inputs in server/src/validation/schemas.ts following existing validation patterns.",
            "dependencies": [
              1
            ],
            "details": "Add to server/src/validation/schemas.ts:\n\n1. Create enum schemas matching Prisma enums:\n\nexport const supplementCategorySchema = z.enum([\n  'AMINO_ACID',\n  'VITAMIN',\n  'MINERAL',\n  'PERFORMANCE',\n  'HERBAL',\n  'PROTEIN',\n  'FATTY_ACID',\n  'PROBIOTIC',\n  'OTHER',\n]);\n\nexport const scheduleTypeSchema = z.enum([\n  'ONE_TIME',\n  'DAILY',\n  'DAILY_MULTIPLE',\n  'WEEKLY',\n  'INTERVAL',\n]);\n\nexport const supplementSourceSchema = z.enum([\n  'scheduled',\n  'manual',\n  'quick_log',\n]);\n\n2. Create supplement-related schemas:\n\n// Get supplements with filters\nexport const getSupplementsQuerySchema = z.object({\n  category: supplementCategorySchema.optional(),\n  search: z.string().optional(),\n});\n\n// Create user supplement (configure schedule)\nexport const createUserSupplementSchema = z.object({\n  supplementId: nonEmptyStringSchema,\n  dosage: nonEmptyStringSchema,\n  unit: nonEmptyStringSchema,\n  scheduleType: scheduleTypeSchema,\n  scheduleTimes: z.array(z.string()).optional(), // For DAILY_MULTIPLE: [\"08:00\", \"20:00\"]\n  weeklySchedule: z.record(z.array(z.string())).optional(), // For WEEKLY\n  intervalDays: positiveIntSchema.optional(), // For INTERVAL\n  startDate: datetimeSchema,\n  endDate: datetimeSchema.optional(),\n  notes: z.string().optional(),\n}).refine(\n  (data) => {\n    // Validate schedule-specific fields\n    if (data.scheduleType === 'DAILY_MULTIPLE' && !data.scheduleTimes?.length) {\n      return false;\n    }\n    if (data.scheduleType === 'WEEKLY' && !data.weeklySchedule) {\n      return false;\n    }\n    if (data.scheduleType === 'INTERVAL' && !data.intervalDays) {\n      return false;\n    }\n    return true;\n  },\n  {\n    message: 'Schedule-specific fields are required based on scheduleType',\n  }\n);\n\n// Update user supplement\nexport const updateUserSupplementSchema = createUserSupplementSchema.partial().extend({\n  isActive: z.boolean().optional(),\n});\n\n// Create supplement log (manual or quick log)\nexport const createSupplementLogSchema = z.object({\n  userSupplementId: z.string().optional(), // Null for one-time logs\n  supplementId: nonEmptyStringSchema,\n  dosage: nonEmptyStringSchema,\n  unit: nonEmptyStringSchema,\n  takenAt: datetimeSchema,\n  source: supplementSourceSchema,\n  notes: z.string().optional(),\n});\n\n// Get supplement logs with filters\nexport const getSupplementLogsQuerySchema = z.object({\n  startDate: datetimeSchema.optional(),\n  endDate: datetimeSchema.optional(),\n  supplementId: z.string().optional(),\n  userSupplementId: z.string().optional(),\n});\n\n// Bulk log supplements (for scheduled doses)\nexport const bulkCreateSupplementLogsSchema = z.object({\n  logs: z.array(createSupplementLogSchema).min(1, 'At least one log is required'),\n});\n\n3. Export all new schemas\n\nFollow existing patterns:\n- Use existing base schemas (nonEmptyStringSchema, positiveIntSchema, datetimeSchema)\n- Add custom refinements for complex validation\n- Use descriptive error messages\n- Support optional fields with .optional()\n- Group related schemas together with comments",
            "status": "pending",
            "testStrategy": "1. Import schemas in test file\n2. Test valid inputs pass validation\n3. Test invalid inputs throw ZodError:\n   - Missing required fields\n   - Invalid enum values\n   - Invalid schedule configurations (e.g., DAILY_MULTIPLE without scheduleTimes)\n   - Invalid date formats\n4. Test refinement logic for schedule-specific fields\n5. Verify error messages are descriptive\n6. Test partial updates with updateUserSupplementSchema"
          },
          {
            "id": 4,
            "title": "Implement SupplementService with business logic",
            "description": "Create server/src/services/supplementService.ts with all business logic for supplement management, schedules, and logging following existing service patterns.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create server/src/services/supplementService.ts:\n\nexport class SupplementService {\n  // Supplement master list methods\n  async getSupplements(filters?: { category?: string; search?: string }) {\n    // Query Supplement model\n    // Filter by category if provided\n    // Search by name if search term provided (use contains, case insensitive)\n    // Order by category, then name\n    // Return array of supplements\n  }\n\n  async getSupplementById(supplementId: string) {\n    // Find supplement by ID\n    // Throw error if not found\n    // Return supplement\n  }\n\n  // User supplement (schedule) methods\n  async createUserSupplement(userId: string, data: CreateUserSupplementInput) {\n    // Verify supplementId exists\n    // Create UserSupplement with schedule configuration\n    // Include supplement relation in return\n    // Return created user supplement with nested supplement data\n  }\n\n  async getUserSupplements(userId: string, includeInactive = false) {\n    // Query UserSupplement for user\n    // Filter by isActive if includeInactive is false\n    // Include supplement relation\n    // Order by createdAt desc\n    // Return array of user supplements with nested supplement\n  }\n\n  async getUserSupplementById(userId: string, userSupplementId: string) {\n    // Find UserSupplement by ID and userId\n    // Include supplement relation\n    // Throw error if not found or doesn't belong to user\n    // Return user supplement with nested supplement\n  }\n\n  async updateUserSupplement(userId: string, userSupplementId: string, data: UpdateUserSupplementInput) {\n    // Verify ownership with getUserSupplementById\n    // Update UserSupplement\n    // Include supplement relation in return\n    // Return updated user supplement with nested supplement\n  }\n\n  async deleteUserSupplement(userId: string, userSupplementId: string) {\n    // Verify ownership with getUserSupplementById\n    // Soft delete: set isActive = false (don't hard delete to preserve history)\n    // Return success message\n  }\n\n  async getScheduledSupplements(userId: string, date: Date) {\n    // Get active UserSupplements for user\n    // Filter by startDate <= date and (endDate >= date OR endDate is null)\n    // Calculate which supplements should be taken on this date based on:\n    //   - DAILY: every day\n    //   - DAILY_MULTIPLE: multiple times per day (return with scheduleTimes)\n    //   - WEEKLY: check if date's day of week is in weeklySchedule\n    //   - INTERVAL: check if (date - startDate) % intervalDays === 0\n    // Return array with supplement details and scheduled times\n  }\n\n  // Supplement log methods\n  async createSupplementLog(userId: string, data: CreateSupplementLogInput) {\n    // Verify supplementId exists\n    // If userSupplementId provided, verify it belongs to user\n    // Create SupplementLog\n    // Include supplement relation in return\n    // Return log with nested supplement data\n  }\n\n  async bulkCreateSupplementLogs(userId: string, logs: CreateSupplementLogInput[]) {\n    // Validate all supplementIds and userSupplementIds\n    // Create all logs in transaction\n    // Return array of created logs\n  }\n\n  async getSupplementLogs(userId: string, filters?: GetSupplementLogsFilters) {\n    // Query SupplementLog for user\n    // Filter by date range if provided (startDate, endDate)\n    // Filter by supplementId if provided\n    // Filter by userSupplementId if provided\n    // Include supplement relation\n    // Order by takenAt desc\n    // Return array of logs with nested supplement\n  }\n\n  async getSupplementLogById(userId: string, logId: string) {\n    // Find SupplementLog by ID and userId\n    // Include supplement relation\n    // Throw error if not found or doesn't belong to user\n    // Return log with nested supplement\n  }\n\n  async updateSupplementLog(userId: string, logId: string, data: UpdateSupplementLogInput) {\n    // Verify ownership\n    // Update log (dosage, unit, takenAt, notes)\n    // Return updated log\n  }\n\n  async deleteSupplementLog(userId: string, logId: string) {\n    // Verify ownership with getSupplementLogById\n    // Hard delete (logs can be safely deleted)\n    // Return success message\n  }\n\n  async getDailySummary(userId: string, date?: Date) {\n    // Get all logs for specified day\n    // Get scheduled supplements for the day\n    // Calculate adherence: logged vs scheduled\n    // Return summary with logs and adherence percentage\n  }\n\n  async getWeeklySummary(userId: string) {\n    // Get logs for past 7 days\n    // Group by day\n    // Calculate daily adherence\n    // Return array of daily summaries\n  }\n}\n\nexport const supplementService = new SupplementService();\n\nFollow existing patterns from mealService.ts, activityService.ts:\n- Export singleton instance\n- Use Prisma for all database operations\n- Throw errors for not found/unauthorized\n- Use proper TypeScript types\n- Include relations in queries where needed\n- Use helper functions like getDayBoundaries, getDaysAgo from utils/dateHelpers\n- No any types",
            "status": "pending",
            "testStrategy": "1. Unit tests for each service method\n2. Test CRUD operations for supplements\n3. Test user supplement schedule creation with different scheduleTypes\n4. Test getScheduledSupplements logic for each schedule type:\n   - DAILY: returns every day\n   - DAILY_MULTIPLE: returns with correct times\n   - WEEKLY: returns only on specified days\n   - INTERVAL: returns on correct interval days\n5. Test supplement logging and filtering\n6. Test adherence calculation in daily/weekly summaries\n7. Test authorization (users can only access their own data)\n8. Test error cases (not found, invalid IDs)\n9. Mock Prisma client for isolated testing"
          },
          {
            "id": 5,
            "title": "Create SupplementController with request handlers",
            "description": "Implement server/src/controllers/supplementController.ts with all API request handlers following existing controller patterns.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create server/src/controllers/supplementController.ts:\n\nimport { supplementService } from '../services/supplementService';\nimport { AuthenticatedRequest } from '../types';\nimport { requireAuth } from '../utils/authHelpers';\nimport {\n  getSupplementsQuerySchema,\n  createUserSupplementSchema,\n  updateUserSupplementSchema,\n  createSupplementLogSchema,\n  getSupplementLogsQuerySchema,\n  bulkCreateSupplementLogsSchema,\n} from '../validation/schemas';\nimport { withErrorHandling, ErrorHandlers } from '../utils/controllerHelpers';\nimport { HTTP_STATUS } from '../config/constants';\nimport { parseOptionalDate } from '../utils/dateHelpers';\n\nexport class SupplementController {\n  // Master supplement list endpoints\n  getSupplements = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const validatedQuery = getSupplementsQuerySchema.parse(req.query);\n    const supplements = await supplementService.getSupplements(validatedQuery);\n\n    res.status(HTTP_STATUS.OK).json(supplements);\n  });\n\n  getSupplementById = ErrorHandlers.withNotFound<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const supplement = await supplementService.getSupplementById(req.params.id);\n\n    res.status(HTTP_STATUS.OK).json(supplement);\n  });\n\n  // User supplement (schedule) endpoints\n  createUserSupplement = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const validatedData = createUserSupplementSchema.parse(req.body);\n    const userSupplement = await supplementService.createUserSupplement(userId, validatedData);\n\n    res.status(HTTP_STATUS.CREATED).json(userSupplement);\n  });\n\n  getUserSupplements = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const includeInactive = req.query.includeInactive === 'true';\n    const userSupplements = await supplementService.getUserSupplements(userId, includeInactive);\n\n    res.status(HTTP_STATUS.OK).json(userSupplements);\n  });\n\n  getUserSupplementById = ErrorHandlers.withNotFound<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const userSupplement = await supplementService.getUserSupplementById(userId, req.params.id);\n\n    res.status(HTTP_STATUS.OK).json(userSupplement);\n  });\n\n  updateUserSupplement = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const validatedData = updateUserSupplementSchema.parse(req.body);\n    const userSupplement = await supplementService.updateUserSupplement(userId, req.params.id, validatedData);\n\n    res.status(HTTP_STATUS.OK).json(userSupplement);\n  });\n\n  deleteUserSupplement = ErrorHandlers.withNotFound<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const result = await supplementService.deleteUserSupplement(userId, req.params.id);\n\n    res.status(HTTP_STATUS.OK).json(result);\n  });\n\n  getScheduledSupplements = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const date = parseOptionalDate(req.query.date as string | undefined);\n    const scheduled = await supplementService.getScheduledSupplements(userId, date || new Date());\n\n    res.status(HTTP_STATUS.OK).json(scheduled);\n  });\n\n  // Supplement log endpoints\n  createSupplementLog = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const validatedData = createSupplementLogSchema.parse(req.body);\n    const log = await supplementService.createSupplementLog(userId, validatedData);\n\n    res.status(HTTP_STATUS.CREATED).json(log);\n  });\n\n  bulkCreateSupplementLogs = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const validatedData = bulkCreateSupplementLogsSchema.parse(req.body);\n    const logs = await supplementService.bulkCreateSupplementLogs(userId, validatedData.logs);\n\n    res.status(HTTP_STATUS.CREATED).json(logs);\n  });\n\n  getSupplementLogs = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const validatedQuery = getSupplementLogsQuerySchema.parse(req.query);\n    const logs = await supplementService.getSupplementLogs(userId, validatedQuery);\n\n    res.status(HTTP_STATUS.OK).json(logs);\n  });\n\n  getSupplementLogById = ErrorHandlers.withNotFound<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const log = await supplementService.getSupplementLogById(userId, req.params.id);\n\n    res.status(HTTP_STATUS.OK).json(log);\n  });\n\n  updateSupplementLog = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    // Use partial schema for updates\n    const validatedData = createSupplementLogSchema.partial().parse(req.body);\n    const log = await supplementService.updateSupplementLog(userId, req.params.id, validatedData);\n\n    res.status(HTTP_STATUS.OK).json(log);\n  });\n\n  deleteSupplementLog = ErrorHandlers.withNotFound<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const result = await supplementService.deleteSupplementLog(userId, req.params.id);\n\n    res.status(HTTP_STATUS.OK).json(result);\n  });\n\n  getDailySummary = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const date = parseOptionalDate(req.query.date as string | undefined);\n    const summary = await supplementService.getDailySummary(userId, date);\n\n    res.status(HTTP_STATUS.OK).json(summary);\n  });\n\n  getWeeklySummary = withErrorHandling<AuthenticatedRequest>(async (req, res) => {\n    const userId = requireAuth(req, res);\n    if (!userId) return;\n\n    const summary = await supplementService.getWeeklySummary(userId);\n\n    res.status(HTTP_STATUS.OK).json(summary);\n  });\n}\n\nexport const supplementController = new SupplementController();\n\nFollow existing patterns from mealController.ts:\n- Use withErrorHandling wrapper\n- Use ErrorHandlers.withNotFound for detail endpoints\n- Validate with Zod schemas\n- Use requireAuth helper\n- Return appropriate HTTP status codes\n- Export singleton instance",
            "status": "pending",
            "testStrategy": "1. Integration tests for each endpoint\n2. Test authentication requirement (401 without token)\n3. Test Zod validation (400 for invalid inputs)\n4. Test successful operations (200/201 status codes)\n5. Test not found cases (404)\n6. Test authorization (users can only access their own data)\n7. Test query parameters (filters, dates)\n8. Test bulk operations\n9. Use supertest for HTTP testing\n10. Follow test patterns from activity.test.ts"
          },
          {
            "id": 6,
            "title": "Create supplement API routes",
            "description": "Implement server/src/routes/supplementRoutes.ts with all REST endpoints following existing routing patterns.",
            "dependencies": [
              5
            ],
            "details": "Create server/src/routes/supplementRoutes.ts:\n\nimport { Router } from 'express';\nimport { supplementController } from '../controllers/supplementController';\nimport { authenticate } from '../middleware/auth';\n\nconst router = Router();\n\n// All supplement routes are protected\nrouter.use(authenticate);\n\n// Master supplement list routes\nrouter.get('/supplements', (req, res) => supplementController.getSupplements(req, res));\nrouter.get('/supplements/:id', (req, res) => supplementController.getSupplementById(req, res));\n\n// User supplement (schedule) routes\nrouter.post('/user-supplements', (req, res) => supplementController.createUserSupplement(req, res));\nrouter.get('/user-supplements', (req, res) => supplementController.getUserSupplements(req, res));\nrouter.get('/user-supplements/scheduled', (req, res) => supplementController.getScheduledSupplements(req, res));\nrouter.get('/user-supplements/:id', (req, res) => supplementController.getUserSupplementById(req, res));\nrouter.put('/user-supplements/:id', (req, res) => supplementController.updateUserSupplement(req, res));\nrouter.delete('/user-supplements/:id', (req, res) => supplementController.deleteUserSupplement(req, res));\n\n// Supplement log routes\nrouter.post('/supplement-logs', (req, res) => supplementController.createSupplementLog(req, res));\nrouter.post('/supplement-logs/bulk', (req, res) => supplementController.bulkCreateSupplementLogs(req, res));\nrouter.get('/supplement-logs', (req, res) => supplementController.getSupplementLogs(req, res));\nrouter.get('/supplement-logs/summary/daily', (req, res) => supplementController.getDailySummary(req, res));\nrouter.get('/supplement-logs/summary/weekly', (req, res) => supplementController.getWeeklySummary(req, res));\nrouter.get('/supplement-logs/:id', (req, res) => supplementController.getSupplementLogById(req, res));\nrouter.put('/supplement-logs/:id', (req, res) => supplementController.updateSupplementLog(req, res));\nrouter.delete('/supplement-logs/:id', (req, res) => supplementController.deleteSupplementLog(req, res));\n\nexport default router;\n\nThen update server/src/index.ts to register the routes:\n\nimport supplementRoutes from './routes/supplementRoutes';\n\n// Register routes\napp.use('/api/supplements', supplementRoutes); // Master list\napp.use('/api', supplementRoutes); // For user-supplements and supplement-logs paths\n\nOR create three separate route files:\n- supplementRoutes.ts for /api/supplements (master list)\n- userSupplementRoutes.ts for /api/user-supplements (schedules)\n- supplementLogRoutes.ts for /api/supplement-logs (logs)\n\nRecommendation: Use single file with clear comments separating concerns.\n\nFollow existing patterns from mealRoutes.ts:\n- Use authenticate middleware\n- Arrow functions for route handlers\n- Export default router\n- RESTful URL structure\n- Specific routes before parameterized routes\n- Summary/aggregate routes before ID routes",
            "status": "pending",
            "testStrategy": "1. Test all routes are registered correctly\n2. Verify authentication middleware is applied\n3. Test route precedence (specific before parameterized)\n4. Test with curl or Postman to verify endpoints are accessible\n5. Check that routes return expected status codes\n6. Verify route parameters are passed to controllers\n7. Integration tests cover all route paths"
          },
          {
            "id": 7,
            "title": "Write comprehensive backend tests",
            "description": "Create server/src/__tests__/supplement.test.ts with unit tests for service and integration tests for API endpoints.",
            "dependencies": [
              4,
              5,
              6
            ],
            "details": "Create server/src/__tests__/supplement.test.ts:\n\nimport request from 'supertest';\nimport app from '../index';\nimport {\n  createTestUser,\n  createTestToken,\n} from './setup';\nimport { SupplementCategory, ScheduleType } from '@prisma/client';\nimport prisma from '../config/database';\n\n// Add test helper functions to setup.ts:\n// createTestSupplement(), createTestUserSupplement(), createTestSupplementLog()\n// assertSupplementStructure(), assertUserSupplementStructure(), assertSupplementLogStructure()\n\ndescribe('Supplement API Endpoints', () => {\n  let authToken: string;\n  let userId: string;\n  let supplementId: string;\n\n  beforeEach(async () => {\n    const user = await createTestUser();\n    userId = user.id;\n    authToken = createTestToken(userId);\n\n    // Create test supplement\n    const supplement = await prisma.supplement.create({\n      data: {\n        name: 'Test Creatine',\n        category: 'PERFORMANCE',\n        defaultDosage: '5g',\n        defaultUnit: 'g',\n      },\n    });\n    supplementId = supplement.id;\n  });\n\n  describe('GET /api/supplements', () => {\n    it('should get all supplements', async () => {\n      const response = await request(app)\n        .get('/api/supplements')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(Array.isArray(response.body)).toBe(true);\n      expect(response.body.length).toBeGreaterThan(0);\n    });\n\n    it('should filter supplements by category', async () => {\n      const response = await request(app)\n        .get('/api/supplements?category=PERFORMANCE')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(Array.isArray(response.body)).toBe(true);\n      response.body.forEach((s: any) => {\n        expect(s.category).toBe('PERFORMANCE');\n      });\n    });\n\n    it('should search supplements by name', async () => {\n      const response = await request(app)\n        .get('/api/supplements?search=creatine')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(Array.isArray(response.body)).toBe(true);\n    });\n  });\n\n  describe('POST /api/user-supplements', () => {\n    it('should create a daily supplement schedule', async () => {\n      const scheduleData = {\n        supplementId,\n        dosage: '5g',\n        unit: 'g',\n        scheduleType: 'DAILY',\n        startDate: new Date().toISOString(),\n      };\n\n      const response = await request(app)\n        .post('/api/user-supplements')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(scheduleData)\n        .expect(201);\n\n      expect(response.body.scheduleType).toBe('DAILY');\n      expect(response.body.supplement).toBeDefined();\n    });\n\n    it('should create a daily multiple schedule with times', async () => {\n      const scheduleData = {\n        supplementId,\n        dosage: '5g',\n        unit: 'g',\n        scheduleType: 'DAILY_MULTIPLE',\n        scheduleTimes: ['08:00', '20:00'],\n        startDate: new Date().toISOString(),\n      };\n\n      const response = await request(app)\n        .post('/api/user-supplements')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(scheduleData)\n        .expect(201);\n\n      expect(response.body.scheduleTimes).toEqual(['08:00', '20:00']);\n    });\n\n    it('should fail without required schedule fields', async () => {\n      const scheduleData = {\n        supplementId,\n        dosage: '5g',\n        unit: 'g',\n        scheduleType: 'DAILY_MULTIPLE',\n        // Missing scheduleTimes\n        startDate: new Date().toISOString(),\n      };\n\n      await request(app)\n        .post('/api/user-supplements')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(scheduleData)\n        .expect(400);\n    });\n  });\n\n  describe('GET /api/user-supplements', () => {\n    it('should get user supplements', async () => {\n      // Create user supplement first\n      await request(app)\n        .post('/api/user-supplements')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          supplementId,\n          dosage: '5g',\n          unit: 'g',\n          scheduleType: 'DAILY',\n          startDate: new Date().toISOString(),\n        });\n\n      const response = await request(app)\n        .get('/api/user-supplements')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(Array.isArray(response.body)).toBe(true);\n      expect(response.body.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('GET /api/user-supplements/scheduled', () => {\n    it('should get scheduled supplements for today', async () => {\n      await request(app)\n        .post('/api/user-supplements')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          supplementId,\n          dosage: '5g',\n          unit: 'g',\n          scheduleType: 'DAILY',\n          startDate: new Date().toISOString(),\n        });\n\n      const response = await request(app)\n        .get('/api/user-supplements/scheduled')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(Array.isArray(response.body)).toBe(true);\n    });\n  });\n\n  describe('POST /api/supplement-logs', () => {\n    it('should log a supplement', async () => {\n      const logData = {\n        supplementId,\n        dosage: '5g',\n        unit: 'g',\n        takenAt: new Date().toISOString(),\n        source: 'manual',\n      };\n\n      const response = await request(app)\n        .post('/api/supplement-logs')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(logData)\n        .expect(201);\n\n      expect(response.body.supplementId).toBe(supplementId);\n      expect(response.body.supplement).toBeDefined();\n    });\n  });\n\n  describe('GET /api/supplement-logs', () => {\n    it('should get supplement logs', async () => {\n      // Create log first\n      await request(app)\n        .post('/api/supplement-logs')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          supplementId,\n          dosage: '5g',\n          unit: 'g',\n          takenAt: new Date().toISOString(),\n          source: 'manual',\n        });\n\n      const response = await request(app)\n        .get('/api/supplement-logs')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(Array.isArray(response.body)).toBe(true);\n      expect(response.body.length).toBeGreaterThan(0);\n    });\n\n    it('should filter logs by date range', async () => {\n      const startDate = new Date();\n      const endDate = new Date(Date.now() + 86400000);\n\n      const response = await request(app)\n        .get(`/api/supplement-logs?startDate=${startDate.toISOString()}&endDate=${endDate.toISOString()}`)\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(Array.isArray(response.body)).toBe(true);\n    });\n  });\n\n  describe('GET /api/supplement-logs/summary/daily', () => {\n    it('should get daily summary', async () => {\n      const response = await request(app)\n        .get('/api/supplement-logs/summary/daily')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(response.body).toHaveProperty('logs');\n      expect(response.body).toHaveProperty('adherence');\n    });\n  });\n\n  describe('Authentication', () => {\n    it('should reject requests without token', async () => {\n      await request(app)\n        .get('/api/supplements')\n        .expect(401);\n    });\n  });\n});\n\nFollow existing patterns from activity.test.ts:\n- Use supertest for integration tests\n- Create test fixtures in beforeEach\n- Test happy paths and error cases\n- Test authentication and authorization\n- Test validation with invalid inputs\n- Use assertion helpers\n- Clean up with afterEach if needed",
            "status": "pending",
            "testStrategy": "1. Run tests: cd server && npm test supplement.test.ts\n2. Verify all tests pass\n3. Check code coverage: npm run test:coverage\n4. Ensure >80% coverage for supplement service and controller\n5. Test schedule logic thoroughly (DAILY, DAILY_MULTIPLE, WEEKLY, INTERVAL)\n6. Test edge cases (expired schedules, inactive supplements)\n7. Test adherence calculation accuracy"
          },
          {
            "id": 8,
            "title": "Create TypeScript types for mobile supplement interfaces",
            "description": "Add supplement-related TypeScript interfaces to lib/types/index.ts following existing type patterns.",
            "dependencies": [
              1
            ],
            "details": "Add to lib/types/index.ts:\n\n// Supplement enums (match Prisma enums)\nexport type SupplementCategory =\n  | 'AMINO_ACID'\n  | 'VITAMIN'\n  | 'MINERAL'\n  | 'PERFORMANCE'\n  | 'HERBAL'\n  | 'PROTEIN'\n  | 'FATTY_ACID'\n  | 'PROBIOTIC'\n  | 'OTHER';\n\nexport type ScheduleType =\n  | 'ONE_TIME'\n  | 'DAILY'\n  | 'DAILY_MULTIPLE'\n  | 'WEEKLY'\n  | 'INTERVAL';\n\nexport type SupplementSource = 'scheduled' | 'manual' | 'quick_log';\n\n// Supplement master list\nexport interface Supplement {\n  id: string;\n  name: string;\n  category: SupplementCategory;\n  description?: string;\n  defaultDosage?: string;\n  defaultUnit?: string;\n  metadata?: Record<string, any>;\n  createdAt: string;\n  updatedAt: string;\n}\n\n// User's configured supplement schedule\nexport interface UserSupplement {\n  id: string;\n  userId: string;\n  supplementId: string;\n  supplement: Supplement; // Nested relation\n  dosage: string;\n  unit: string;\n  scheduleType: ScheduleType;\n  scheduleTimes?: string[]; // For DAILY_MULTIPLE: [\"08:00\", \"20:00\"]\n  weeklySchedule?: Record<string, string[]>; // For WEEKLY: {monday: [\"08:00\"]}\n  intervalDays?: number; // For INTERVAL: every N days\n  startDate: string;\n  endDate?: string;\n  isActive: boolean;\n  notes?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\n// Supplement consumption log\nexport interface SupplementLog {\n  id: string;\n  userId: string;\n  userSupplementId?: string;\n  supplementId: string;\n  supplement: Supplement; // Nested relation\n  dosage: string;\n  unit: string;\n  takenAt: string;\n  source: SupplementSource;\n  notes?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\n// Scheduled supplement (for daily view)\nexport interface ScheduledSupplement {\n  userSupplement: UserSupplement;\n  scheduledTimes: string[]; // Times supplement should be taken today\n  taken: boolean; // Whether it's been logged today\n  logs: SupplementLog[]; // Today's logs for this supplement\n}\n\n// Input types for API calls\nexport interface CreateUserSupplementInput {\n  supplementId: string;\n  dosage: string;\n  unit: string;\n  scheduleType: ScheduleType;\n  scheduleTimes?: string[];\n  weeklySchedule?: Record<string, string[]>;\n  intervalDays?: number;\n  startDate: string;\n  endDate?: string;\n  notes?: string;\n}\n\nexport interface UpdateUserSupplementInput {\n  dosage?: string;\n  unit?: string;\n  scheduleType?: ScheduleType;\n  scheduleTimes?: string[];\n  weeklySchedule?: Record<string, string[]>;\n  intervalDays?: number;\n  startDate?: string;\n  endDate?: string;\n  isActive?: boolean;\n  notes?: string;\n}\n\nexport interface CreateSupplementLogInput {\n  userSupplementId?: string;\n  supplementId: string;\n  dosage: string;\n  unit: string;\n  takenAt: string;\n  source: SupplementSource;\n  notes?: string;\n}\n\nexport interface UpdateSupplementLogInput {\n  dosage?: string;\n  unit?: string;\n  takenAt?: string;\n  notes?: string;\n}\n\n// Summary types\nexport interface SupplementDailySummary {\n  date: string;\n  scheduledCount: number;\n  takenCount: number;\n  adherencePercentage: number;\n  logs: SupplementLog[];\n  scheduled: ScheduledSupplement[];\n}\n\nexport interface SupplementWeeklySummary {\n  days: {\n    date: string;\n    scheduledCount: number;\n    takenCount: number;\n    adherencePercentage: number;\n  }[];\n  totalScheduled: number;\n  totalTaken: number;\n  averageAdherence: number;\n}\n\nFollow existing patterns:\n- Export all types\n- Use string for dates (ISO 8601)\n- Match backend types exactly\n- Include nested relations where appropriate\n- Use optional fields with ?\n- Document complex types with comments",
            "status": "pending",
            "testStrategy": "1. Verify TypeScript compilation: npx tsc --noEmit\n2. Import types in a test file and verify they're accessible\n3. Check that all fields match Prisma schema\n4. Verify types are used in API client (next subtask)\n5. Test that nested relations (supplement) are properly typed\n6. Ensure no 'any' types are used"
          },
          {
            "id": 9,
            "title": "Implement mobile API client for supplements",
            "description": "Create lib/api/supplements.ts with all API client functions following existing API client patterns.",
            "dependencies": [
              8
            ],
            "details": "Create lib/api/supplements.ts:\n\nimport api from './client';\nimport {\n  Supplement,\n  UserSupplement,\n  SupplementLog,\n  ScheduledSupplement,\n  CreateUserSupplementInput,\n  UpdateUserSupplementInput,\n  CreateSupplementLogInput,\n  UpdateSupplementLogInput,\n  SupplementDailySummary,\n  SupplementWeeklySummary,\n  SupplementCategory,\n} from '../types';\n\n// Master supplement list API\nexport const supplementsApi = {\n  /**\n   * Get all supplements with optional filters\n   */\n  async getSupplements(filters?: {\n    category?: SupplementCategory;\n    search?: string;\n  }): Promise<Supplement[]> {\n    const params = new URLSearchParams();\n    if (filters?.category) params.append('category', filters.category);\n    if (filters?.search) params.append('search', filters.search);\n\n    const response = await api.get<Supplement[]>(\n      `/supplements${params.toString() ? `?${params.toString()}` : ''}`\n    );\n    return response.data;\n  },\n\n  /**\n   * Get supplement by ID\n   */\n  async getSupplementById(id: string): Promise<Supplement> {\n    const response = await api.get<Supplement>(`/supplements/${id}`);\n    return response.data;\n  },\n};\n\n// User supplement (schedule) API\nexport const userSupplementsApi = {\n  /**\n   * Create a new supplement schedule\n   */\n  async create(data: CreateUserSupplementInput): Promise<UserSupplement> {\n    const response = await api.post<UserSupplement>('/user-supplements', data);\n    return response.data;\n  },\n\n  /**\n   * Get all user supplements (schedules)\n   */\n  async getAll(includeInactive = false): Promise<UserSupplement[]> {\n    const response = await api.get<UserSupplement[]>(\n      `/user-supplements${includeInactive ? '?includeInactive=true' : ''}`\n    );\n    return response.data;\n  },\n\n  /**\n   * Get scheduled supplements for a specific date\n   */\n  async getScheduled(date?: Date): Promise<ScheduledSupplement[]> {\n    const dateParam = date ? `?date=${date.toISOString()}` : '';\n    const response = await api.get<ScheduledSupplement[]>(\n      `/user-supplements/scheduled${dateParam}`\n    );\n    return response.data;\n  },\n\n  /**\n   * Get user supplement by ID\n   */\n  async getById(id: string): Promise<UserSupplement> {\n    const response = await api.get<UserSupplement>(`/user-supplements/${id}`);\n    return response.data;\n  },\n\n  /**\n   * Update user supplement\n   */\n  async update(id: string, data: UpdateUserSupplementInput): Promise<UserSupplement> {\n    const response = await api.put<UserSupplement>(`/user-supplements/${id}`, data);\n    return response.data;\n  },\n\n  /**\n   * Delete (deactivate) user supplement\n   */\n  async delete(id: string): Promise<{ message: string }> {\n    const response = await api.delete<{ message: string }>(`/user-supplements/${id}`);\n    return response.data;\n  },\n};\n\n// Supplement log API\nexport const supplementLogsApi = {\n  /**\n   * Log a supplement (manual or scheduled)\n   */\n  async create(data: CreateSupplementLogInput): Promise<SupplementLog> {\n    const response = await api.post<SupplementLog>('/supplement-logs', data);\n    return response.data;\n  },\n\n  /**\n   * Log multiple supplements at once\n   */\n  async createBulk(logs: CreateSupplementLogInput[]): Promise<SupplementLog[]> {\n    const response = await api.post<SupplementLog[]>('/supplement-logs/bulk', { logs });\n    return response.data;\n  },\n\n  /**\n   * Get supplement logs with optional filters\n   */\n  async getAll(filters?: {\n    startDate?: string;\n    endDate?: string;\n    supplementId?: string;\n    userSupplementId?: string;\n  }): Promise<SupplementLog[]> {\n    const params = new URLSearchParams();\n    if (filters?.startDate) params.append('startDate', filters.startDate);\n    if (filters?.endDate) params.append('endDate', filters.endDate);\n    if (filters?.supplementId) params.append('supplementId', filters.supplementId);\n    if (filters?.userSupplementId) params.append('userSupplementId', filters.userSupplementId);\n\n    const response = await api.get<SupplementLog[]>(\n      `/supplement-logs${params.toString() ? `?${params.toString()}` : ''}`\n    );\n    return response.data;\n  },\n\n  /**\n   * Get supplement log by ID\n   */\n  async getById(id: string): Promise<SupplementLog> {\n    const response = await api.get<SupplementLog>(`/supplement-logs/${id}`);\n    return response.data;\n  },\n\n  /**\n   * Update supplement log\n   */\n  async update(id: string, data: UpdateSupplementLogInput): Promise<SupplementLog> {\n    const response = await api.put<SupplementLog>(`/supplement-logs/${id}`, data);\n    return response.data;\n  },\n\n  /**\n   * Delete supplement log\n   */\n  async delete(id: string): Promise<{ message: string }> {\n    const response = await api.delete<{ message: string }>(`/supplement-logs/${id}`);\n    return response.data;\n  },\n\n  /**\n   * Get daily summary\n   */\n  async getDailySummary(date?: Date): Promise<SupplementDailySummary> {\n    const dateParam = date ? `?date=${date.toISOString()}` : '';\n    const response = await api.get<SupplementDailySummary>(\n      `/supplement-logs/summary/daily${dateParam}`\n    );\n    return response.data;\n  },\n\n  /**\n   * Get weekly summary\n   */\n  async getWeeklySummary(): Promise<SupplementWeeklySummary> {\n    const response = await api.get<SupplementWeeklySummary>(\n      '/supplement-logs/summary/weekly'\n    );\n    return response.data;\n  },\n};\n\nFollow existing patterns from lib/api/meals.ts:\n- Export separate API objects for each resource\n- Use async/await\n- Type all responses\n- Use URLSearchParams for query strings\n- Include JSDoc comments\n- Handle errors (axios interceptor in client.ts handles auth)\n- Use the shared api client from './client'",
            "status": "pending",
            "testStrategy": "1. Import API functions in a test component\n2. Mock axios to test API calls\n3. Verify correct endpoints are called\n4. Verify correct HTTP methods are used\n5. Test query parameters are properly formatted\n6. Test request bodies are properly structured\n7. Verify TypeScript types are enforced\n8. Test error handling (network errors, 401, 404, etc.)"
          },
          {
            "id": 10,
            "title": "Create My Supplements screen with schedule list",
            "description": "Implement app/supplements/index.tsx to display user's configured supplement schedules with adherence tracking.",
            "dependencies": [
              9
            ],
            "details": "Create app/supplements/index.tsx:\n\nimport { useState, useEffect, useCallback } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  FlatList,\n  TouchableOpacity,\n  RefreshControl,\n  ActivityIndicator,\n  Alert,\n} from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { Ionicons } from '@expo/vector-icons';\nimport { userSupplementsApi } from '@/lib/api/supplements';\nimport { UserSupplement } from '@/lib/types';\nimport { colors, spacing, typography } from '@/lib/theme/colors';\nimport { getErrorMessage } from '@/lib/utils/errorHandling';\n\nexport default function MySupplementsScreen() {\n  const [supplements, setSupplements] = useState<UserSupplement[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [refreshing, setRefreshing] = useState(false);\n  const router = useRouter();\n\n  const loadSupplements = useCallback(async () => {\n    try {\n      const data = await userSupplementsApi.getAll();\n      setSupplements(data);\n    } catch (error) {\n      Alert.alert('Error', getErrorMessage(error, 'Failed to load supplements'));\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const onRefresh = useCallback(async () => {\n    setRefreshing(true);\n    await loadSupplements();\n    setRefreshing(false);\n  }, [loadSupplements]);\n\n  useEffect(() => {\n    loadSupplements();\n  }, [loadSupplements]);\n\n  const handleDelete = useCallback(\n    async (id: string, name: string) => {\n      Alert.alert(\n        'Deactivate Supplement',\n        `Are you sure you want to deactivate ${name}?`,\n        [\n          { text: 'Cancel', style: 'cancel' },\n          {\n            text: 'Deactivate',\n            style: 'destructive',\n            onPress: async () => {\n              try {\n                await userSupplementsApi.delete(id);\n                await loadSupplements();\n              } catch (error) {\n                Alert.alert('Error', getErrorMessage(error, 'Failed to deactivate supplement'));\n              }\n            },\n          },\n        ]\n      );\n    },\n    [loadSupplements]\n  );\n\n  const getScheduleDescription = (supplement: UserSupplement): string => {\n    switch (supplement.scheduleType) {\n      case 'DAILY':\n        return 'Daily';\n      case 'DAILY_MULTIPLE':\n        return `${supplement.scheduleTimes?.length || 0}x daily`;\n      case 'WEEKLY':\n        const days = Object.keys(supplement.weeklySchedule || {}).length;\n        return `${days} days/week`;\n      case 'INTERVAL':\n        return `Every ${supplement.intervalDays} days`;\n      case 'ONE_TIME':\n        return 'One-time';\n      default:\n        return supplement.scheduleType;\n    }\n  };\n\n  const getCategoryIcon = (category: string): keyof typeof Ionicons.glyphMap => {\n    const iconMap: Record<string, keyof typeof Ionicons.glyphMap> = {\n      AMINO_ACID: 'fitness',\n      VITAMIN: 'nutrition',\n      MINERAL: 'water',\n      PERFORMANCE: 'flash',\n      HERBAL: 'leaf',\n      PROTEIN: 'barbell',\n      FATTY_ACID: 'fish',\n      PROBIOTIC: 'medical',\n      OTHER: 'ellipse',\n    };\n    return iconMap[category] || 'ellipse';\n  };\n\n  const renderSupplementItem = ({ item }: { item: UserSupplement }) => (\n    <TouchableOpacity\n      style={styles.supplementCard}\n      onPress={() => router.push(`/supplements/${item.id}`)}\n      activeOpacity={0.7}\n    >\n      <View style={styles.supplementHeader}>\n        <View style={styles.iconContainer}>\n          <Ionicons\n            name={getCategoryIcon(item.supplement.category)}\n            size={24}\n            color={colors.primary.main}\n          />\n        </View>\n        <View style={styles.supplementInfo}>\n          <Text style={styles.supplementName}>{item.supplement.name}</Text>\n          <Text style={styles.supplementDosage}>\n            {item.dosage} {item.unit} • {getScheduleDescription(item)}\n          </Text>\n          <Text style={styles.supplementCategory}>{item.supplement.category}</Text>\n        </View>\n        <TouchableOpacity\n          onPress={() => handleDelete(item.id, item.supplement.name)}\n          hitSlop={{ top: 10, right: 10, bottom: 10, left: 10 }}\n        >\n          <Ionicons name=\"trash-outline\" size={20} color={colors.error.main} />\n        </TouchableOpacity>\n      </View>\n\n      {item.notes && (\n        <Text style={styles.supplementNotes} numberOfLines={2}>\n          {item.notes}\n        </Text>\n      )}\n\n      {item.endDate && (\n        <Text style={styles.endDate}>\n          Ends: {new Date(item.endDate).toLocaleDateString()}\n        </Text>\n      )}\n    </TouchableOpacity>\n  );\n\n  if (isLoading) {\n    return (\n      <SafeAreaView style={styles.container}>\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" color={colors.primary.main} />\n        </View>\n      </SafeAreaView>\n    );\n  }\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <View style={styles.header}>\n        <Text style={styles.title}>My Supplements</Text>\n        <TouchableOpacity\n          onPress={() => router.push('/supplements/add')}\n          style={styles.addButton}\n        >\n          <Ionicons name=\"add-circle\" size={28} color={colors.primary.main} />\n        </TouchableOpacity>\n      </View>\n\n      {supplements.length === 0 ? (\n        <View style={styles.emptyContainer}>\n          <Ionicons name=\"medkit-outline\" size={64} color={colors.text.disabled} />\n          <Text style={styles.emptyText}>No supplements yet</Text>\n          <Text style={styles.emptySubtext}>Tap + to add your first supplement</Text>\n        </View>\n      ) : (\n        <FlatList\n          data={supplements}\n          renderItem={renderSupplementItem}\n          keyExtractor={(item) => item.id}\n          contentContainerStyle={styles.listContainer}\n          refreshControl={\n            <RefreshControl\n              refreshing={refreshing}\n              onRefresh={onRefresh}\n              tintColor={colors.primary.main}\n            />\n          }\n        />\n      )}\n    </SafeAreaView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: colors.background.default,\n  },\n  loadingContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    padding: spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: colors.divider,\n  },\n  title: {\n    ...typography.h4,\n    color: colors.text.primary,\n  },\n  addButton: {\n    padding: spacing.xs,\n  },\n  listContainer: {\n    padding: spacing.md,\n  },\n  supplementCard: {\n    backgroundColor: colors.surface.main,\n    borderRadius: 12,\n    padding: spacing.md,\n    marginBottom: spacing.md,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 2,\n  },\n  supplementHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  iconContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    backgroundColor: colors.primary.light,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginRight: spacing.md,\n  },\n  supplementInfo: {\n    flex: 1,\n  },\n  supplementName: {\n    ...typography.body1Bold,\n    color: colors.text.primary,\n    marginBottom: 4,\n  },\n  supplementDosage: {\n    ...typography.body2,\n    color: colors.text.secondary,\n    marginBottom: 2,\n  },\n  supplementCategory: {\n    ...typography.caption,\n    color: colors.text.disabled,\n  },\n  supplementNotes: {\n    ...typography.body2,\n    color: colors.text.secondary,\n    marginTop: spacing.sm,\n    fontStyle: 'italic',\n  },\n  endDate: {\n    ...typography.caption,\n    color: colors.warning.main,\n    marginTop: spacing.sm,\n  },\n  emptyContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: spacing.xl,\n  },\n  emptyText: {\n    ...typography.h6,\n    color: colors.text.secondary,\n    marginTop: spacing.md,\n  },\n  emptySubtext: {\n    ...typography.body2,\n    color: colors.text.disabled,\n    marginTop: spacing.xs,\n  },\n});\n\nFollow existing patterns from app/(tabs)/index.tsx:\n- Use SafeAreaView\n- Implement pull-to-refresh\n- Show loading indicator\n- Handle empty state\n- Use consistent styling from theme\n- Type all state with TypeScript\n- Use getErrorMessage for error handling\n- Implement confirmation dialogs for destructive actions",
            "status": "pending",
            "testStrategy": "1. Test screen renders with supplements\n2. Test empty state displays correctly\n3. Test pull-to-refresh functionality\n4. Test navigation to add screen\n5. Test navigation to detail screen\n6. Test delete confirmation dialog\n7. Test schedule description formatting for each type\n8. Test category icons display correctly\n9. Test error handling when API fails\n10. Visual testing on iOS and Android"
          },
          {
            "id": 11,
            "title": "Create Add/Edit Supplement screen with schedule configuration",
            "description": "Implement app/supplements/add.tsx and app/supplements/[id].tsx for creating and editing supplement schedules with dynamic form based on schedule type.",
            "dependencies": [
              9
            ],
            "details": "Create app/supplements/add.tsx:\n\nimport { useState, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  ScrollView,\n  TextInput,\n  TouchableOpacity,\n  Alert,\n  Platform,\n} from 'react-native';\nimport { useRouter, useLocalSearchParams } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { Picker } from '@react-native-picker/picker';\nimport DateTimePicker from '@react-native-community/datetimepicker';\nimport { Ionicons } from '@expo/vector-icons';\nimport { supplementsApi, userSupplementsApi } from '@/lib/api/supplements';\nimport {\n  Supplement,\n  UserSupplement,\n  ScheduleType,\n  CreateUserSupplementInput,\n} from '@/lib/types';\nimport { colors, spacing, typography } from '@/lib/theme/colors';\nimport { getErrorMessage } from '@/lib/utils/errorHandling';\n\nexport default function AddSupplementScreen() {\n  const router = useRouter();\n  const params = useLocalSearchParams<{ id?: string }>();\n  const isEditing = !!params.id;\n\n  // State\n  const [supplements, setSupplements] = useState<Supplement[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isSaving, setIsSaving] = useState(false);\n\n  // Form state\n  const [selectedSupplementId, setSelectedSupplementId] = useState('');\n  const [dosage, setDosage] = useState('');\n  const [unit, setUnit] = useState('g');\n  const [scheduleType, setScheduleType] = useState<ScheduleType>('DAILY');\n  const [scheduleTimes, setScheduleTimes] = useState<string[]>(['08:00']);\n  const [intervalDays, setIntervalDays] = useState('1');\n  const [startDate, setStartDate] = useState(new Date());\n  const [hasEndDate, setHasEndDate] = useState(false);\n  const [endDate, setEndDate] = useState(new Date());\n  const [notes, setNotes] = useState('');\n  const [showStartDatePicker, setShowStartDatePicker] = useState(false);\n  const [showEndDatePicker, setShowEndDatePicker] = useState(false);\n\n  // Load data\n  useEffect(() => {\n    loadData();\n  }, []);\n\n  const loadData = async () => {\n    try {\n      const [supplementsData, userSupplementData] = await Promise.all([\n        supplementsApi.getSupplements(),\n        isEditing ? userSupplementsApi.getById(params.id!) : null,\n      ]);\n\n      setSupplements(supplementsData);\n\n      if (userSupplementData) {\n        // Pre-fill form for editing\n        setSelectedSupplementId(userSupplementData.supplementId);\n        setDosage(userSupplementData.dosage);\n        setUnit(userSupplementData.unit);\n        setScheduleType(userSupplementData.scheduleType);\n        setScheduleTimes(userSupplementData.scheduleTimes || ['08:00']);\n        setIntervalDays(String(userSupplementData.intervalDays || 1));\n        setStartDate(new Date(userSupplementData.startDate));\n        setHasEndDate(!!userSupplementData.endDate);\n        if (userSupplementData.endDate) {\n          setEndDate(new Date(userSupplementData.endDate));\n        }\n        setNotes(userSupplementData.notes || '');\n      } else if (supplementsData.length > 0) {\n        // Default to first supplement\n        setSelectedSupplementId(supplementsData[0].id);\n        const defaultSupplement = supplementsData[0];\n        if (defaultSupplement.defaultDosage) setDosage(defaultSupplement.defaultDosage);\n        if (defaultSupplement.defaultUnit) setUnit(defaultSupplement.defaultUnit);\n      }\n    } catch (error) {\n      Alert.alert('Error', getErrorMessage(error, 'Failed to load supplements'));\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleSupplementChange = (supplementId: string) => {\n    setSelectedSupplementId(supplementId);\n    const supplement = supplements.find((s) => s.id === supplementId);\n    if (supplement?.defaultDosage) setDosage(supplement.defaultDosage);\n    if (supplement?.defaultUnit) setUnit(supplement.defaultUnit);\n  };\n\n  const handleAddTime = () => {\n    setScheduleTimes([...scheduleTimes, '08:00']);\n  };\n\n  const handleRemoveTime = (index: number) => {\n    setScheduleTimes(scheduleTimes.filter((_, i) => i !== index));\n  };\n\n  const handleTimeChange = (index: number, time: string) => {\n    const newTimes = [...scheduleTimes];\n    newTimes[index] = time;\n    setScheduleTimes(newTimes);\n  };\n\n  const handleSave = async () => {\n    // Validation\n    if (!selectedSupplementId) {\n      Alert.alert('Error', 'Please select a supplement');\n      return;\n    }\n    if (!dosage) {\n      Alert.alert('Error', 'Please enter dosage');\n      return;\n    }\n    if (!unit) {\n      Alert.alert('Error', 'Please enter unit');\n      return;\n    }\n    if (scheduleType === 'DAILY_MULTIPLE' && scheduleTimes.length === 0) {\n      Alert.alert('Error', 'Please add at least one time');\n      return;\n    }\n    if (scheduleType === 'INTERVAL' && (!intervalDays || parseInt(intervalDays) < 1)) {\n      Alert.alert('Error', 'Please enter valid interval days');\n      return;\n    }\n\n    setIsSaving(true);\n    try {\n      const data: CreateUserSupplementInput = {\n        supplementId: selectedSupplementId,\n        dosage,\n        unit,\n        scheduleType,\n        startDate: startDate.toISOString(),\n        notes: notes || undefined,\n      };\n\n      if (scheduleType === 'DAILY_MULTIPLE') {\n        data.scheduleTimes = scheduleTimes;\n      }\n      if (scheduleType === 'INTERVAL') {\n        data.intervalDays = parseInt(intervalDays);\n      }\n      if (hasEndDate) {\n        data.endDate = endDate.toISOString();\n      }\n\n      if (isEditing) {\n        await userSupplementsApi.update(params.id!, data);\n      } else {\n        await userSupplementsApi.create(data);\n      }\n\n      router.back();\n    } catch (error) {\n      Alert.alert('Error', getErrorMessage(error, 'Failed to save supplement'));\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  // Render schedule-specific fields based on scheduleType\n  const renderScheduleFields = () => {\n    switch (scheduleType) {\n      case 'DAILY_MULTIPLE':\n        return (\n          <View style={styles.section}>\n            <Text style={styles.label}>Times</Text>\n            {scheduleTimes.map((time, index) => (\n              <View key={index} style={styles.timeRow}>\n                <TextInput\n                  style={styles.timeInput}\n                  value={time}\n                  onChangeText={(value) => handleTimeChange(index, value)}\n                  placeholder=\"HH:MM\"\n                  placeholderTextColor={colors.text.disabled}\n                />\n                {scheduleTimes.length > 1 && (\n                  <TouchableOpacity\n                    onPress={() => handleRemoveTime(index)}\n                    style={styles.removeButton}\n                  >\n                    <Ionicons name=\"close-circle\" size={24} color={colors.error.main} />\n                  </TouchableOpacity>\n                )}\n              </View>\n            ))}\n            <TouchableOpacity onPress={handleAddTime} style={styles.addTimeButton}>\n              <Ionicons name=\"add-circle-outline\" size={20} color={colors.primary.main} />\n              <Text style={styles.addTimeText}>Add Time</Text>\n            </TouchableOpacity>\n          </View>\n        );\n\n      case 'INTERVAL':\n        return (\n          <View style={styles.section}>\n            <Text style={styles.label}>Every (days)</Text>\n            <TextInput\n              style={styles.input}\n              value={intervalDays}\n              onChangeText={setIntervalDays}\n              keyboardType=\"number-pad\"\n              placeholder=\"E.g., 3\"\n              placeholderTextColor={colors.text.disabled}\n            />\n          </View>\n        );\n\n      case 'WEEKLY':\n        // TODO: Implement weekly schedule selector\n        return (\n          <View style={styles.section}>\n            <Text style={styles.comingSoon}>Weekly schedule coming soon</Text>\n          </View>\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  // Render UI similar to existing patterns...\n  // Include: supplement picker, dosage, unit, schedule type picker, date pickers, notes\n  // Full implementation truncated for brevity - follow app/auth/signup.tsx patterns\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <View style={styles.header}>\n        <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>\n          <Ionicons name=\"arrow-back\" size={24} color={colors.text.primary} />\n        </TouchableOpacity>\n        <Text style={styles.headerTitle}>\n          {isEditing ? 'Edit Supplement' : 'Add Supplement'}\n        </Text>\n        <View style={{ width: 24 }} />\n      </View>\n\n      <ScrollView style={styles.content} contentContainerStyle={styles.contentContainer}>\n        {/* Supplement Picker */}\n        <View style={styles.section}>\n          <Text style={styles.label}>Supplement *</Text>\n          <View style={styles.pickerContainer}>\n            <Picker\n              selectedValue={selectedSupplementId}\n              onValueChange={handleSupplementChange}\n              style={styles.picker}\n            >\n              {supplements.map((s) => (\n                <Picker.Item key={s.id} label={s.name} value={s.id} />\n              ))}\n            </Picker>\n          </View>\n        </View>\n\n        {/* Dosage & Unit */}\n        <View style={styles.row}>\n          <View style={[styles.section, { flex: 2 }]}>\n            <Text style={styles.label}>Dosage *</Text>\n            <TextInput\n              style={styles.input}\n              value={dosage}\n              onChangeText={setDosage}\n              placeholder=\"E.g., 5\"\n              placeholderTextColor={colors.text.disabled}\n            />\n          </View>\n          <View style={[styles.section, { flex: 1, marginLeft: spacing.md }]}>\n            <Text style={styles.label}>Unit *</Text>\n            <TextInput\n              style={styles.input}\n              value={unit}\n              onChangeText={setUnit}\n              placeholder=\"g, mg, IU\"\n              placeholderTextColor={colors.text.disabled}\n            />\n          </View>\n        </View>\n\n        {/* Schedule Type */}\n        <View style={styles.section}>\n          <Text style={styles.label}>Schedule Type *</Text>\n          <View style={styles.pickerContainer}>\n            <Picker\n              selectedValue={scheduleType}\n              onValueChange={(value) => setScheduleType(value as ScheduleType)}\n              style={styles.picker}\n            >\n              <Picker.Item label=\"Daily\" value=\"DAILY\" />\n              <Picker.Item label=\"Multiple times per day\" value=\"DAILY_MULTIPLE\" />\n              <Picker.Item label=\"Weekly\" value=\"WEEKLY\" />\n              <Picker.Item label=\"Every X days\" value=\"INTERVAL\" />\n              <Picker.Item label=\"One-time\" value=\"ONE_TIME\" />\n            </Picker>\n          </View>\n        </View>\n\n        {renderScheduleFields()}\n\n        {/* Start Date */}\n        <View style={styles.section}>\n          <Text style={styles.label}>Start Date *</Text>\n          <TouchableOpacity\n            style={styles.dateButton}\n            onPress={() => setShowStartDatePicker(true)}\n          >\n            <Text style={styles.dateText}>{startDate.toLocaleDateString()}</Text>\n            <Ionicons name=\"calendar-outline\" size={20} color={colors.primary.main} />\n          </TouchableOpacity>\n          {showStartDatePicker && (\n            <DateTimePicker\n              value={startDate}\n              mode=\"date\"\n              onChange={(event, date) => {\n                setShowStartDatePicker(Platform.OS === 'ios');\n                if (date) setStartDate(date);\n              }}\n            />\n          )}\n        </View>\n\n        {/* End Date Toggle */}\n        <TouchableOpacity\n          style={styles.checkboxRow}\n          onPress={() => setHasEndDate(!hasEndDate)}\n        >\n          <Ionicons\n            name={hasEndDate ? 'checkbox' : 'square-outline'}\n            size={24}\n            color={colors.primary.main}\n          />\n          <Text style={styles.checkboxLabel}>Set end date</Text>\n        </TouchableOpacity>\n\n        {hasEndDate && (\n          <View style={styles.section}>\n            <Text style={styles.label}>End Date</Text>\n            <TouchableOpacity\n              style={styles.dateButton}\n              onPress={() => setShowEndDatePicker(true)}\n            >\n              <Text style={styles.dateText}>{endDate.toLocaleDateString()}</Text>\n              <Ionicons name=\"calendar-outline\" size={20} color={colors.primary.main} />\n            </TouchableOpacity>\n            {showEndDatePicker && (\n              <DateTimePicker\n                value={endDate}\n                mode=\"date\"\n                minimumDate={startDate}\n                onChange={(event, date) => {\n                  setShowEndDatePicker(Platform.OS === 'ios');\n                  if (date) setEndDate(date);\n                }}\n              />\n            )}\n          </View>\n        )}\n\n        {/* Notes */}\n        <View style={styles.section}>\n          <Text style={styles.label}>Notes</Text>\n          <TextInput\n            style={[styles.input, styles.textArea]}\n            value={notes}\n            onChangeText={setNotes}\n            placeholder=\"E.g., Take with food\"\n            placeholderTextColor={colors.text.disabled}\n            multiline\n            numberOfLines={3}\n          />\n        </View>\n\n        {/* Save Button */}\n        <TouchableOpacity\n          style={[styles.saveButton, isSaving && styles.saveButtonDisabled]}\n          onPress={handleSave}\n          disabled={isSaving}\n        >\n          <Text style={styles.saveButtonText}>\n            {isSaving ? 'Saving...' : isEditing ? 'Update' : 'Add Supplement'}\n          </Text>\n        </TouchableOpacity>\n      </ScrollView>\n    </SafeAreaView>\n  );\n}\n\n// StyleSheet similar to existing forms...\n\nCreate app/supplements/[id].tsx for detail/edit view (similar structure, shows existing data with edit button)\n\nFollow existing patterns:\n- Form validation\n- Loading states\n- Error handling with getErrorMessage\n- Confirmation dialogs\n- Date pickers\n- Conditional rendering based on schedule type\n- TypeScript typing for all state",
            "status": "pending",
            "testStrategy": "1. Test form renders with all supplements\n2. Test supplement selection auto-fills dosage/unit\n3. Test schedule type picker shows/hides relevant fields\n4. Test DAILY_MULTIPLE time management (add/remove)\n5. Test INTERVAL days input validation\n6. Test date picker functionality\n7. Test form validation (required fields)\n8. Test save functionality\n9. Test edit mode pre-fills form correctly\n10. Test navigation back after save\n11. Visual testing on iOS and Android"
          },
          {
            "id": 12,
            "title": "Create Quick Log and History screens",
            "description": "Implement app/supplements/log.tsx for quick logging and app/supplements/history.tsx for viewing supplement logs with filtering.",
            "dependencies": [
              9
            ],
            "details": "Create app/supplements/log.tsx (Quick Log Screen):\n\nimport { useState, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  ScrollView,\n  TouchableOpacity,\n  TextInput,\n  Alert,\n} from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { Picker } from '@react-native-picker/picker';\nimport DateTimePicker from '@react-native-community/datetimepicker';\nimport { Ionicons } from '@expo/vector-icons';\nimport { supplementsApi, supplementLogsApi } from '@/lib/api/supplements';\nimport { Supplement, CreateSupplementLogInput } from '@/lib/types';\nimport { colors, spacing, typography } from '@/lib/theme/colors';\nimport { getErrorMessage } from '@/lib/utils/errorHandling';\n\nexport default function QuickLogScreen() {\n  const router = useRouter();\n  const [supplements, setSupplements] = useState<Supplement[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isSaving, setIsSaving] = useState(false);\n\n  // Form state\n  const [selectedSupplementId, setSelectedSupplementId] = useState('');\n  const [dosage, setDosage] = useState('');\n  const [unit, setUnit] = useState('g');\n  const [takenAt, setTakenAt] = useState(new Date());\n  const [showDatePicker, setShowDatePicker] = useState(false);\n  const [notes, setNotes] = useState('');\n\n  useEffect(() => {\n    loadSupplements();\n  }, []);\n\n  const loadSupplements = async () => {\n    try {\n      const data = await supplementsApi.getSupplements();\n      setSupplements(data);\n      if (data.length > 0) {\n        setSelectedSupplementId(data[0].id);\n        if (data[0].defaultDosage) setDosage(data[0].defaultDosage);\n        if (data[0].defaultUnit) setUnit(data[0].defaultUnit);\n      }\n    } catch (error) {\n      Alert.alert('Error', getErrorMessage(error, 'Failed to load supplements'));\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleSupplementChange = (supplementId: string) => {\n    setSelectedSupplementId(supplementId);\n    const supplement = supplements.find((s) => s.id === supplementId);\n    if (supplement?.defaultDosage) setDosage(supplement.defaultDosage);\n    if (supplement?.defaultUnit) setUnit(supplement.defaultUnit);\n  };\n\n  const handleSave = async () => {\n    if (!selectedSupplementId || !dosage || !unit) {\n      Alert.alert('Error', 'Please fill in all required fields');\n      return;\n    }\n\n    setIsSaving(true);\n    try {\n      const logData: CreateSupplementLogInput = {\n        supplementId: selectedSupplementId,\n        dosage,\n        unit,\n        takenAt: takenAt.toISOString(),\n        source: 'quick_log',\n        notes: notes || undefined,\n      };\n\n      await supplementLogsApi.create(logData);\n      Alert.alert('Success', 'Supplement logged successfully', [\n        { text: 'OK', onPress: () => router.back() },\n      ]);\n    } catch (error) {\n      Alert.alert('Error', getErrorMessage(error, 'Failed to log supplement'));\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  // Render similar to add supplement form but simpler (no schedule fields)\n  // Include: supplement picker, dosage, unit, date/time picker, notes, save button\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <View style={styles.header}>\n        <TouchableOpacity onPress={() => router.back()}>\n          <Ionicons name=\"close\" size={28} color={colors.text.primary} />\n        </TouchableOpacity>\n        <Text style={styles.headerTitle}>Quick Log</Text>\n        <View style={{ width: 28 }} />\n      </View>\n\n      <ScrollView style={styles.content} contentContainerStyle={styles.contentContainer}>\n        {/* Form fields similar to add screen */}\n        {/* Supplement, Dosage, Unit, Date/Time, Notes */}\n        {/* Save button */}\n      </ScrollView>\n    </SafeAreaView>\n  );\n}\n\n// StyleSheet...\n\nCreate app/supplements/history.tsx (History Screen):\n\nimport { useState, useEffect, useCallback } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  FlatList,\n  TouchableOpacity,\n  RefreshControl,\n  ActivityIndicator,\n  Alert,\n} from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { Ionicons } from '@expo/vector-icons';\nimport { supplementLogsApi } from '@/lib/api/supplements';\nimport { SupplementLog } from '@/lib/types';\nimport { colors, spacing, typography } from '@/lib/theme/colors';\nimport { getErrorMessage } from '@/lib/utils/errorHandling';\n\nexport default function SupplementHistoryScreen() {\n  const router = useRouter();\n  const [logs, setLogs] = useState<SupplementLog[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [refreshing, setRefreshing] = useState(false);\n\n  const loadLogs = useCallback(async () => {\n    try {\n      const data = await supplementLogsApi.getAll();\n      setLogs(data);\n    } catch (error) {\n      Alert.alert('Error', getErrorMessage(error, 'Failed to load history'));\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const onRefresh = useCallback(async () => {\n    setRefreshing(true);\n    await loadLogs();\n    setRefreshing(false);\n  }, [loadLogs]);\n\n  useEffect(() => {\n    loadLogs();\n  }, [loadLogs]);\n\n  const handleDelete = useCallback(\n    async (id: string, name: string) => {\n      Alert.alert('Delete Log', `Delete ${name} log?`, [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Delete',\n          style: 'destructive',\n          onPress: async () => {\n            try {\n              await supplementLogsApi.delete(id);\n              await loadLogs();\n            } catch (error) {\n              Alert.alert('Error', getErrorMessage(error, 'Failed to delete log'));\n            }\n          },\n        },\n      ]);\n    },\n    [loadLogs]\n  );\n\n  const renderLogItem = ({ item }: { item: SupplementLog }) => (\n    <View style={styles.logCard}>\n      <View style={styles.logHeader}>\n        <View style={styles.logInfo}>\n          <Text style={styles.supplementName}>{item.supplement.name}</Text>\n          <Text style={styles.logDosage}>\n            {item.dosage} {item.unit}\n          </Text>\n          <Text style={styles.logTime}>\n            {new Date(item.takenAt).toLocaleString()}\n          </Text>\n          {item.source && (\n            <Text style={styles.logSource}>Source: {item.source}</Text>\n          )}\n        </View>\n        <TouchableOpacity\n          onPress={() => handleDelete(item.id, item.supplement.name)}\n          hitSlop={{ top: 10, right: 10, bottom: 10, left: 10 }}\n        >\n          <Ionicons name=\"trash-outline\" size={20} color={colors.error.main} />\n        </TouchableOpacity>\n      </View>\n      {item.notes && (\n        <Text style={styles.logNotes} numberOfLines={2}>\n          {item.notes}\n        </Text>\n      )}\n    </View>\n  );\n\n  // Render similar to meals list with logs grouped by date\n  // Include: date headers, log items, delete functionality, empty state\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <View style={styles.header}>\n        <Text style={styles.title}>Supplement History</Text>\n        <TouchableOpacity onPress={() => router.push('/supplements/log')}>\n          <Ionicons name=\"add-circle\" size={28} color={colors.primary.main} />\n        </TouchableOpacity>\n      </View>\n\n      {isLoading ? (\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" color={colors.primary.main} />\n        </View>\n      ) : logs.length === 0 ? (\n        <View style={styles.emptyContainer}>\n          <Ionicons name=\"clipboard-outline\" size={64} color={colors.text.disabled} />\n          <Text style={styles.emptyText}>No logs yet</Text>\n          <Text style={styles.emptySubtext}>Tap + to log your first supplement</Text>\n        </View>\n      ) : (\n        <FlatList\n          data={logs}\n          renderItem={renderLogItem}\n          keyExtractor={(item) => item.id}\n          contentContainerStyle={styles.listContainer}\n          refreshControl={\n            <RefreshControl\n              refreshing={refreshing}\n              onRefresh={onRefresh}\n              tintColor={colors.primary.main}\n            />\n          }\n        />\n      )}\n    </SafeAreaView>\n  );\n}\n\n// StyleSheet...\n\nOptional: Create app/supplements/today.tsx for Today's Schedule view:\n- Shows scheduled supplements for today\n- Mark as taken with quick action button\n- Shows adherence percentage\n- Link to quick log for unscheduled supplements\n\nFollow existing patterns:\n- FlatList with RefreshControl\n- Empty states\n- Loading indicators\n- Error handling\n- Confirmation dialogs for destructive actions\n- Grouped lists by date\n- Consistent styling",
            "status": "pending",
            "testStrategy": "1. Test quick log form renders correctly\n2. Test supplement selection auto-fills defaults\n3. Test date/time picker functionality\n4. Test save creates log successfully\n5. Test history screen displays logs\n6. Test logs grouped by date correctly\n7. Test delete functionality with confirmation\n8. Test pull-to-refresh on history\n9. Test empty states\n10. Test navigation between screens\n11. Visual testing on iOS and Android"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-04T21:22:52.961Z",
      "taskCount": 10,
      "completedCount": 0,
      "tags": [
        "master"
      ],
      "created": "2025-12-05T21:12:56.407Z",
      "description": "Tasks for master context",
      "updated": "2025-12-05T21:12:56.420Z"
    }
  }
}