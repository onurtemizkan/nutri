{
  "master": {
    "tasks": [
      {
        "id": 2,
        "title": "Implement Real Food Classification ML Model",
        "description": "Replace the mock food classifier in ml-service/app/services/food_analysis_service.py with a real CNN model (EfficientNet or ResNet) trained on food image datasets.",
        "details": "1. Create a new module `ml-service/app/ml_models/food_classifier.py` with:\n   - Load pre-trained EfficientNet-B0 or ResNet-50 from torchvision\n   - Fine-tune on Food-101 dataset or custom food dataset\n   - Implement proper image preprocessing pipeline matching ImageNet stats\n   - Support for GPU inference if available (auto-detect CUDA)\n\n2. Update `food_analysis_service.py`:\n   - Replace `NUTRITION_DATABASE` with a proper food database (USDA FoodData Central API integration)\n   - Update `_classify_food()` to use real model inference instead of random selection\n   - Add model loading with caching to avoid reloading on each request\n   - Implement top-5 predictions with confidence scores\n\n3. Add model versioning:\n   - Store model checkpoints in `ml-service/models/food_classifier/`\n   - Add `model_version` field to responses\n   - Implement A/B testing capability by loading multiple model versions\n\n4. Extend nutrition database:\n   - Expand from current 6 items to 100+ common foods\n   - Structure: JSON file or SQLite database with USDA data\n   - Include serving size variations (small, medium, large)\n\nPseudo-code for classifier:\n```python\nclass FoodClassifier:\n    def __init__(self, model_path: str = None):\n        self.model = self._load_model(model_path)\n        self.classes = self._load_class_labels()\n    \n    def _load_model(self, path):\n        model = torchvision.models.efficientnet_b0(pretrained=True)\n        model.classifier[-1] = nn.Linear(1280, num_food_classes)\n        if path:\n            model.load_state_dict(torch.load(path))\n        model.eval()\n        return model\n    \n    async def classify(self, image: np.ndarray) -> List[Tuple[str, float]]:\n        tensor = self._preprocess(image)\n        with torch.no_grad():\n            outputs = self.model(tensor)\n            probs = torch.softmax(outputs, dim=1)\n        return self._get_top_k(probs, k=5)\n```",
        "testStrategy": "1. Unit tests for model loading and inference\n2. Test classification accuracy on held-out test set (target >80% top-5)\n3. Integration test: POST /api/food/analyze with real food images\n4. Performance test: Inference time <3s per image\n5. Test model fallback when GPU not available",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Build Health Metrics Mobile UI Screens",
        "description": "Create mobile screens for viewing and manually entering health metrics (RHR, HRV, sleep, recovery). Backend API is complete at /api/health-metrics.",
        "details": "1. Create new screens in `app/` directory:\n   - `app/health/index.tsx` - Health metrics dashboard/list\n   - `app/health/[id].tsx` - Detail view for specific metric\n   - `app/health/add.tsx` - Manual entry form\n\n2. Health Dashboard (`app/health/index.tsx`):\n   - Display today's key metrics in cards (RHR, HRV, Sleep, Recovery)\n   - Time range selector: Today, Week, Month\n   - Pull-to-refresh functionality\n   - Navigate to detail view on tap\n\n3. Metric Detail View (`app/health/[id].tsx`):\n   - Line chart showing metric over time (use react-native-chart-kit or Victory Native)\n   - Statistics: avg, min, max, trend arrow\n   - Data source indicator (Apple Health, Fitbit, Manual)\n   - Date range filter\n\n4. Manual Entry Form (`app/health/add.tsx`):\n   - Metric type picker (dropdown with all HealthMetricType enum values)\n   - Value input with unit display (bpm, ms, hours, %)\n   - Date/time picker (defaults to now)\n   - Source set to 'MANUAL'\n   - Validation: min/max ranges per metric type\n\n5. Create API client in `lib/api/health-metrics.ts`:\n```typescript\nexport const healthMetricsApi = {\n  getAll: (params: { startDate?: string; endDate?: string; metricType?: string }) => \n    apiClient.get('/health-metrics', { params }),\n  getById: (id: string) => apiClient.get(`/health-metrics/${id}`),\n  create: (data: CreateHealthMetricInput) => apiClient.post('/health-metrics', data),\n  getDailySummary: (date: string) => apiClient.get(`/health-metrics/daily/${date}`),\n}\n```\n\n6. Add navigation:\n   - Add 'Health' tab to bottom navigation in `app/(tabs)/_layout.tsx`\n   - Use health heart icon from @expo/vector-icons\n<info added on 2025-12-05T01:32:13.931Z>\nNow I have a comprehensive understanding of the codebase's styling patterns, typography, colors, and testing conventions. Let me provide the update text:\n\n7. Styling and UX Consistency Requirements:\n\nAll Health Metrics screens must follow the established design system in `lib/theme/colors.ts`:\n- Use `colors.background.primary` (#0F1419) as main background\n- Use `colors.background.tertiary` (#1E2330) for cards and surfaces\n- Use `colors.primary.main` (#8B5CF6) for interactive elements\n- Apply `gradients.primary` (purple-pink) for CTAs and active states\n- Text: `colors.text.primary` for headings, `colors.text.tertiary` for labels\n- Use `spacing` constants (xs:4, sm:8, md:16, lg:24, xl:32)\n- Apply `borderRadius` constants (sm:8, md:12, lg:16)\n- Use `typography.fontSize` and `typography.fontWeight` for consistent text styling\n- Import theme tokens: `import { colors, gradients, shadows, spacing, borderRadius, typography } from '@/lib/theme/colors'`\n\nMatch existing UX patterns from `app/(tabs)/index.tsx` and `app/add-meal.tsx`:\n- Cards with `borderWidth: 1, borderColor: colors.border.secondary`\n- Section titles: `fontSize: typography.fontSize['2xl']` or `lg`, `fontWeight: bold/semibold`\n- Form inputs: Height 48px, `backgroundColor: colors.background.tertiary`, `borderRadius: borderRadius.md`\n- Pull-to-refresh using `RefreshControl` with `tintColor={colors.primary.main}`\n- Loading states with `ActivityIndicator` using `colors.primary.main`\n- FAB pattern: 56x56 with LinearGradient and `shadows.xl`\n- SafeAreaView container with ScrollView using `showsVerticalScrollIndicator={false}`\n\n8. Comprehensive Test Requirements:\n\nCreate mobile component tests in `__tests__/` directory using react-native-testing-library:\n\nTest file structure:\n- `__tests__/screens/health/HealthDashboard.test.tsx`\n- `__tests__/screens/health/HealthMetricDetail.test.tsx`\n- `__tests__/screens/health/AddHealthMetric.test.tsx`\n- `__tests__/api/health-metrics.test.ts`\n\nRequired test coverage per screen:\n\nHealthDashboard tests:\n- Renders loading state with ActivityIndicator\n- Renders metric cards for RHR, HRV, Sleep, Recovery when data exists\n- Renders empty state when no health data available\n- Time range selector changes displayed data (Today/Week/Month)\n- Pull-to-refresh triggers API reload\n- Tapping metric card navigates to detail view\n- Error state rendering when API fails\n\nHealthMetricDetail tests:\n- Renders line chart with historical data\n- Displays statistics (avg, min, max, trend)\n- Shows correct data source indicator (Apple Health, Fitbit, Manual)\n- Date range filter updates chart data\n- Handles empty data gracefully\n- Loading and error states\n\nAddHealthMetric (Manual Entry) tests:\n- Metric type picker renders all HealthMetricType enum values\n- Value input accepts numeric input with correct units per type\n- Date/time picker defaults to current time\n- Source automatically set to MANUAL\n- Validation errors for out-of-range values (per metric type)\n- Required field validation\n- Successful submission calls API and navigates back\n- Cancel button discards changes and navigates back\n- Form disabled during submission\n\nAPI client tests (`lib/api/health-metrics.ts`):\n- Follow existing patterns from `__tests__/unit/api/food-analysis.test.ts`\n- Mock axios using `jest.mock('axios')`\n- Test getAll with various query params (startDate, endDate, metricType)\n- Test getById returns single metric\n- Test create sends correct payload and returns created metric\n- Test getDailySummary formats date correctly\n- Test error handling with proper error messages\n\nUse test patterns from existing tests:\n- Arrange, Act, Assert pattern\n- Mock dependencies with `jest.mock()`\n- Use `waitFor` for async assertions\n- Test user interactions with `fireEvent`\n</info added on 2025-12-05T01:32:13.931Z>",
        "testStrategy": "1. Component tests for each screen using react-native-testing-library\n2. Test form validation for manual entry\n3. Test API integration with mock server\n4. Visual regression tests for chart rendering\n5. Test pull-to-refresh behavior\n6. Test empty state when no health data exists",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TypeScript types for health metrics in lib/types/health-metrics.ts",
            "description": "Define TypeScript interfaces and types for health metrics to be used across the mobile app, matching the backend API contracts.",
            "dependencies": [],
            "details": "Create `lib/types/health-metrics.ts` with the following types:\n\n1. **HealthMetricType enum** - Match the 28 types from `server/src/validation/schemas.ts` healthMetricTypeSchema: RESTING_HEART_RATE, HEART_RATE_VARIABILITY_SDNN, HEART_RATE_VARIABILITY_RMSSD, BLOOD_PRESSURE_SYSTOLIC, BLOOD_PRESSURE_DIASTOLIC, RESPIRATORY_RATE, OXYGEN_SATURATION, VO2_MAX, SLEEP_DURATION, DEEP_SLEEP_DURATION, REM_SLEEP_DURATION, SLEEP_EFFICIENCY, SLEEP_SCORE, STEPS, ACTIVE_CALORIES, TOTAL_CALORIES, EXERCISE_MINUTES, STANDING_HOURS, RECOVERY_SCORE, STRAIN_SCORE, READINESS_SCORE, BODY_FAT_PERCENTAGE, MUSCLE_MASS, BONE_MASS, WATER_PERCENTAGE, SKIN_TEMPERATURE, BLOOD_GLUCOSE, STRESS_LEVEL\n\n2. **HealthMetricSource type** - Match `server/src/validation/schemas.ts` healthMetricSourceSchema: 'apple_health' | 'fitbit' | 'garmin' | 'oura' | 'whoop' | 'manual'\n\n3. **HealthMetric interface** - Based on backend response: id, userId, metricType, value, unit, recordedAt, source, sourceId?, metadata?, createdAt, updatedAt\n\n4. **CreateHealthMetricInput interface** - Match `server/src/validation/schemas.ts` createHealthMetricSchema: metricType, value, unit, recordedAt (ISO string), source, sourceId?, metadata?\n\n5. **HealthMetricStats interface** - For stats endpoint: average, min, max, count, trend ('up' | 'down' | 'stable'), percentChange\n\n6. **TimeSeriesDataPoint interface** - For charts: date (string), value, source?\n\n7. **METRIC_CONFIG constant** - Unit and display info per metric type: { unit: string, displayName: string, minValue?: number, maxValue?: number, icon?: string }. Example: RESTING_HEART_RATE: { unit: 'bpm', displayName: 'Resting Heart Rate', minValue: 30, maxValue: 220 }",
            "status": "done",
            "testStrategy": null,
            "updatedAt": "2025-12-05T01:39:21.568Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create health metrics API client in lib/api/health-metrics.ts",
            "description": "Implement API client functions to communicate with the backend health metrics endpoints, following the existing mealsApi pattern in lib/api/meals.ts.",
            "dependencies": [
              1
            ],
            "details": "Create `lib/api/health-metrics.ts` following the pattern from `lib/api/meals.ts`:\n\n```typescript\nimport api from './client';\nimport { HealthMetric, CreateHealthMetricInput, HealthMetricStats, TimeSeriesDataPoint, HealthMetricType, HealthMetricSource } from '../types/health-metrics';\n\nexport interface GetHealthMetricsParams {\n  metricType?: HealthMetricType;\n  startDate?: string;\n  endDate?: string;\n  source?: HealthMetricSource;\n  limit?: number;\n}\n\nexport const healthMetricsApi = {\n  // POST /health-metrics - Create single metric\n  async create(data: CreateHealthMetricInput): Promise<HealthMetric>,\n\n  // GET /health-metrics - Get all with optional filters\n  async getAll(params?: GetHealthMetricsParams): Promise<HealthMetric[]>,\n\n  // GET /health-metrics/:id - Get by ID\n  async getById(id: string): Promise<HealthMetric>,\n\n  // GET /health-metrics/latest/:metricType - Get latest value for a metric type\n  async getLatest(metricType: HealthMetricType): Promise<HealthMetric | null>,\n\n  // GET /health-metrics/timeseries/:metricType - Get time series data for charts\n  async getTimeSeries(metricType: HealthMetricType, startDate?: string, endDate?: string): Promise<TimeSeriesDataPoint[]>,\n\n  // GET /health-metrics/stats/:metricType - Get statistics (avg, min, max, trend)\n  async getStats(metricType: HealthMetricType, days?: number): Promise<HealthMetricStats>,\n\n  // GET /health-metrics/average/daily/:metricType - Get daily average\n  async getDailyAverage(metricType: HealthMetricType, date?: string): Promise<{ average: number; count: number }>,\n\n  // GET /health-metrics/average/weekly/:metricType - Get weekly average\n  async getWeeklyAverage(metricType: HealthMetricType): Promise<{ average: number; count: number }>,\n\n  // DELETE /health-metrics/:id - Delete metric\n  async delete(id: string): Promise<void>,\n};\n```\n\nUse the existing `api` client from `./client` which handles JWT auth token injection. Match the routes from `server/src/routes/healthMetricRoutes.ts`.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T01:39:52.642Z"
          },
          {
            "id": 3,
            "title": "Add Health tab to bottom navigation in app/(tabs)/_layout.tsx",
            "description": "Add a new 'Health' tab to the existing tab navigation using a heart icon, maintaining consistency with the current tab styling.",
            "dependencies": [],
            "details": "Modify `app/(tabs)/_layout.tsx` to add the Health tab:\n\n1. Add the 'heart.fill' SF Symbol to the MAPPING in `components/ui/IconSymbol.tsx`:\n```typescript\n'heart.fill': 'favorite',  // MaterialIcons mapping\n'person.fill': 'person',   // Already exists\n```\n\n2. Add new Tabs.Screen in `app/(tabs)/_layout.tsx` after the index tab and before profile:\n```typescript\n<Tabs.Screen\n  name=\"health\"\n  options={{\n    title: 'Health',\n    tabBarIcon: ({ color }) => <IconSymbol size={28} name=\"heart.fill\" color={color} />,\n  }}\n/>\n```\n\n3. Ensure the tab follows existing styling from tabBarStyle with:\n- `tabBarActiveTintColor: colors.primary.main` (purple #8B5CF6)\n- `tabBarInactiveTintColor: colors.text.disabled` (gray #6B7280)\n- Same height and padding as other tabs\n\n4. Export IconSymbolName type must include 'heart.fill' for TypeScript safety.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T01:40:18.178Z"
          },
          {
            "id": 4,
            "title": "Create Health Dashboard screen at app/(tabs)/health.tsx",
            "description": "Build the main Health Dashboard screen displaying today's key metrics (RHR, HRV, Sleep, Recovery) in cards with time range selector and pull-to-refresh.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `app/(tabs)/health.tsx` following patterns from `app/(tabs)/index.tsx`:\n\n**Imports:**\n- React hooks: useState, useEffect, useCallback\n- Components: View, Text, StyleSheet, ScrollView, TouchableOpacity, RefreshControl, ActivityIndicator\n- expo-router: useRouter\n- SafeAreaView from react-native-safe-area-context\n- LinearGradient from expo-linear-gradient\n- Theme: colors, gradients, shadows, spacing, borderRadius, typography from '@/lib/theme/colors'\n- API: healthMetricsApi from '@/lib/api/health-metrics'\n- Types: HealthMetric, HealthMetricStats, METRIC_CONFIG from '@/lib/types/health-metrics'\n\n**State:**\n- metrics: Record<HealthMetricType, { latest: HealthMetric | null; stats: HealthMetricStats | null }>\n- timeRange: 'today' | 'week' | 'month' (default 'today')\n- isLoading: boolean, refreshing: boolean\n\n**Layout Structure:**\n1. Header with title \"Health\" and date (matches index.tsx greeting style: fontSize: typography.fontSize['3xl'], fontWeight: bold)\n2. Time Range Selector (horizontal buttons like meal type selector in add-meal.tsx)\n3. Metric Cards Grid (2x2) for: RESTING_HEART_RATE, HEART_RATE_VARIABILITY_SDNN, SLEEP_DURATION, RECOVERY_SCORE\n\n**Each Metric Card (TouchableOpacity):**\n- backgroundColor: colors.background.tertiary\n- borderWidth: 1, borderColor: colors.border.secondary\n- borderRadius: borderRadius.lg\n- padding: spacing.md\n- Icon (use Ionicons: heart-outline, pulse-outline, moon-outline, fitness-outline)\n- Label (colors.text.tertiary, fontSize: typography.fontSize.sm)\n- Value (colors.text.primary, fontSize: typography.fontSize['2xl'], fontWeight: bold)\n- Unit (colors.text.tertiary)\n- Trend indicator arrow (green up, red down, gray stable)\n- onPress: router.push(`/health/${metricType}`)\n\n**Pull-to-refresh:** Use RefreshControl with tintColor={colors.primary.main}\n\n**Loading State:** ActivityIndicator centered with colors.primary.main\n\n**Empty State:** \"No health data yet. Add your first metric!\" with button to /health/add",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T01:41:25.915Z"
          },
          {
            "id": 5,
            "title": "Create Metric Detail screen at app/health/[metricType].tsx",
            "description": "Build the detail view for a specific health metric showing historical line chart, statistics (avg, min, max, trend), date range filter, and data source indicator.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `app/health/[metricType].tsx` as a dynamic route screen:\n\n**Imports:**\n- useLocalSearchParams from expo-router to get metricType param\n- LineChart from react-native-chart-kit (install if needed) or VictoryLine from victory-native\n- All theme imports from lib/theme/colors\n- healthMetricsApi and types\n\n**State:**\n- timeSeries: TimeSeriesDataPoint[] for chart data\n- stats: HealthMetricStats | null\n- dateRange: '7d' | '30d' | '90d' (default '30d')\n- isLoading: boolean\n\n**Layout:**\n1. **Header** with back button (TouchableOpacity with Ionicons chevron-back) and metric display name from METRIC_CONFIG\n\n2. **Date Range Selector** - Horizontal buttons matching add-meal.tsx mealTypeContainer style:\n   - 7 Days, 30 Days, 90 Days\n   - Active: LinearGradient with gradients.primary\n   - Inactive: backgroundColor: colors.background.tertiary\n\n3. **Line Chart** (full width, height ~200):\n   - backgroundColor: colors.background.tertiary\n   - Line color: colors.primary.main (#8B5CF6)\n   - Grid lines: colors.border.secondary\n   - Labels: colors.text.tertiary\n   - Data points from timeSeries API response\n\n4. **Statistics Card** (similar to macrosContainer in index.tsx):\n   - Three columns: Average, Minimum, Maximum\n   - Each shows value with unit\n   - fontSize: typography.fontSize.xl for values\n   - backgroundColor: colors.background.tertiary\n   - borderRadius: borderRadius.md\n\n5. **Trend Section:**\n   - Arrow icon (trending-up/down/minus from Ionicons)\n   - Percentage change text\n   - Color: status.success (green) for up, status.error (red) for down\n\n6. **Data Source Badge:**\n   - Icon per source (Apple Health, Fitbit, Manual, etc.)\n   - Text showing source name\n   - colors.text.tertiary styling\n\n**Chart Config (react-native-chart-kit):**\n```typescript\nchartConfig: {\n  backgroundColor: colors.background.tertiary,\n  backgroundGradientFrom: colors.background.tertiary,\n  backgroundGradientTo: colors.background.tertiary,\n  color: (opacity = 1) => `rgba(139, 92, 246, ${opacity})`, // primary.main\n  labelColor: (opacity = 1) => `rgba(156, 163, 175, ${opacity})`, // text.tertiary\n  strokeWidth: 2,\n}\n```",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T01:43:39.003Z"
          },
          {
            "id": 6,
            "title": "Create Manual Entry form at app/health/add.tsx",
            "description": "Build the form for manually entering health metrics with metric type picker, value input with dynamic units, date/time picker, and validation for min/max ranges per metric type.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `app/health/add.tsx` following the pattern from `app/add-meal.tsx`:\n\n**Imports:**\n- useState, useEffect from react\n- All RN components: View, Text, TextInput, TouchableOpacity, StyleSheet, ScrollView, KeyboardAvoidingView, Platform, ActivityIndicator\n- useRouter from expo-router\n- SafeAreaView, LinearGradient, Ionicons\n- DateTimePicker from @react-native-community/datetimepicker (or expo-date-time-picker)\n- Picker from @react-native-picker/picker\n- healthMetricsApi, CreateHealthMetricInput, HealthMetricType, METRIC_CONFIG\n- colors, gradients, spacing, borderRadius, typography from theme\n- showAlert from '@/lib/utils/alert'\n- getErrorMessage from '@/lib/utils/errorHandling'\n\n**State:**\n- metricType: HealthMetricType (default 'RESTING_HEART_RATE')\n- value: string (for TextInput)\n- recordedAt: Date (default new Date())\n- isLoading: boolean\n- showDatePicker: boolean\n- errors: { value?: string }\n\n**Layout (match add-meal.tsx structure):**\n1. **Header** - Same as add-meal: Cancel (left), \"Add Health Metric\" (center), Save (right)\n   - Cancel: text style, color: colors.text.secondary\n   - Save: text style, color: colors.primary.main, disabled when isLoading\n\n2. **Metric Type Picker Section:**\n   - Label: \"Metric Type\" (styles.sectionTitle)\n   - Dropdown picker with all 28 HealthMetricType values\n   - Group by category: Cardiovascular, Sleep, Activity, Recovery, Body Composition\n   - Display friendly names from METRIC_CONFIG.displayName\n\n3. **Value Input Section:**\n   - Label: \"Value ({unit})\" - dynamically show unit from METRIC_CONFIG[metricType].unit\n   - TextInput with keyboardType=\"decimal-pad\"\n   - Height 48px, backgroundColor: colors.background.tertiary\n   - Validation message below if out of range (colors.status.error)\n\n4. **Date/Time Picker Section:**\n   - Label: \"Recorded At\"\n   - TouchableOpacity showing formatted date/time\n   - Opens DateTimePicker modal\n   - Default to current time\n\n5. **Source Badge** (non-editable):\n   - Shows \"Manual\" with checkmark icon\n   - Subtle styling: colors.special.highlight background\n\n**Validation:**\n- Value required and numeric\n- Check against METRIC_CONFIG[metricType].minValue and maxValue\n- Show inline error: \"Value must be between {min} and {max} {unit}\"\n\n**handleSave:**\n```typescript\nconst data: CreateHealthMetricInput = {\n  metricType,\n  value: parseFloat(value),\n  unit: METRIC_CONFIG[metricType].unit,\n  recordedAt: recordedAt.toISOString(),\n  source: 'manual',\n};\nawait healthMetricsApi.create(data);\nshowAlert('Success', 'Health metric added!', [{ text: 'OK', onPress: () => router.back() }]);\n```",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-05T01:45:06.446Z"
          },
          {
            "id": 7,
            "title": "Write unit tests for health-metrics API client",
            "description": "Create comprehensive unit tests for lib/api/health-metrics.ts following the existing test patterns from __tests__/unit/api/food-analysis.test.ts.",
            "dependencies": [
              2
            ],
            "details": "Create `__tests__/unit/api/health-metrics.test.ts`:\n\n**Setup:**\n```typescript\nimport axios from 'axios';\nimport { healthMetricsApi } from '@/lib/api/health-metrics';\nimport { HealthMetric, HealthMetricType, HealthMetricStats, TimeSeriesDataPoint } from '@/lib/types/health-metrics';\n\njest.mock('axios');\nconst mockedAxios = axios as jest.Mocked<typeof axios>;\n```\n\n**Test Fixtures:**\n```typescript\nconst mockHealthMetric: HealthMetric = {\n  id: 'metric-1',\n  userId: 'user-1',\n  metricType: 'RESTING_HEART_RATE',\n  value: 62,\n  unit: 'bpm',\n  recordedAt: '2024-01-15T08:00:00Z',\n  source: 'manual',\n  createdAt: '2024-01-15T08:00:00Z',\n  updatedAt: '2024-01-15T08:00:00Z',\n};\n\nconst mockStats: HealthMetricStats = {\n  average: 65,\n  min: 58,\n  max: 72,\n  count: 30,\n  trend: 'down',\n  percentChange: -3.5,\n};\n```\n\n**Test Cases:**\n\n1. **create():**\n   - Should successfully create a health metric\n   - Should send correct payload format to POST /health-metrics\n   - Should handle validation errors (400)\n   - Should handle auth errors (401)\n\n2. **getAll():**\n   - Should return array of metrics\n   - Should pass query params (metricType, startDate, endDate, source, limit)\n   - Should handle empty results\n   - Should handle network errors\n\n3. **getById():**\n   - Should return single metric by ID\n   - Should handle 404 not found\n\n4. **getLatest():**\n   - Should return latest metric for type\n   - Should return null when no metrics exist\n\n5. **getTimeSeries():**\n   - Should return array of data points for chart\n   - Should pass date range params\n   - Should handle empty data gracefully\n\n6. **getStats():**\n   - Should return stats with average, min, max, trend\n   - Should pass days param\n   - Should handle 404 when no data\n\n7. **getDailyAverage() and getWeeklyAverage():**\n   - Should return average and count\n   - Should handle date param for daily\n\n8. **delete():**\n   - Should successfully delete metric\n   - Should handle 404 errors\n\n**Pattern:** Use Arrange, Act, Assert. Mock `api.get`, `api.post`, `api.delete` from the client module.",
            "status": "done",
            "testStrategy": "Run with `npm test __tests__/unit/api/health-metrics.test.ts`. Verify all API methods are tested with success and error cases. Check coverage with `npm run test:coverage`.",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T01:46:30.103Z"
          },
          {
            "id": 8,
            "title": "Write component tests for Health screens",
            "description": "Create comprehensive component tests for HealthDashboard, HealthMetricDetail, and AddHealthMetric screens using react-native-testing-library.",
            "dependencies": [
              4,
              5,
              6
            ],
            "details": "Create test files in `__tests__/screens/health/` directory:\n\n**1. __tests__/screens/health/HealthDashboard.test.tsx:**\n```typescript\nimport React from 'react';\nimport { render, fireEvent, waitFor } from '@testing-library/react-native';\nimport HealthDashboard from '@/app/(tabs)/health';\nimport { healthMetricsApi } from '@/lib/api/health-metrics';\n\njest.mock('@/lib/api/health-metrics');\njest.mock('expo-router', () => ({ useRouter: () => ({ push: jest.fn() }) }));\njest.mock('@/lib/context/AuthContext', () => ({ useAuth: () => ({ user: { id: '1', name: 'Test' } }) }));\n```\n\nTest cases:\n- Renders loading state with ActivityIndicator initially\n- Renders metric cards when data loads successfully\n- Renders empty state when no health data available\n- Time range selector updates displayed data (Today/Week/Month)\n- Pull-to-refresh triggers API reload (test RefreshControl onRefresh)\n- Tapping metric card calls router.push with correct metric type\n- Error state renders when API fails\n\n**2. __tests__/screens/health/HealthMetricDetail.test.tsx:**\n\nTest cases:\n- Renders line chart with historical data points\n- Displays statistics (avg, min, max, trend arrow, percentage)\n- Shows correct data source indicator icon/text\n- Date range filter buttons update chart data (7d/30d/90d)\n- Handles empty data gracefully with message\n- Loading state shows ActivityIndicator\n- Error state with retry button\n\n**3. __tests__/screens/health/AddHealthMetric.test.tsx:**\n\nTest cases:\n- Metric type picker renders all HealthMetricType enum values\n- Value input accepts numeric input and shows correct unit dynamically\n- Date/time picker defaults to current time and opens modal\n- Source automatically displays \"Manual\"\n- Shows validation error for out-of-range values (test per metric type bounds)\n- Shows required field validation when value empty\n- Successful submission calls API and navigates back\n- Cancel button navigates back without saving\n- Form inputs disabled during submission (isLoading state)\n- Shows loading indicator on Save button during submission\n\n**Common Mocks:**\n- Mock @react-native-community/datetimepicker\n- Mock @react-native-picker/picker\n- Mock react-native-chart-kit or victory-native\n- Mock expo-linear-gradient",
            "status": "done",
            "testStrategy": "Run with `npm test __tests__/screens/health/`. Verify all user interactions are tested. Use `fireEvent` for button presses and text input. Use `waitFor` for async operations. Target 80%+ coverage for all three screens.",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T01:46:30.166Z"
          }
        ],
        "updatedAt": "2025-12-05T01:59:24.616Z"
      },
      {
        "id": 4,
        "title": "Build Activity Tracking Mobile UI Screens",
        "description": "Create mobile screens for viewing and manually logging activities. Backend API is complete at /api/activities.",
        "details": "1. Create new screens in `app/` directory:\n   - `app/activity/index.tsx` - Activity list/history\n   - `app/activity/[id].tsx` - Activity detail view\n   - `app/activity/add.tsx` - Manual activity entry form\n\n2. Activity List (`app/activity/index.tsx`):\n   - Weekly summary card: total minutes, calories, workout count\n   - Filter by activity type (All, Cardio, Strength, Flexibility)\n   - List of recent activities with icon, duration, calories\n   - Floating action button to add new activity\n   - Pull-to-refresh\n\n3. Activity Detail View (`app/activity/[id].tsx`):\n   - Display all activity fields: type, duration, intensity, calories\n   - Heart rate data if available (avg, max)\n   - Distance and steps for applicable activities\n   - Notes field\n   - Edit/Delete buttons\n\n4. Manual Entry Form (`app/activity/add.tsx`):\n   - Activity type picker (21 types from ActivityType enum)\n   - Intensity picker (Low, Moderate, High, Maximum)\n   - Duration input (hours:minutes picker)\n   - Date/time pickers for start time\n   - Optional fields: calories, heart rate, distance, notes\n   - Validation: duration > 0, end time > start time\n\n5. Create API client in `lib/api/activities.ts`:\n```typescript\nexport const activitiesApi = {\n  getAll: (params?: { activityType?: string; startDate?: string }) =>\n    apiClient.get('/activities', { params }),\n  getById: (id: string) => apiClient.get(`/activities/${id}`),\n  create: (data: CreateActivityInput) => apiClient.post('/activities', data),\n  update: (id: string, data: Partial<CreateActivityInput>) =>\n    apiClient.put(`/activities/${id}`, data),\n  delete: (id: string) => apiClient.delete(`/activities/${id}`),\n  getWeeklySummary: () => apiClient.get('/activities/weekly-summary'),\n}\n```\n\n6. Add activity icons mapping for different activity types",
        "testStrategy": "1. Component tests for each screen\n2. Test form validation (duration, time constraints)\n3. Test activity type filtering\n4. Test CRUD operations with mock API\n5. Test weekly summary calculation display\n6. Test edit/delete flows with confirmation dialogs",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Apple HealthKit Integration",
        "description": "Enable automatic sync of comprehensive health data from Apple HealthKit including cardiovascular metrics (RHR, Heart Rate, HRV SDNN/RMSSD), sleep quality metrics (duration, deep sleep, REM, efficiency, score), respiratory data (respiratory rate, oxygen saturation), and VO2Max.",
        "status": "done",
        "dependencies": [
          "3",
          "4"
        ],
        "priority": "medium",
        "details": "1. Install and configure react-native-health (recommended for Expo managed workflow):\n   - Add `react-native-health` to package.json dependencies\n   - Configure `app.json` with NSHealthShareUsageDescription and NSHealthUpdateUsageDescription\n   - Add HealthKit entitlement to iOS build configuration\n   - Request HealthKit permissions on iOS for all metric types\n\n2. **Schema Consideration**: The existing Prisma HealthMetricType enum in `server/prisma/schema.prisma` already supports:\n   - Cardiovascular: `RESTING_HEART_RATE`, `HEART_RATE_VARIABILITY_SDNN`, `HEART_RATE_VARIABILITY_RMSSD`\n   - Respiratory: `RESPIRATORY_RATE`, `OXYGEN_SATURATION`, `VO2_MAX`\n   - Sleep: `SLEEP_DURATION`, `DEEP_SLEEP_DURATION`, `REM_SLEEP_DURATION`, `SLEEP_EFFICIENCY`, `SLEEP_SCORE`\n   - NOTE: Consider adding `HEART_RATE` (instantaneous/average HR, separate from resting) if needed for workout HR data\n\n3. Create health sync service in `lib/services/healthkit.ts`:\n```typescript\nexport interface HealthKitConfig {\n  permissions: {\n    read: HealthKitPermission[];\n    write?: HealthKitPermission[];\n  };\n}\n\nexport const healthKitService = {\n  // Initialize and request permissions\n  requestPermissions: () => Promise<boolean>,\n  isAvailable: () => Promise<boolean>,\n  \n  // Sync cardiovascular data\n  syncCardiovascularMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKQuantityTypeIdentifierRestingHeartRate → RESTING_HEART_RATE\n  // - HKQuantityTypeIdentifierHeartRate → instantaneous HR samples\n  // - HKQuantityTypeIdentifierHeartRateVariabilitySDNN → HEART_RATE_VARIABILITY_SDNN\n  // - HKQuantityTypeIdentifier.heartRateVariabilityRMSSD (if available)\n  \n  // Sync respiratory data\n  syncRespiratoryMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKQuantityTypeIdentifierRespiratoryRate → RESPIRATORY_RATE\n  // - HKQuantityTypeIdentifierOxygenSaturation → OXYGEN_SATURATION\n  // - HKQuantityTypeIdentifierVO2Max → VO2_MAX\n  \n  // Sync sleep data\n  syncSleepMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKCategoryTypeIdentifierSleepAnalysis → parse into:\n  //   - SLEEP_DURATION (total sleep time)\n  //   - DEEP_SLEEP_DURATION (deep/core sleep stages)\n  //   - REM_SLEEP_DURATION (REM stages)\n  //   - SLEEP_EFFICIENCY (time asleep / time in bed)\n  //   - SLEEP_SCORE (if available from source)\n  \n  // Sync activity data\n  syncActivityMetrics: (startDate: Date, endDate: Date) => Promise<HealthMetric[]>,\n  // - HKQuantityTypeIdentifierStepCount → STEPS\n  // - HKQuantityTypeIdentifierActiveEnergyBurned → ACTIVE_CALORIES\n  // - HKWorkoutType → Activity model with exercise HR data\n  \n  // Background sync\n  setupBackgroundSync: () => void,\n}\n```\n\n4. HealthKit type identifiers mapping:\n```typescript\nconst HEALTHKIT_TYPE_MAP = {\n  // Cardiovascular\n  HKQuantityTypeIdentifierRestingHeartRate: 'RESTING_HEART_RATE',\n  HKQuantityTypeIdentifierHeartRateVariabilitySDNN: 'HEART_RATE_VARIABILITY_SDNN',\n  // Note: RMSSD might need manual calculation from RR intervals\n  \n  // Respiratory\n  HKQuantityTypeIdentifierRespiratoryRate: 'RESPIRATORY_RATE',\n  HKQuantityTypeIdentifierOxygenSaturation: 'OXYGEN_SATURATION',\n  HKQuantityTypeIdentifierVO2Max: 'VO2_MAX',\n  \n  // Sleep (requires parsing HKCategoryTypeIdentifierSleepAnalysis)\n  // Sleep stages: inBed, asleepUnspecified, awake, asleepCore, asleepDeep, asleepREM\n  \n  // Activity\n  HKQuantityTypeIdentifierStepCount: 'STEPS',\n  HKQuantityTypeIdentifierActiveEnergyBurned: 'ACTIVE_CALORIES',\n};\n```\n\n5. Implement data transformation layer:\n   - Convert HealthKit units to API units (bpm, ms, %, steps, kcal, etc.)\n   - Match existing Zod validation schemas in `server/src/validation/schemas.ts`\n   - Use source: 'apple_health' to match healthMetricSourceSchema\n   - Include device metadata: {device: \"Apple Watch\", quality: \"high\"}\n\n6. Create sync flow:\n   - Initial sync: Fetch last 30 days of data on first connect\n   - Incremental sync: Fetch data since last sync timestamp\n   - Store lastSyncTimestamp in Expo SecureStore (per metric type for efficiency)\n   - Batch API calls using bulkCreateHealthMetricsSchema (50 items per request)\n   - Handle timezone conversions (HealthKit returns local time, API expects UTC)\n\n7. Handle data deduplication:\n   - Use existing (userId, metricType, recordedAt, source) unique constraint in schema\n   - Server handles conflicts via upsert\n   - Store sourceId from HealthKit sample UUID for traceability\n\n8. Add sync UI in profile settings (app/profile.tsx or new app/settings/health.tsx):\n   - Connect/Disconnect Apple Health button\n   - Permission status for each metric category\n   - Last sync timestamp display (per category)\n   - Manual sync button with progress indicator\n   - Sync status indicator (syncing, synced, error)\n   - Data preview showing recently synced metrics\n\n9. Handle background sync (future enhancement):\n   - Configure iOS background fetch capability\n   - Sync when app becomes active via AppState listener\n   - Respect battery and data usage settings\n   - Consider using HealthKit's HKObserverQuery for real-time updates",
        "testStrategy": "1. Unit tests for HealthKit service:\n   - Mock react-native-health module for simulator testing\n   - Test permission request flow and error handling\n   - Test data transformation for each metric type (HK format → API format)\n   - Test unit conversions (HK units → standard units)\n\n2. Test cardiovascular data sync:\n   - Mock RHR samples → verify RESTING_HEART_RATE records\n   - Mock HRV samples → verify HEART_RATE_VARIABILITY_SDNN records\n   - Test edge cases: missing data, invalid values\n\n3. Test respiratory data sync:\n   - Mock respiratory rate → verify RESPIRATORY_RATE records\n   - Mock SpO2 → verify OXYGEN_SATURATION records\n   - Mock VO2Max → verify VO2_MAX records\n\n4. Test sleep data parsing:\n   - Mock sleep analysis categories → verify correct stage classification\n   - Test sleep efficiency calculation (time asleep / time in bed)\n   - Test sleep duration aggregation across fragmented sleep\n\n5. Test sync error handling and retry logic:\n   - Network errors during bulk upload\n   - Partial failures in batch operations\n   - Permission denied scenarios\n\n6. Test deduplication with existing data:\n   - Re-sync same data → verify no duplicates\n   - Test sourceId matching\n\n7. Test UI state updates during sync:\n   - Loading states\n   - Progress indication\n   - Error display\n\n8. Manual testing on physical device:\n   - Test with real Apple Watch data\n   - Verify data accuracy against Health app\n   - Test permission prompts\n   - Test background sync behavior",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and configure react-native-health package",
            "description": "Add react-native-health dependency and configure iOS build settings with proper entitlements and Info.plist descriptions",
            "dependencies": [],
            "details": "Install react-native-health via npm/yarn. Update app.json with NSHealthShareUsageDescription explaining why the app needs read access to health data. Add HealthKit entitlement. Configure iOS build to include HealthKit framework. Test that the package builds correctly on iOS simulator/device.",
            "status": "done",
            "testStrategy": "Verify package installs without errors. Confirm iOS build succeeds. Check Info.plist contains correct health usage descriptions.",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:30:33.391Z"
          },
          {
            "id": 2,
            "title": "Create HealthKit permission management system",
            "description": "Implement permission request flow for all required HealthKit data types including cardiovascular, respiratory, and sleep metrics",
            "dependencies": [
              1
            ],
            "details": "Create lib/services/healthkit/permissions.ts. Define permission sets for each metric category. Implement isAvailable() check for HealthKit. Implement requestPermissions() with granular permission requests. Handle partial permission grants gracefully. Store permission status in context/state.",
            "status": "done",
            "testStrategy": "Mock HealthKit permissions. Test all permission states (granted, denied, not determined). Test partial permission scenarios.",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:30:33.786Z"
          },
          {
            "id": 3,
            "title": "Implement cardiovascular metrics sync (RHR, HR, HRV)",
            "description": "Create sync functions for Resting Heart Rate, Heart Rate samples, and Heart Rate Variability (SDNN and RMSSD)",
            "dependencies": [
              2
            ],
            "details": "Implement syncCardiovascularMetrics() in healthkit.ts. Query HKQuantityTypeIdentifierRestingHeartRate for RHR. Query HKQuantityTypeIdentifierHeartRateVariabilitySDNN for HRV. Transform HealthKit samples to match HealthMetric API format. Handle unit conversions (HK returns bpm/ms). Include device metadata from sample source.",
            "status": "done",
            "testStrategy": "Mock HK cardiovascular queries. Verify correct transformation to RESTING_HEART_RATE and HEART_RATE_VARIABILITY_SDNN types. Test unit handling.",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:30:33.979Z"
          },
          {
            "id": 4,
            "title": "Implement respiratory metrics sync (respiratory rate, SpO2, VO2Max)",
            "description": "Create sync functions for respiratory rate, oxygen saturation, and VO2Max data from HealthKit",
            "dependencies": [
              2
            ],
            "details": "Implement syncRespiratoryMetrics() in healthkit.ts. Query HKQuantityTypeIdentifierRespiratoryRate, HKQuantityTypeIdentifierOxygenSaturation, and HKQuantityTypeIdentifierVO2Max. Transform to RESPIRATORY_RATE, OXYGEN_SATURATION, and VO2_MAX metric types. Handle different sample frequencies (VO2Max is less frequent).",
            "status": "done",
            "testStrategy": "Mock HK respiratory queries. Verify correct transformation to API format. Test handling of sparse VO2Max data.",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:30:34.209Z"
          },
          {
            "id": 5,
            "title": "Implement sleep metrics sync with stage classification",
            "description": "Create sync function for sleep analysis including duration, deep sleep, REM, and efficiency calculations",
            "dependencies": [
              2
            ],
            "details": "Implement syncSleepMetrics() in healthkit.ts. Query HKCategoryTypeIdentifierSleepAnalysis. Parse sleep stages (asleepCore→DEEP_SLEEP, asleepDeep→DEEP_SLEEP, asleepREM→REM_SLEEP). Calculate total SLEEP_DURATION. Calculate SLEEP_EFFICIENCY (asleep time / in bed time). Handle fragmented sleep sessions.",
            "status": "done",
            "testStrategy": "Mock HK sleep analysis with various stage combinations. Verify correct duration calculations. Test efficiency calculation accuracy. Test fragmented sleep handling.",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:30:34.351Z"
          },
          {
            "id": 6,
            "title": "Implement activity metrics sync (steps, active calories)",
            "description": "Create sync function for daily activity data including step count and active energy burned",
            "dependencies": [
              2
            ],
            "details": "Implement syncActivityMetrics() in healthkit.ts. Query HKQuantityTypeIdentifierStepCount and HKQuantityTypeIdentifierActiveEnergyBurned. Aggregate daily totals. Transform to STEPS and ACTIVE_CALORIES metric types. Handle timezone boundaries for daily aggregation.",
            "status": "done",
            "testStrategy": "Mock HK activity queries. Verify daily aggregation logic. Test timezone handling for day boundaries.",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:30:34.528Z"
          },
          {
            "id": 7,
            "title": "Create batch sync orchestration with API integration",
            "description": "Implement the main sync orchestration that coordinates all metric syncs and uploads to the backend API",
            "dependencies": [
              3,
              4,
              5,
              6
            ],
            "details": "Create syncAllHealthData() coordinator function. Implement incremental sync using stored lastSyncTimestamp from SecureStore. Batch API uploads using bulkCreateHealthMetricsSchema (50 items per request). Handle partial failures and retry logic. Update lastSyncTimestamp per metric category on success.",
            "status": "done",
            "testStrategy": "Test full sync orchestration flow. Verify batch chunking at 50 items. Test incremental sync with stored timestamps. Test error handling and retry.",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:30:34.685Z"
          },
          {
            "id": 8,
            "title": "Build HealthKit settings UI with sync controls",
            "description": "Create the user interface for managing HealthKit connection, viewing sync status, and triggering manual syncs",
            "dependencies": [
              7
            ],
            "details": "Create app/settings/health.tsx screen or add section to app/profile.tsx. Display Connect/Disconnect Apple Health button. Show permission status per metric category with toggle indicators. Display last sync timestamp and synced data counts. Add manual Sync Now button with progress indicator. Show sync status (syncing/synced/error) with appropriate feedback.",
            "status": "done",
            "testStrategy": "Test UI component rendering. Test connect/disconnect flow. Test sync button interaction and loading states. Test error state display.",
            "parentId": "undefined",
            "updatedAt": "2025-12-11T20:30:34.823Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down the Apple HealthKit integration into implementation phases:\n\n1. **Library Setup & Configuration**: Install react-native-health or expo-health-connect, configure iOS entitlements in app.json (NSHealthShareUsageDescription), and set up the Expo plugin. Research which library works best with Expo SDK 52.\n\n2. **HealthKit Service Core**: Create `lib/services/healthkit.ts` with typed interfaces matching the existing TypeScript patterns in `lib/types/index.ts`. Implement the base service structure with permission request methods.\n\n3. **Data Fetching Implementation**: Implement data fetching for each metric type mapping HealthKit identifiers to the existing HealthMetricType enum (RESTING_HEART_RATE, HEART_RATE_VARIABILITY_SDNN, SLEEP_DURATION, STEPS, ACTIVE_CALORIES). Note: Add ACTIVE_HEART_RATE to schema.prisma for instantaneous HR.\n\n4. **Activity Sync Implementation**: Map HKWorkoutType to the existing ActivityType enum (RUNNING, CYCLING, SWIMMING, etc.) in schema.prisma. Handle activity data transformation.\n\n5. **Sync Logic & State Management**: Implement initial sync (30 days), incremental sync with lastSyncTimestamp stored in SecureStore (pattern from lib/api/client.ts), batch API calls (50 items/request), and leverage the existing bulk endpoint at `/api/health-metrics/bulk`.\n\n6. **Profile UI Integration**: Extend the existing `app/(tabs)/profile.tsx` with a Health Integration section. Add Connect/Disconnect Apple Health button, sync status indicators, last sync timestamp display, and manual sync button following the existing design patterns.\n\n7. **Testing & Error Handling**: Mock HealthKit data for simulator, test permission flows, data transformation, sync error handling/retry logic, and UI state updates. Follow existing error handling patterns in lib/utils/errorHandling.ts.",
        "updatedAt": "2025-12-11T20:30:34.823Z"
      },
      {
        "id": 6,
        "title": "Train and Deploy LSTM Models for Health Predictions",
        "description": "Train LSTM models for RHR and HRV prediction using the existing HealthMetricLSTM architecture in ml-service/app/ml_models/lstm.py (with LSTMConfig params: hidden_dim, num_layers, dropout) and make them production-ready. Leverage existing ModelTrainingService skeleton in model_training.py and PredictionService in prediction.py.",
        "status": "done",
        "dependencies": [
          "3",
          "5"
        ],
        "priority": "high",
        "details": "## Prerequisites (DONE)\n- Task 3 (Health Metrics Mobile UI) - COMPLETE\n- Task 5 (HealthKit Integration) - COMPLETE\n- Feature engineering service ready in `ml-service/app/services/feature_engineering.py` (50+ features)\n\n## Existing Infrastructure\n\n### LSTM Architecture (ml-service/app/ml_models/lstm.py)\n- `LSTMConfig` dataclass: input_dim, hidden_dim=128, num_layers=2, dropout=0.2, sequence_length=30\n- `HealthMetricLSTM`: forward(), predict(), count_parameters(), to_device()\n- `MultiTaskLSTM`: For simultaneous RHR + HRV prediction\n- `LSTMWithAttention`: For interpretability with attention weights\n\n### ModelTrainingService (ml-service/app/services/model_training.py)\n- Already has `train_model()` method with full pipeline:\n  - Data preparation via DataPreparationService\n  - LSTM model initialization with LSTMConfig\n  - Training loop with early stopping (patience=10)\n  - Model evaluation (MAE, RMSE, R², MAPE)\n  - Model saving with artifacts (model.pt, scaler.pkl, metadata.pkl)\n- Quality assessment with production thresholds (R² > 0.5, MAPE < 15%)\n\n### PredictionService (ml-service/app/services/prediction.py)\n- Complete implementation with:\n  - Model loading via `_load_model_artifacts()`\n  - Prediction with confidence intervals\n  - Historical stats and percentile calculation\n  - Natural language interpretation\n  - Redis caching (24h TTL)\n\n### Inference Queue (ml-service/app/core/queue/)\n- `InferenceQueue` class in manager.py with:\n  - Semaphore-based concurrency control\n  - Circuit breaker integration (circuit_breaker.py)\n  - Background workers for processing\n- `QueueMetrics` in metrics.py with Prometheus metrics:\n  - nutri_ml_queue_size, nutri_ml_active_inferences\n  - nutri_ml_inference_duration_seconds histogram\n  - Circuit breaker state tracking\n\n### Model Storage Pattern (from what_if.py)\n- Pattern: `models/{user_id}_{metric}_{timestamp}/`\n- Artifacts: model.pt, config.pkl, scaler.pkl, label_scaler.pkl, feature_names.pkl, metadata.pkl\n\n## Implementation Tasks\n\n### 1. Add Minimum Data Requirements Validation\nAdd `validate_training_data_requirements()` in ModelTrainingService:\n- Check at least 30 days of health metrics (RHR/HRV)\n- Check at least 21 days of nutrition data\n- Raise descriptive ValueError if insufficient\n\n### 2. Create Training API Endpoints\nCreate `ml-service/app/api/training.py`:\n- POST `/api/v1/models/train` - Async training with job_id\n- GET `/api/v1/models/{model_id}` - Model info and metrics\n- GET `/api/v1/models/user/{user_id}` - List user models\n- Store training status in Redis with TTL\n\n### 3. Integrate with Inference Queue\nLeverage existing queue pattern for training jobs:\n- Use InferenceQueue for managing training jobs\n- Integrate with existing QueueMetrics for monitoring\n- Add training-specific metrics (training_duration, model_quality)\n\n### 4. Add Model Versioning\nEnhance ModelTrainingService:\n- Semantic versioning (v1.0.0, v1.0.1)\n- Active model tracking per user/metric\n- `rollback_to_version()` capability\n- `cleanup_old_models()` keeping last 5 versions\n\n### 5. Create Prediction API Endpoints\nCreate `ml-service/app/api/predictions_api.py`:\n- POST `/api/v1/predict` - Single prediction\n- POST `/api/v1/predict/batch` - Multiple metrics\n- POST `/api/v1/predict/what-if` - Scenario testing (integrate with what_if.py)\n- Use existing PredictionService\n\n### 6. Add Prometheus Metrics for Training\nExtend existing metrics pattern:\n- Training job duration histogram\n- Model quality metrics (R², MAPE)\n- Training failures counter\n- Active training jobs gauge\n\n### Training Configuration\n```python\nLSTMConfig(\n    input_dim=num_features,  # From feature engineering (50+)\n    hidden_dim=128,\n    num_layers=2,\n    dropout=0.2,\n    sequence_length=30,\n    device='cuda' if torch.cuda.is_available() else 'cpu'\n)\n\n# Training params (already in model_training.py)\nbatch_size=32\nlearning_rate=0.001\nepochs=100 (max)\nearly_stopping_patience=10\n```",
        "testStrategy": "1. Unit tests for data validation (test insufficient data raises ValueError)\n2. Test training with synthetic data generator (verify loss decreases over epochs)\n3. Test model save/load roundtrip preserves predictions exactly\n4. Test evaluation metrics calculation accuracy\n5. Integration test: API endpoints → training → prediction flow\n6. Test early stopping triggers correctly with plateaued loss\n7. Test inference queue integration with mock training jobs\n8. Test Prometheus metrics are recorded correctly\n9. Test model versioning and rollback functionality\n10. Load test: verify queue handles concurrent training requests",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Minimum Data Requirements Validation",
            "description": "Add validation logic to check minimum data requirements before training LSTM models for RHR and HRV prediction.",
            "dependencies": [],
            "details": "Add method `validate_training_data_requirements()` to ModelTrainingService in `ml-service/app/services/model_training.py`. This should check: (1) At least 30 days of health data with RHR/HRV measurements from HealthMetric model, (2) At least 21 days of nutrition data (meals) from Meal model, (3) Sufficient non-null feature coverage (>70%) using FeatureEngineeringService data quality metrics. Raise descriptive ValueError with specific missing requirements if validation fails. Call this method at the start of `train_model()` before `data_prep_service.prepare_training_data()`. Use async database queries consistent with existing SQLAlchemy patterns in the codebase.",
            "status": "pending",
            "testStrategy": "Unit test with mock database returning insufficient data (<30 days health, <21 days nutrition). Test ValueError is raised with descriptive message listing specific shortfalls. Test with sufficient data ensuring training proceeds without error.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Training API Endpoints with Queue Integration",
            "description": "Add FastAPI endpoints for triggering LSTM model training with integration to the existing inference queue pattern.",
            "dependencies": [
              1
            ],
            "details": "Create `ml-service/app/api/training.py` with endpoints:\n\n1. POST `/api/v1/models/train` - Accepts TrainModelRequest schema (from schemas/predictions.py), validates data requirements via subtask 1, submits training to background task, returns 202 Accepted with job_id. Use asyncio.create_task() for long-running training.\n\n2. GET `/api/v1/models/{model_id}` - Returns model metadata.pkl contents including training metrics, architecture, hyperparameters.\n\n3. GET `/api/v1/models/user/{user_id}` - Lists all model directories matching `{user_id}_*` pattern from models_dir, returns list with status and metrics.\n\nStore training status in Redis using existing redis_client pattern with keys like `training:{job_id}` and 1-hour TTL. Register router in main.py following existing API structure.",
            "status": "done",
            "testStrategy": "Integration test POST /api/v1/models/train with synthetic user data - verify 202 response with job_id. Test GET endpoints return correct model info. Test error responses for invalid user_id or missing data. Verify Redis status updates during training.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T10:22:13.219Z"
          },
          {
            "id": 3,
            "title": "Implement Model Versioning and Management System",
            "description": "Add model versioning to track multiple versions per user/metric with rollback capability, following the storage pattern from what_if.py.",
            "dependencies": [
              1,
              2
            ],
            "details": "Enhance ModelTrainingService with versioning methods:\n\n1. `_generate_model_version()` - Semantic versioning (v1.0.0 → v1.0.1) based on existing models for user/metric.\n\n2. `_set_active_model()` - Mark latest trained model as active in metadata.pkl with `is_active: true` flag.\n\n3. `get_model_history(user_id, metric)` - List all model versions with metrics by scanning `models/{user_id}_{metric}_*` directories.\n\n4. `rollback_to_version(user_id, metric, version)` - Set specified version as active, update previous active model.\n\n5. `cleanup_old_models(user_id, metric, keep_count=5)` - Remove oldest versions beyond keep_count, preserving active model.\n\nUpdate model storage path from `{user_id}_{metric}_{timestamp}` to include version: `{user_id}_{metric}_v{major}.{minor}.{patch}_{timestamp}`. Update PredictionService._find_latest_model() to prefer active model.",
            "status": "pending",
            "testStrategy": "Test version generation creates sequential versions. Test active model selection works correctly. Test rollback restores previous version as active without data loss. Test cleanup removes old versions while keeping latest 5 and never removing active model.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Prediction API Endpoints with What-If Integration",
            "description": "Create FastAPI endpoints for health metric predictions integrating with existing PredictionService and WhatIfService.",
            "dependencies": [
              3
            ],
            "details": "Create `ml-service/app/api/predictions_api.py` with endpoints:\n\n1. POST `/api/v1/predict` - Accepts PredictRequest (user_id, metric, target_date), calls PredictionService.predict(), returns PredictResponse with prediction, confidence interval, interpretation.\n\n2. POST `/api/v1/predict/batch` - Accepts BatchPredictRequest with list of metrics, calls predict() for each in parallel using asyncio.gather(), returns combined results.\n\n3. POST `/api/v1/predict/what-if` - Integrates with existing WhatIfService.test_what_if_scenarios() from what_if.py.\n\nAdd proper error handling:\n- 404 when no trained model exists\n- 400 for insufficient input data\n- 503 when circuit breaker is open (from inference queue)\n\nLeverage existing Redis caching in PredictionService (24h TTL). Register router in main.py.",
            "status": "done",
            "testStrategy": "Integration test with pre-trained model verifying prediction returns valid value with confidence interval. Test batch prediction returns all requested metrics. Test what-if endpoint correctly modifies predictions based on scenarios. Test error responses for missing model and insufficient data.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T10:22:13.308Z"
          },
          {
            "id": 5,
            "title": "Add Prometheus Metrics for Training and Integrate with Queue",
            "description": "Extend existing Prometheus metrics pattern from queue/metrics.py to cover model training operations.",
            "dependencies": [
              2,
              4
            ],
            "details": "Create `ml-service/app/core/training_metrics.py` following QueueMetrics pattern:\n\n```python\n@dataclass\nclass TrainingMetrics:\n    prefix: str = 'nutri_ml_training'\n    \n    # Gauges\n    active_training_jobs: Gauge  # Currently running training jobs\n    \n    # Counters\n    training_jobs_total: Counter  # By status: success, error, timeout\n    training_failures: Counter  # By reason\n    \n    # Histograms\n    training_duration_seconds: Histogram  # Training time distribution\n    model_quality_r2: Histogram  # R² score distribution\n    model_quality_mape: Histogram  # MAPE distribution\n    \n    # Info\n    latest_model_info: Info  # Last trained model details\n```\n\nIntegrate with ModelTrainingService.train_model():\n- Record training start/end times\n- Record evaluation metrics (MAE, RMSE, R², MAPE)\n- Track success/failure counts\n\nExpose metrics at existing /metrics endpoint.",
            "status": "pending",
            "testStrategy": "Run test training and verify Prometheus metrics are recorded correctly. Check training_duration histogram captures timing. Verify model_quality histograms track R² and MAPE. Test counter increments on success and failure.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create Comprehensive LSTM Training and Prediction Tests",
            "description": "Implement end-to-end tests for the complete LSTM training pipeline using synthetic data, covering all new functionality.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create `ml-service/tests/test_lstm_training.py` with tests:\n\n1. `test_data_validation_requirements` - Verify validate_training_data_requirements() with insufficient/sufficient data.\n\n2. `test_training_data_preparation` - Verify sliding windows (30-day), normalization, train/val split (80/20) using DataPreparationService.\n\n3. `test_lstm_model_forward_pass` - Verify HealthMetricLSTM output shape (batch, 1) with random input matching LSTMConfig.\n\n4. `test_training_loss_decreases` - Run 10 epochs with synthetic data, verify train_losses[-1] < train_losses[0].\n\n5. `test_model_save_load_roundtrip` - Save model via _save_model_artifacts(), reload via _load_model_artifacts(), verify identical predictions.\n\n6. `test_evaluation_metrics_accuracy` - Verify MAE, RMSE, R², MAPE calculations against known values.\n\n7. `test_early_stopping_triggers` - Verify training stops when validation loss plateaus for patience=10 epochs.\n\n8. `test_model_versioning` - Test version generation, active model setting, rollback.\n\n9. `test_api_train_predict_flow` - Integration test: POST /train → GET /status → POST /predict.\n\nUse pytest fixtures for database session and synthetic data. Mark slow tests with @pytest.mark.slow.",
            "status": "pending",
            "testStrategy": "Run full test suite with `pytest ml-service/tests/test_lstm_training.py -v`. All tests should pass with synthetic data. Verify coverage >80% for model_training.py and prediction.py. Include integration tests for API endpoints.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-26T12:01:58.103Z"
      },
      {
        "id": 7,
        "title": "Create Predictions Visualization Mobile UI",
        "description": "Build mobile screens to display ML predictions (RHR, HRV forecasts) with confidence intervals and historical context, following existing codebase patterns.",
        "status": "pending",
        "dependencies": [
          "6"
        ],
        "priority": "medium",
        "details": "## Overview\nCreate prediction visualization screens that mirror the existing patterns in `app/health/[metricType].tsx` and integrate with the ML service prediction schemas from `ml-service/app/schemas/predictions.py`.\n\n## New Screens to Create\n\n### 1. `app/predictions/index.tsx` - Predictions Dashboard\n- Follow pattern from `app/(tabs)/health.tsx`\n- SafeAreaView with custom header (back button, title, spacer pattern)\n- Prediction cards for RHR, HRV_SDNN (primary metrics)\n- Each card displays:\n  - `predicted_value` with appropriate unit (bpm, ms)\n  - `confidence_score` as percentage badge (0-1 → 0-100%)\n  - Direction indicator using Ionicons `trending-up`/`trending-down`\n  - Comparison text: deviation from `historical_average`\n- Pull-to-refresh using React Native `RefreshControl`\n- TouchableOpacity cards navigating to `/predictions/[metric]`\n- Use `batchPredict` API for initial load with metrics: `['RESTING_HEART_RATE', 'HEART_RATE_VARIABILITY_SDNN']`\n\n### 2. `app/predictions/[metric].tsx` - Detailed Prediction View\n- Follow pattern from `app/health/[metricType].tsx` (lines 330-548)\n- Custom header with metric name from `METRIC_CONFIG`\n- Historical chart (30 days) + prediction point for tomorrow\n- Use `healthMetricsApi.getTimeSeries()` for historical data\n- Use `predictionsApi.predict()` for prediction\n- Confidence interval visualization as shaded region\n- Display cards for:\n  - `interpretation` (from PredictResponse)\n  - `recommendation` (from PredictResponse)\n  - Feature importance section (placeholder)\n\n## TypeScript Types (`lib/types/predictions.ts`)\nMirror ML service schemas from `ml-service/app/schemas/predictions.py`:\n\n```typescript\n// Match PredictionMetric enum (lines 12-19)\nexport type PredictionMetric = \n  | 'RESTING_HEART_RATE'\n  | 'HEART_RATE_VARIABILITY_SDNN'\n  | 'HEART_RATE_VARIABILITY_RMSSD'\n  | 'SLEEP_DURATION'\n  | 'RECOVERY_SCORE';\n\n// Match ModelArchitecture enum (lines 22-27)\nexport type ModelArchitecture = 'lstm' | 'xgboost' | 'linear';\n\n// Match PredictionResult (lines 155-182)\nexport interface PredictionResult {\n  metric: PredictionMetric;\n  target_date: string;\n  predicted_at: string;\n  predicted_value: number;\n  confidence_interval_lower: number;\n  confidence_interval_upper: number;\n  confidence_score: number; // 0-1\n  historical_average: number;\n  deviation_from_average: number;\n  percentile: number; // 0-100\n  model_id: string;\n  model_version: string;\n  architecture: ModelArchitecture;\n}\n\n// Match PredictResponse (lines 185-201)\nexport interface PredictResponse {\n  user_id: string;\n  prediction: PredictionResult;\n  features_used: number;\n  sequence_length: number;\n  data_quality_score: number;\n  interpretation: string;\n  recommendation: string | null;\n  cached: boolean;\n}\n\n// Match BatchPredictResponse (lines 224-242)\nexport interface BatchPredictResponse {\n  user_id: string;\n  target_date: string;\n  predicted_at: string;\n  predictions: Record<string, PredictionResult>;\n  overall_data_quality: number;\n  all_predictions_successful: boolean;\n  failed_metrics: string[];\n}\n\n// Match ModelInfo (lines 250-267)\nexport interface ModelInfo {\n  model_id: string;\n  user_id: string;\n  metric: PredictionMetric;\n  architecture: ModelArchitecture;\n  version: string;\n  trained_at: string;\n  training_metrics: TrainingMetrics;\n  sequence_length: number;\n  num_features: number;\n  model_size_mb: number;\n  is_active: boolean;\n  is_production_ready: boolean;\n}\n\n// Match TrainingMetrics (lines 78-95)\nexport interface TrainingMetrics {\n  train_loss: number;\n  val_loss: number;\n  best_val_loss: number;\n  mae: number;\n  rmse: number;\n  r2_score: number;\n  mape: number;\n  epochs_trained: number;\n  early_stopped: boolean;\n  training_time_seconds: number;\n}\n\n// Match TrainModelResponse (lines 98-126) - for quality_issues\nexport interface TrainModelResponse {\n  user_id: string;\n  metric: PredictionMetric;\n  architecture: ModelArchitecture;\n  model_id: string;\n  model_version: string;\n  trained_at: string;\n  training_metrics: TrainingMetrics;\n  total_samples: number;\n  sequence_length: number;\n  num_features: number;\n  model_path: string;\n  model_size_mb: number;\n  is_production_ready: boolean;\n  quality_issues: string[];\n}\n\nexport interface ListModelsResponse {\n  user_id: string;\n  models: ModelInfo[];\n  total_models: number;\n}\n```\n\n## API Client (`lib/api/predictions.ts`)\nFollow pattern from `lib/api/health-metrics.ts`:\n\n```typescript\nimport api from './client';\nimport {\n  PredictionMetric,\n  PredictResponse,\n  BatchPredictResponse,\n  ModelInfo,\n  ListModelsResponse,\n} from '../types/predictions';\n\nfunction isNotFoundError(error: unknown): boolean {\n  if (error && typeof error === 'object' && 'response' in error) {\n    const response = (error as { response?: { status?: number } }).response;\n    return response?.status === 404;\n  }\n  return false;\n}\n\nexport const predictionsApi = {\n  async predict(\n    metric: PredictionMetric,\n    targetDate: string,\n    modelVersion?: string\n  ): Promise<PredictResponse | null> {\n    try {\n      const response = await api.post<PredictResponse>('/predictions/predict', {\n        metric,\n        target_date: targetDate,\n        model_version: modelVersion,\n      });\n      return response.data;\n    } catch (error) {\n      if (isNotFoundError(error)) return null;\n      throw error;\n    }\n  },\n\n  async batchPredict(\n    metrics: PredictionMetric[],\n    targetDate: string\n  ): Promise<BatchPredictResponse | null> {\n    try {\n      const response = await api.post<BatchPredictResponse>('/predictions/batch-predict', {\n        metrics,\n        target_date: targetDate,\n      });\n      return response.data;\n    } catch (error) {\n      if (isNotFoundError(error)) return null;\n      throw error;\n    }\n  },\n\n  async listModels(): Promise<ListModelsResponse | null> {\n    try {\n      const response = await api.get<ListModelsResponse>('/predictions/models');\n      return response.data;\n    } catch (error) {\n      if (isNotFoundError(error)) return null;\n      throw error;\n    }\n  },\n};\n\nexport default predictionsApi;\n```\n\n## Chart Component (`lib/components/PredictionChart.tsx`)\nWrap react-native-chart-kit LineChart with confidence interval support:\n\n```typescript\nimport { LineChart } from 'react-native-chart-kit';\nimport { View, Animated } from 'react-native';\nimport { colors, borderRadius } from '@/lib/theme/colors';\nimport { TimeSeriesDataPoint } from '@/lib/types/health-metrics';\n\ninterface PredictionChartProps {\n  historicalData: TimeSeriesDataPoint[];\n  predictedValue: number;\n  confidenceIntervalLower: number;\n  confidenceIntervalUpper: number;\n  width: number;\n  height?: number;\n}\n\n// Chart config matching app/health/[metricType].tsx (lines 291-309)\nconst chartConfig = {\n  backgroundColor: colors.background.tertiary,\n  backgroundGradientFrom: colors.background.tertiary,\n  backgroundGradientTo: colors.background.tertiary,\n  decimalPlaces: 0,\n  color: (opacity = 1) => `rgba(139, 92, 246, ${opacity})`, // colors.primary.main\n  labelColor: (opacity = 1) => `rgba(156, 163, 175, ${opacity})`, // colors.text.tertiary\n  propsForDots: {\n    r: '4',\n    strokeWidth: '2',\n    stroke: colors.primary.main,\n  },\n};\n\n// Prediction point uses distinct color (orange)\nconst predictionColor = '#F59E0B'; // colors.status.warning\n```\n\n## State Management Pattern\nFollow `app/health/[metricType].tsx` (lines 47-53, 81-108):\n- useState for: prediction, loading, error, timeSeries\n- useCallback for loadData\n- useEffect to trigger loading\n- Pull-to-refresh via RefreshControl\n\n## Empty States Configuration\n1. **Loading:** ActivityIndicator in loadingContainer (line 385-388)\n2. **No Model Trained:** emptyCard style with:\n   - Ionicons 'analytics-outline' (48px)\n   - Title: 'No prediction model available'\n   - Subtitle: 'We need at least 30 days of data to train a prediction model'\n   - CTA: TouchableOpacity navigating to health tracking\n3. **Model Not Production Ready:** warning state showing `TrainModelResponse.quality_issues[]`\n4. **Prediction Available:** Full UI\n5. **Error:** errorCard style (lines 393-399) with retry button\n\n## Screen Registration in `app/_layout.tsx`\nAdd after line 161:\n```typescript\n<Stack.Screen\n  name=\"predictions/index\"\n  options={{\n    headerShown: false,\n    animation: 'slide_from_right'\n  }}\n/>\n<Stack.Screen\n  name=\"predictions/[metric]\"\n  options={{\n    headerShown: false,\n    animation: 'slide_from_right'\n  }}\n/>\n```\n\n## Theme Integration\nUse from `lib/theme/colors.ts`:\n- colors.background.tertiary for cards\n- colors.primary.main (#8B5CF6) for primary elements\n- colors.status.warning (#F59E0B) for prediction indicator\n- colors.status.success/error for trend colors\n- shadows.sm for card elevation\n- borderRadius.lg for card corners\n- spacing.* for consistent spacing\n- typography.* for text styles",
        "testStrategy": "1. **Component Tests:**\n   - Dashboard renders prediction cards with mock data\n   - Detail view renders chart with historical + prediction\n   - Test navigation between screens\n\n2. **State Tests:**\n   - Loading state shows ActivityIndicator\n   - Error state shows retry button\n   - Empty state (no model) shows CTA\n   - Warning state shows quality_issues\n   - Success state shows full UI\n\n3. **API Integration:**\n   - Mock axios for predict(), batchPredict(), listModels()\n   - Test 404 handling (no model trained)\n   - Test error handling\n\n4. **Chart Tests:**\n   - PredictionChart renders with mock data\n   - Confidence interval bounds display\n   - Prediction point highlighted\n\n5. **Snapshot Tests:**\n   - Dashboard in various states\n   - Detail view with chart",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TypeScript types and API client for predictions",
            "description": "Implement lib/types/predictions.ts mirroring ML service schemas and lib/api/predictions.ts following health-metrics.ts patterns",
            "dependencies": [],
            "details": "**File 1: `lib/types/predictions.ts`**\nCreate TypeScript types matching `ml-service/app/schemas/predictions.py` exactly:\n- PredictionMetric type (5 values matching lines 12-19)\n- ModelArchitecture type (3 values matching lines 22-27)\n- PredictionResult interface (matching lines 155-182)\n- PredictResponse interface (matching lines 185-201)\n- BatchPredictResponse interface (matching lines 224-242)\n- ModelInfo interface (matching lines 250-267)\n- TrainingMetrics interface (matching lines 78-95)\n- TrainModelResponse interface (matching lines 98-126, includes quality_issues[])\n- ListModelsResponse interface (matching lines 270-275)\n\n**File 2: `lib/api/predictions.ts`**\nFollow pattern from `lib/api/health-metrics.ts`:\n- Import shared axios client from `./client`\n- Implement `isNotFoundError` helper (lines 244-250)\n- Export `predictionsApi` object with:\n  - `predict(metric, targetDate, modelVersion?)` → POST /predictions/predict\n  - `batchPredict(metrics[], targetDate)` → POST /predictions/batch-predict\n  - `listModels()` → GET /predictions/models\n- Handle 404 responses returning null (model not trained)\n- Use proper TypeScript types for all parameters and returns",
            "status": "pending",
            "testStrategy": "Unit tests with axios mocked: verify predict() returns PredictResponse, batchPredict() returns BatchPredictResponse, listModels() returns ListModelsResponse. Test 404 returns null. Test error propagation for 500.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build Predictions Dashboard screen at app/predictions/index.tsx",
            "description": "Create the main predictions dashboard showing prediction cards for predictable health metrics with pull-to-refresh",
            "dependencies": [
              1
            ],
            "details": "**Create `app/predictions/index.tsx`** following `app/(tabs)/health.tsx` pattern:\n\n**Structure:**\n- SafeAreaView with testID='predictions-dashboard-screen'\n- Custom header: back button (chevron-back), title 'Predictions', spacer\n- ScrollView with RefreshControl for pull-to-refresh\n- Use `useResponsive()` hook for tablet layouts\n\n**State Management (following lines 47-53 of [metricType].tsx):**\n```typescript\nconst [predictions, setPredictions] = useState<BatchPredictResponse | null>(null);\nconst [models, setModels] = useState<ListModelsResponse | null>(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState<string | null>(null);\nconst [isRefreshing, setIsRefreshing] = useState(false);\n```\n\n**Data Loading:**\n- On mount: call `predictionsApi.listModels()` to check model availability\n- If models exist: call `predictionsApi.batchPredict(['RESTING_HEART_RATE', 'HEART_RATE_VARIABILITY_SDNN'], tomorrow)`\n- Calculate tomorrow's date: `new Date(Date.now() + 86400000).toISOString().split('T')[0]`\n\n**Prediction Card Component:**\n- TouchableOpacity navigating to `/predictions/${metric}`\n- Display: predicted_value with unit (from METRIC_CONFIG), confidence_score as badge (multiply by 100), trending icon based on deviation_from_average, comparison text\n- Use colors.background.tertiary, borderRadius.lg, shadows.sm\n\n**Screen Registration:**\nAdd to `app/_layout.tsx` after line 161 with headerShown: false, animation: 'slide_from_right'",
            "status": "pending",
            "testStrategy": "Component tests: verify cards render with mock BatchPredictResponse, pull-to-refresh triggers API call, tap on card navigates via router.push, loading state shows ActivityIndicator, error state shows retry button.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Detailed Prediction View at app/predictions/[metric].tsx",
            "description": "Build the detailed prediction screen with historical chart, confidence interval, AI interpretation, and recommendations",
            "dependencies": [
              1,
              2
            ],
            "details": "**Create `app/predictions/[metric].tsx`** mirroring `app/health/[metricType].tsx`:\n\n**Route Parameter:**\n```typescript\nconst { metric } = useLocalSearchParams<{ metric: string }>();\nconst validMetric = metric as PredictionMetric;\nconst config = METRIC_CONFIG[validMetric as HealthMetricType];\n```\n\n**State Management:**\n```typescript\nconst [timeSeries, setTimeSeries] = useState<TimeSeriesDataPoint[]>([]);\nconst [prediction, setPrediction] = useState<PredictResponse | null>(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState<string | null>(null);\n```\n\n**Data Loading:**\n- Call `healthMetricsApi.getTimeSeries(validMetric, startDate, endDate)` for 30 days historical\n- Call `predictionsApi.predict(validMetric, tomorrowDate)` for prediction\n- Use Promise.all for parallel loading\n\n**UI Sections:**\n1. **Custom Header:** Back button, metric displayName, spacer\n2. **Chart Card:** PredictionChart component (subtask 4) showing historical + prediction\n3. **Stats Cards:** Row of 3 cards - Predicted Value, Confidence (%), Historical Average\n4. **Confidence Interval Card:** Shows lower and upper bounds\n5. **Interpretation Card:** Display `prediction.interpretation` text\n6. **Recommendation Card:** Display `prediction.recommendation` if not null\n7. **Feature Importance Card:** Placeholder showing 'Key factors: Recent sleep patterns, Nutrition quality, Activity levels'\n\n**Styling:** Match [metricType].tsx styles - chartCard, statsContainer, statCard, trendCard patterns",
            "status": "pending",
            "testStrategy": "Test chart renders with mock historical + prediction data. Verify confidence interval displays lower/upper bounds. Test interpretation and recommendation cards render. Verify navigation works with different metric parameters.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement PredictionChart component with confidence interval visualization",
            "description": "Create reusable chart component that displays historical values with predicted value and confidence interval shading",
            "dependencies": [
              1
            ],
            "details": "**Create `lib/components/PredictionChart.tsx`:**\n\n**Props Interface:**\n```typescript\ninterface PredictionChartProps {\n  historicalData: TimeSeriesDataPoint[];\n  predictedValue: number;\n  confidenceIntervalLower: number;\n  confidenceIntervalUpper: number;\n  metricType: HealthMetricType;\n  width: number;\n  height?: number;\n}\n```\n\n**Chart Configuration (from [metricType].tsx lines 291-309):**\n```typescript\nconst chartConfig = {\n  backgroundColor: colors.background.tertiary,\n  backgroundGradientFrom: colors.background.tertiary,\n  backgroundGradientTo: colors.background.tertiary,\n  decimalPlaces: getDecimalPlaces(metricType),\n  color: (opacity = 1) => `rgba(139, 92, 246, ${opacity})`,\n  labelColor: (opacity = 1) => `rgba(156, 163, 175, ${opacity})`,\n};\n```\n\n**Data Preparation:**\n- Sample historical data evenly (max 6 points like [metricType].tsx line 224)\n- Append prediction point with distinct styling\n- Format labels based on date range\n\n**Prediction Point Styling:**\n- Use colors.status.warning (#F59E0B) for prediction dot\n- Add pulse animation using React Native Animated API\n- Larger dot size (r='6') vs historical (r='4')\n\n**Confidence Interval Visualization:**\n- Option A: Use decorator prop to draw shaded region between bounds\n- Option B: Overlay two semi-transparent lines for upper/lower bounds\n- Color: `rgba(245, 158, 11, 0.2)` (warning with 20% opacity)\n\n**Export:** Default export and named export for tree shaking",
            "status": "pending",
            "testStrategy": "Component tests: verify historical line renders with correct points, prediction point appears with distinct color, confidence bounds are visually distinct. Test with edge cases: single data point, empty historical data, wide confidence intervals.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement comprehensive state handling for predictions screens",
            "description": "Add loading, error, no-model-trained, and model-quality-warning states following existing patterns",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "**Enhance both `app/predictions/index.tsx` and `app/predictions/[metric].tsx` with state handling:**\n\n**1. Loading State (matching [metricType].tsx lines 385-388):**\n```typescript\n{isLoading && (\n  <View style={styles.loadingContainer}>\n    <ActivityIndicator size=\"large\" color={colors.primary.main} />\n  </View>\n)}\n```\n\n**2. Error State (matching [metricType].tsx lines 393-399):**\n```typescript\n{error && !isLoading && (\n  <View style={styles.errorCard}>\n    <Ionicons name=\"alert-circle-outline\" size={24} color={colors.status.error} />\n    <Text style={styles.errorText}>{error}</Text>\n    <TouchableOpacity onPress={loadData} style={styles.retryButton}>\n      <Text style={styles.retryText}>Retry</Text>\n    </TouchableOpacity>\n  </View>\n)}\n```\n\n**3. No Model Trained State:**\n```typescript\n{!isLoading && !error && (!models || models.total_models === 0) && (\n  <View style={styles.emptyCard}>\n    <Ionicons name=\"analytics-outline\" size={48} color={colors.text.disabled} />\n    <Text style={styles.emptyTitle}>No prediction model available</Text>\n    <Text style={styles.emptySubtitle}>\n      We need at least 30 days of health data to train a prediction model.\n      Keep tracking your health metrics!\n    </Text>\n    <TouchableOpacity \n      style={styles.ctaButton} \n      onPress={() => router.push('/(tabs)/health')}\n    >\n      <Text style={styles.ctaButtonText}>Track Health Data</Text>\n    </TouchableOpacity>\n  </View>\n)}\n```\n\n**4. Model Not Production Ready State:**\nCheck `ModelInfo.is_production_ready` from listModels() response:\n```typescript\n{model && !model.is_production_ready && (\n  <View style={styles.warningCard}>\n    <Ionicons name=\"warning-outline\" size={24} color={colors.status.warning} />\n    <Text style={styles.warningTitle}>Model Quality Notice</Text>\n    <Text style={styles.warningText}>Predictions may be less accurate:</Text>\n    {qualityIssues.map((issue, i) => (\n      <Text key={i} style={styles.warningItem}>• {issue}</Text>\n    ))}\n  </View>\n)}\n```\n\n**5. Add styles for new states:**\nCopy errorCard, emptyCard patterns from [metricType].tsx (lines 666-713) and add warningCard, ctaButton styles.\n\n**Logic Flow:**\n- First call `listModels()` to check availability\n- If no models → show No Model Trained state\n- If models exist but none production ready → show warning + predictions\n- If production-ready model → show normal predictions",
            "status": "pending",
            "testStrategy": "Test each state renders correctly: mock listModels() returning empty array triggers no-model state, mock model with is_production_ready=false shows warning, mock 500 error shows error state with retry, mock successful response shows predictions.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement ML Insights Engine and Recommendations",
        "description": "Build the insights generation system that analyzes correlations, predictions, and anomalies to generate personalized nutrition recommendations. Leverages existing CorrelationEngineService (ml-service/app/services/correlation_engine.py) and PredictionService (ml-service/app/services/prediction.py) to produce actionable insights stored in the MLInsight model (server/prisma/schema.prisma:277-312).",
        "status": "pending",
        "dependencies": [
          "6"
        ],
        "priority": "medium",
        "details": "## Existing Infrastructure to Leverage\n\n### CorrelationEngineService (ml-service/app/services/correlation_engine.py)\n- `analyze_correlations(request: CorrelationRequest)` → CorrelationResponse\n- `analyze_lag(request: LagAnalysisRequest)` → LagAnalysisResponse\n- Supports Pearson, Spearman, Kendall, Granger correlations\n- Uses FeatureEngineeringService for 50+ features\n- Returns CorrelationResult with: feature_name, correlation, p_value, is_significant, strength (weak/moderate/strong), direction (positive/negative)\n\n### Correlation Schemas (ml-service/app/schemas/correlations.py)\n- CorrelationMethod enum: PEARSON, SPEARMAN, KENDALL, GRANGER\n- HealthMetricTarget enum: RHR, HRV_SDNN, HRV_RMSSD, SLEEP_DURATION, SLEEP_QUALITY, RECOVERY_SCORE, VO2_MAX, RESPIRATORY_RATE\n- CorrelationRequest: user_id, target_metric, methods, lookback_days, min_correlation (default 0.3), top_k\n- CorrelationResult: feature_name, correlation, p_value, is_significant, strength, direction, explained_variance\n\n### PredictionService (ml-service/app/services/prediction.py)\n- `predict(request: PredictRequest)` → PredictResponse\n- Returns: predicted_value, confidence_interval_lower/upper, interpretation, recommendation\n- Includes: historical_average, deviation_from_average, percentile\n- Already has `_generate_interpretation()` and `_generate_recommendation()` methods\n- Uses `_get_historical_stats()` for 30-day statistics\n\n### Database Models\n- **MLInsight** (server/prisma/schema.prisma:277-312): userId, insightType, priority, title, description, recommendation, correlation, confidence, dataPoints, metadata (JSON), viewed, viewedAt, dismissed, dismissedAt, helpful, createdAt, expiresAt\n- **MLInsightType** enum: CORRELATION, PREDICTION, ANOMALY, RECOMMENDATION, GOAL_PROGRESS, PATTERN_DETECTED\n- **InsightPriority** enum: LOW, MEDIUM, HIGH, CRITICAL\n- **User** model (ml-service/app/models/user.py): goal_calories, goal_protein, goal_carbs, goal_fat for GOAL_PROGRESS insights\n\n### Feature Engineering (ml-service/app/services/feature_engineering.py)\n- 50+ features across categories: nutrition, activity, health, temporal, interaction\n- `engineer_features(user_id, target_date, categories)` → EngineerFeaturesResponse\n\n## Implementation Plan\n\n### 1. Create InsightsEngine Service (ml-service/app/services/insights_engine.py)\n```python\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.services.correlation_engine import CorrelationEngineService\nfrom app.services.prediction import PredictionService\nfrom app.schemas.correlations import CorrelationRequest, HealthMetricTarget, CorrelationResult\nfrom app.schemas.predictions import PredictionMetric, PredictRequest\nfrom scipy import stats\nimport numpy as np\nfrom datetime import date, datetime, timedelta\nfrom typing import List, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass AnomalyResult:\n    metric_type: str\n    value: float\n    z_score: float\n    mean_30d: float\n    std_30d: float\n    direction: str  # 'high' or 'low'\n    severity: str   # 'warning' (|z|>2) or 'critical' (|z|>3)\n\nclass InsightsEngine:\n    def __init__(self, db: AsyncSession):\n        self.db = db\n        self.correlation_service = CorrelationEngineService(db)\n        self.prediction_service = PredictionService(db)\n    \n    async def generate_insights(self, user_id: str) -> List[MLInsight]:\n        \"\"\"Main entry point - generates all insight types.\"\"\"\n        insights = []\n        \n        # Get correlations using existing CorrelationEngineService\n        correlations = await self._get_significant_correlations(user_id)\n        insights.extend(self._correlation_insights(correlations))\n        \n        # Get predictions using existing PredictionService\n        predictions = await self._get_recent_predictions(user_id)\n        insights.extend(self._prediction_insights(predictions))\n        \n        # Detect anomalies via z-score\n        anomalies = await self._detect_anomalies(user_id)\n        insights.extend(self._anomaly_insights(anomalies))\n        \n        # Check goal progress (uses User.goal_calories, goal_protein, etc.)\n        insights.extend(await self._goal_progress_insights(user_id))\n        \n        return self._prioritize_and_limit(insights, max_insights=5)\n```\n\n### 2. Correlation-Based Insights\nLeverage CorrelationEngineService directly:\n```python\nasync def _get_significant_correlations(self, user_id: str) -> List[CorrelationResult]:\n    metrics = [HealthMetricTarget.RHR, HealthMetricTarget.HRV_SDNN, \n               HealthMetricTarget.HRV_RMSSD, HealthMetricTarget.SLEEP_DURATION]\n    all_correlations = []\n    \n    for metric in metrics:\n        request = CorrelationRequest(\n            user_id=user_id,\n            target_metric=metric,\n            lookback_days=30,\n            min_correlation=0.5,  # Only strong correlations\n            top_k=5\n        )\n        response = await self.correlation_service.analyze_correlations(request)\n        all_correlations.extend(response.correlations)\n    \n    return [c for c in all_correlations if abs(c.correlation) >= 0.5 and c.is_significant]\n```\n\n### 3. Anomaly Detection (Z-Score)\nQuery HealthMetric model (ml-service/app/models/health_metric.py) for 30-day data:\n```python\nasync def _detect_anomalies(self, user_id: str) -> List[AnomalyResult]:\n    from app.models.health_metric import HealthMetric\n    from sqlalchemy import select, and_\n    \n    metrics_to_check = ['SLEEP_DURATION', 'RESTING_HEART_RATE', 'ACTIVE_CALORIES']\n    anomalies = []\n    \n    for metric_type in metrics_to_check:\n        # Fetch last 30 days\n        result = await self.db.execute(\n            select(HealthMetric).where(\n                and_(\n                    HealthMetric.user_id == user_id,\n                    HealthMetric.metric_type == metric_type,\n                    HealthMetric.recorded_at >= datetime.now() - timedelta(days=30)\n                )\n            )\n        )\n        metrics = result.scalars().all()\n        \n        if len(metrics) < 7:\n            continue\n            \n        values = [m.value for m in metrics]\n        mean, std = np.mean(values), np.std(values)\n        today_value = values[-1] if values else 0\n        z_score = (today_value - mean) / std if std > 0 else 0\n        \n        if abs(z_score) > 2.0:\n            anomalies.append(AnomalyResult(\n                metric_type=metric_type,\n                value=today_value,\n                z_score=z_score,\n                mean_30d=mean,\n                std_30d=std,\n                direction='high' if z_score > 0 else 'low',\n                severity='critical' if abs(z_score) > 3 else 'warning'\n            ))\n    return anomalies\n```\n\n### 4. Priority Calculation\n- CRITICAL: Anomalies with |z| > 3, predictions significantly different from average (>20%)\n- HIGH: Strong correlations (|r| > 0.7), anomalies with |z| > 2\n- MEDIUM: Moderate correlations (|r| > 0.5), goal progress updates\n- LOW: Informational patterns, weak correlations\n\n### 5. Insight Expiration\n- ANOMALY: 1 day (time-sensitive)\n- PREDICTION: 2 days (until predicted date passes)\n- CORRELATION: 7 days (stable relationships)\n- GOAL_PROGRESS: 7 days (weekly updates)\n\n### 6. API Registration\nRegister insights router in ml-service/app/api/__init__.py:\n```python\nfrom .insights import router as insights_router\napi_router.include_router(insights_router, prefix=\"/insights\", tags=[\"insights\"])\n```",
        "testStrategy": "1. **Unit tests for InsightsEngine** (`ml-service/tests/test_insights_engine.py`):\n   - Mock CorrelationEngineService.analyze_correlations() and verify filtering\n   - Mock PredictionService._get_historical_stats() for anomaly detection\n   - Test insight prioritization logic (CRITICAL > HIGH > MEDIUM > LOW)\n   - Test NLG templates generate grammatically correct text\n\n2. **Anomaly detection tests**:\n   - Test z-score calculation with known values (mean=60, std=5, value=75 → z=3.0)\n   - Test threshold detection (|z| > 2 = warning, |z| > 3 = critical)\n   - Test edge cases: insufficient data (<7 days), constant values (std=0)\n\n3. **Integration tests** (`ml-service/tests/test_insights_api.py`):\n   - Test GET /api/insights/{user_id} returns filtered insights\n   - Test POST /api/insights/generate creates and stores insights\n   - Test PUT endpoints update viewed/dismissed/helpful fields\n   - Test 404 for non-existent insight IDs\n\n4. **Goal progress tests**:\n   - Test calculation against User.goal_calories, goal_protein, etc.\n   - Test weekly aggregation (7-day rolling sum vs. 7x daily goal)\n\n5. **Database tests**:\n   - Verify MLInsight records created with correct enum values\n   - Test insight expiration dates are set per type\n   - Test duplicate prevention logic",
        "subtasks": [
          {
            "id": 1,
            "title": "Create InsightsEngine Service with Correlation-Based Insight Generation",
            "description": "Implement the core InsightsEngine class in ml-service/app/services/insights_engine.py that generates correlation-based insights by leveraging the existing CorrelationEngineService from ml-service/app/services/correlation_engine.py.",
            "dependencies": [],
            "details": "Create insights_engine.py with InsightsEngine class that:\n\n1. Initialize with AsyncSession and instantiate existing services:\n   - CorrelationEngineService from app.services.correlation_engine\n   - PredictionService from app.services.prediction\n\n2. Implement `async def generate_insights(user_id: str) -> List[MLInsight]` as main entry point\n\n3. Implement `_get_significant_correlations(user_id)` method:\n   - Use CorrelationRequest from app.schemas.correlations\n   - Target metrics: HealthMetricTarget.RHR, HRV_SDNN, HRV_RMSSD, SLEEP_DURATION\n   - Call self.correlation_service.analyze_correlations(request)\n   - Filter by correlation strength (|r| >= 0.5) and significance (is_significant=True)\n\n4. Implement `_correlation_insights(correlations: List[CorrelationResult])` method:\n   - Create MLInsight objects from CorrelationResult\n   - Set insightType = MLInsightType.CORRELATION\n   - Priority: HIGH if |r| > 0.7, MEDIUM if |r| > 0.5\n   - Generate title: 'Your {feature} correlates with {direction} {metric}'\n   - Store correlation coefficient in the correlation field\n   - Set confidence from p_value (lower p_value = higher confidence)\n\n5. Follow existing service patterns from correlation_engine.py for database session handling, error handling, and async patterns",
            "status": "pending",
            "testStrategy": "Unit tests for InsightsEngine with mocked CorrelationEngineService. Test that CorrelationRequest is constructed correctly with min_correlation=0.5. Test filtering by is_significant=True. Test MLInsight creation with proper insight_type, priority, and correlation values. Integration test with sample user data verifying end-to-end flow.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Z-Score Anomaly Detection for Health and Nutrition Data",
            "description": "Add anomaly detection methods to InsightsEngine using z-score analysis to identify unusual values in sleep duration, resting heart rate, and calorie intake by querying HealthMetric model (ml-service/app/models/health_metric.py).",
            "dependencies": [
              1
            ],
            "details": "Extend InsightsEngine with anomaly detection:\n\n1. Create AnomalyResult dataclass:\n   ```python\n   @dataclass\n   class AnomalyResult:\n       metric_type: str\n       value: float\n       z_score: float\n       mean_30d: float\n       std_30d: float\n       direction: str  # 'high' or 'low'\n       severity: str   # 'warning' (|z|>2) or 'critical' (|z|>3)\n   ```\n\n2. Implement `async def _detect_anomalies(user_id: str) -> List[AnomalyResult]`:\n   - Import HealthMetric from app.models.health_metric\n   - Query last 30 days using sqlalchemy select() pattern from correlation_engine.py\n   - Metrics to check: SLEEP_DURATION, RESTING_HEART_RATE, ACTIVE_CALORIES\n   - Calculate mean and std using numpy (already used in correlation_engine.py)\n   - Compute z-score: (today_value - mean) / std\n   - Flag as anomaly if |z| > 2.0\n   - Set severity='critical' if |z| > 3, else 'warning'\n   - Skip metrics with less than 7 data points\n\n3. Implement `_anomaly_insights(anomalies: List[AnomalyResult]) -> List[MLInsight]`:\n   - Set insightType = MLInsightType.ANOMALY\n   - Priority: CRITICAL if severity='critical', HIGH if severity='warning'\n   - Generate titles like 'Your sleep duration was unusually {direction}'\n   - Include z_score in metadata JSON field\n   - Set expiresAt = now + 1 day (anomalies are time-sensitive)\n\n4. Handle edge cases:\n   - Return empty list if std=0 (constant values)\n   - Require minimum 7 days of data",
            "status": "pending",
            "testStrategy": "Unit tests for z-score calculation with known values (mean=60, std=5, value=75 should give z=3.0). Test anomaly thresholds: |z|>2 triggers warning, |z|>3 triggers critical. Test edge cases: insufficient data (<7 days), constant values (std=0), empty data. Mock database queries and verify correct AnomalyResult creation.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build Natural Language Recommendation Generator with Template System",
            "description": "Create a recommendation generation system that transforms correlation data, anomalies, predictions, and goal progress into human-readable, actionable recommendations using template patterns from PredictionService._generate_interpretation().",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement NLG for insights following patterns from prediction.py:447-531:\n\n1. Create `ml-service/app/services/nlg_recommendations.py` with NLGRecommendationGenerator class\n\n2. Study existing patterns in PredictionService:\n   - `_generate_interpretation()` at line 447-480\n   - `_generate_recommendation()` at line 482-520\n   - `_get_metric_display_name()` at line 522-531\n\n3. Implement template-based generation for each insight type:\n   - **CORRELATION templates**:\n     - Positive: 'Increasing your {feature} may improve your {metric}'\n     - Negative: 'Reducing your {feature} could help lower your {metric}'\n     - Use correlation.strength ('weak', 'moderate', 'strong') from CorrelationResult\n   \n   - **ANOMALY templates**:\n     - Low sleep: 'Your sleep was {hours:.1f}h, well below your {mean_30d:.1f}h average. Consider an earlier bedtime.'\n     - High RHR: 'Your resting heart rate is elevated at {value:.0f} bpm. This could indicate stress or inadequate recovery.'\n   \n   - **PREDICTION templates**:\n     - Above average: 'Tomorrow's {metric} is predicted to be higher than your average ({value:.1f} vs {avg:.1f})'\n     - Reuse PredictionService._generate_recommendation() logic\n   \n   - **GOAL_PROGRESS templates**:\n     - 'You're {percent:.0f}% toward your {goal_type} goal this week ({current:.0f} of {target:.0f})'\n   \n   - **PATTERN_DETECTED templates**:\n     - 'You tend to {pattern_description} on {temporal_pattern}'\n\n4. Integrate with InsightsEngine:\n   - Call NLGRecommendationGenerator from _correlation_insights(), _anomaly_insights()\n   - Populate MLInsight.title, description, and recommendation fields\n\n5. Use metric display names from PredictionService._get_metric_display_name() pattern for consistency",
            "status": "pending",
            "testStrategy": "Unit tests for each template type with sample data. Verify proper variable substitution (no {variable} placeholders in output). Test edge cases: missing data fields, extreme values (z=5), different metric types. Test that generated text is grammatically correct. Snapshot tests to ensure recommendation consistency across updates.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create FastAPI Endpoints for Insights CRUD Operations",
            "description": "Implement REST API endpoints in ml-service/app/api/insights.py for listing, generating, viewing, dismissing, and providing feedback on ML insights, following patterns from existing API routes in ml-service/app/api/correlations.py.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create ml-service/app/api/insights.py following patterns from correlations.py and predictions.py:\n\n1. Register router in ml-service/app/api/__init__.py (line 16-33):\n   ```python\n   from .insights import router as insights_router\n   api_router.include_router(insights_router, prefix=\"/insights\", tags=[\"insights\"])\n   ```\n\n2. Create Pydantic schemas in ml-service/app/schemas/insights.py:\n   - MLInsightTypeEnum (mirror Prisma MLInsightType)\n   - InsightPriorityEnum (mirror Prisma InsightPriority)\n   - InsightResponse (all MLInsight fields)\n   - InsightListResponse (list with pagination)\n   - GenerateInsightsRequest (user_id, force_regenerate: bool = False)\n   - GenerateInsightsResponse (insights list, count)\n   - InsightFeedbackRequest (helpful: bool, comment: Optional[str])\n\n3. Implement endpoints:\n   ```python\n   router = APIRouter()\n   \n   @router.get(\"/{user_id}\")\n   async def get_insights(user_id: str, db: AsyncSession = Depends(get_db)):\n       # Query active insights (not dismissed, not expired)\n       # Order by priority DESC, createdAt DESC\n       # Limit to 10\n   \n   @router.post(\"/generate\")\n   async def generate_insights(request: GenerateInsightsRequest, db: AsyncSession = Depends(get_db)):\n       engine = InsightsEngine(db)\n       insights = await engine.generate_insights(request.user_id)\n       # Store in database (subtask 5)\n       return {\"insights\": insights, \"count\": len(insights)}\n   \n   @router.put(\"/{insight_id}/viewed\")\n   async def mark_viewed(insight_id: str, db: AsyncSession = Depends(get_db)):\n       # Update viewed=True, viewedAt=datetime.now(timezone.utc)\n   \n   @router.put(\"/{insight_id}/dismissed\")\n   async def dismiss_insight(insight_id: str, db: AsyncSession = Depends(get_db)):\n       # Update dismissed=True, dismissedAt=datetime.now(timezone.utc)\n   \n   @router.put(\"/{insight_id}/feedback\")\n   async def submit_feedback(insight_id: str, request: InsightFeedbackRequest, db: AsyncSession = Depends(get_db)):\n       # Update helpful field, store feedback in metadata JSON\n   ```\n\n4. Follow dependency injection patterns from correlations.py for get_db",
            "status": "pending",
            "testStrategy": "API endpoint tests using FastAPI TestClient. Test GET returns filtered insights (excludes dismissed/expired). Test POST generates and returns new insights. Test PUT endpoints update correct fields with correct timestamps. Test authorization (user can only access own insights). Test validation errors for invalid input. Test 404 for non-existent insight IDs.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Database Persistence with SQLAlchemy MLInsight Model",
            "description": "Create SQLAlchemy model for MLInsight in ml-service/app/models/ mirroring Prisma schema (server/prisma/schema.prisma:277-312) and implement InsightRepository for CRUD operations.",
            "dependencies": [
              1,
              4
            ],
            "details": "Create database integration following patterns from existing models (ml-service/app/models/health_metric.py):\n\n1. Create ml-service/app/models/ml_insight.py:\n   ```python\n   from sqlalchemy import Column, String, Float, Integer, Boolean, DateTime, JSON, Enum as SQLEnum\n   from sqlalchemy.orm import relationship\n   from app.database import Base\n   import enum\n   \n   class MLInsightTypeEnum(str, enum.Enum):\n       CORRELATION = \"CORRELATION\"\n       PREDICTION = \"PREDICTION\"\n       ANOMALY = \"ANOMALY\"\n       RECOMMENDATION = \"RECOMMENDATION\"\n       GOAL_PROGRESS = \"GOAL_PROGRESS\"\n       PATTERN_DETECTED = \"PATTERN_DETECTED\"\n   \n   class InsightPriorityEnum(str, enum.Enum):\n       LOW = \"LOW\"\n       MEDIUM = \"MEDIUM\"\n       HIGH = \"HIGH\"\n       CRITICAL = \"CRITICAL\"\n   \n   class MLInsight(Base):\n       __tablename__ = \"MLInsight\"\n       __table_args__ = (\n           Index(\"MLInsight_userId_createdAt_idx\", \"userId\", \"createdAt\"),\n           Index(\"MLInsight_userId_insightType_priority_idx\", \"userId\", \"insightType\", \"priority\"),\n       )\n       \n       id = Column(String, primary_key=True)\n       user_id = Column(\"userId\", String, ForeignKey(\"User.id\", ondelete=\"CASCADE\"), nullable=False)\n       insight_type = Column(\"insightType\", SQLEnum(MLInsightTypeEnum), nullable=False)\n       priority = Column(SQLEnum(InsightPriorityEnum), nullable=False)\n       title = Column(String, nullable=False)\n       description = Column(String, nullable=False)\n       recommendation = Column(String, nullable=False)\n       correlation = Column(Float, nullable=True)\n       confidence = Column(Float, nullable=False)\n       data_points = Column(\"dataPoints\", Integer, nullable=False)\n       metadata = Column(JSON, nullable=True)\n       viewed = Column(Boolean, default=False)\n       viewed_at = Column(\"viewedAt\", DateTime, nullable=True)\n       dismissed = Column(Boolean, default=False)\n       dismissed_at = Column(\"dismissedAt\", DateTime, nullable=True)\n       helpful = Column(Boolean, nullable=True)\n       created_at = Column(\"createdAt\", DateTime, server_default=func.now())\n       expires_at = Column(\"expiresAt\", DateTime, nullable=True)\n       \n       user = relationship(\"User\", back_populates=\"ml_insights\")\n   ```\n\n2. Update ml-service/app/models/__init__.py to export MLInsight\n\n3. Create InsightRepository class in insights_engine.py:\n   - `async def create_insight(insight_data: dict) -> MLInsight`\n   - `async def get_user_insights(user_id, include_dismissed=False, include_expired=False) -> List[MLInsight]`\n   - `async def update_insight(insight_id, updates: dict) -> MLInsight`\n   - Use cuid() for ID generation (same as Prisma default)\n\n4. Update InsightsEngine.generate_insights() to:\n   - Persist insights with correct expiresAt based on type:\n     - ANOMALY: now + 1 day\n     - PREDICTION: now + 2 days\n     - CORRELATION: now + 7 days\n     - GOAL_PROGRESS: now + 7 days\n   - Check for duplicate recent insights before creating\n\n5. Implement `_prioritize_and_limit(insights, max_insights=5)`:\n   - Sort by priority (CRITICAL > HIGH > MEDIUM > LOW)\n   - Secondary sort by confidence DESC\n   - Return top max_insights",
            "status": "pending",
            "testStrategy": "Integration tests with test database. Test CRUD operations on MLInsight model. Test filtering by dismissed/expired flags in get_user_insights(). Test duplicate prevention logic. Test insight expiration dates are set correctly per type. Test prioritization sorting returns correct order. Verify data integrity between ML service and Node.js backend using same PostgreSQL database.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9,
        "title": "Build Insights Feed Mobile UI",
        "description": "Create mobile screens to display ML-generated insights, recommendations, and allow user feedback. Depends on Task 8 (ML Insights Engine) for backend API at /api/insights endpoints.",
        "status": "pending",
        "dependencies": [
          "8"
        ],
        "priority": "medium",
        "details": "## Overview\nBuild the Insights Feed UI following existing codebase patterns from `app/(tabs)/health.tsx`, `lib/api/health-metrics.ts`, and `lib/components/SwipeableMealCard.tsx`.\n\n## 1. TypeScript Types (lib/types/insights.ts)\n```typescript\nexport type MLInsightType = \n  | 'CORRELATION' \n  | 'PREDICTION' \n  | 'ANOMALY' \n  | 'RECOMMENDATION' \n  | 'GOAL_PROGRESS' \n  | 'PATTERN_DETECTED';\n\nexport type InsightPriority = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n\nexport interface Insight {\n  id: string;\n  userId: string;\n  insightType: MLInsightType;\n  priority: InsightPriority;\n  title: string;\n  description: string;\n  recommendation: string;\n  correlation?: number;\n  confidence: number;\n  dataPoints: number;\n  metadata?: Record<string, unknown>;\n  viewed: boolean;\n  viewedAt?: string;\n  dismissed: boolean;\n  dismissedAt?: string;\n  helpful?: boolean;\n  createdAt: string;\n  expiresAt?: string;\n}\n\n// Icon and color configurations\nexport const INSIGHT_TYPE_CONFIG: Record<MLInsightType, { icon: string; color: string }> = {\n  CORRELATION: { icon: 'git-compare-outline', color: colors.primary.main },\n  PREDICTION: { icon: 'trending-up', color: colors.status.info },\n  ANOMALY: { icon: 'warning-outline', color: colors.status.warning },\n  RECOMMENDATION: { icon: 'bulb-outline', color: colors.status.success },\n  GOAL_PROGRESS: { icon: 'flag-outline', color: colors.primary.main },\n  PATTERN_DETECTED: { icon: 'calendar-outline', color: colors.text.secondary },\n};\n\nexport const PRIORITY_COLORS: Record<InsightPriority, string> = {\n  CRITICAL: colors.status.error,\n  HIGH: colors.status.warning,\n  MEDIUM: colors.primary.main,\n  LOW: colors.text.tertiary,\n};\n```\n\n## 2. API Client (lib/api/insights.ts)\nFollow pattern from `lib/api/health-metrics.ts`:\n- Use shared axios client from `lib/api/client.ts`\n- Include `isNotFoundError` helper for 404 handling\n- Export typed API methods\n\n## 3. InsightCard Component (lib/components/insights/InsightCard.tsx)\nFollow `SwipeableMealCard.tsx` patterns:\n- Use `Swipeable` from react-native-gesture-handler\n- `renderRightActions` with dismiss action (X icon, 'Dismiss' label, colors.status.error background)\n- Long-press handler using `showAlert` from `lib/utils/alert.ts`\n- Card styling: `backgroundColor: colors.background.tertiary`, `borderRadius: borderRadius.md`, `borderWidth: 1`, `borderColor: colors.border.secondary`\n- Type-specific rendering based on `insightType`\n- Priority color band using `LinearGradient` from expo-linear-gradient\n- `accessibilityLabel` and `accessibilityRole` props\n\n## 4. Insights Feed Screen (app/insights/index.tsx)\nFollow `app/(tabs)/health.tsx` patterns:\n- `SafeAreaView` with custom header\n- `FlatList` with `RefreshControl` for pull-to-refresh (tintColor: colors.primary.main)\n- `useFocusEffect` to reload on screen focus\n- Sort by priority (CRITICAL > HIGH > MEDIUM > LOW) then by createdAt (newest first)\n- Filter out dismissed insights\n- Loading state: centered `ActivityIndicator`\n- Empty state: icon + 'Keep logging meals to unlock insights' message + styled button\n- Error state with retry button\n- Register in `app/_layout.tsx` with `headerShown: false`, `animation: 'slide_from_right'`\n\n## 5. Insight Detail Screen (app/insights/[id].tsx)\nFollow `app/health/[metricType].tsx` patterns:\n- `useLocalSearchParams` to get insight id\n- Custom header with back button (chevron-back icon)\n- ScrollView with full description, recommendation section\n- Chart using `LineChart` from react-native-chart-kit if correlation/prediction type\n- Feedback section: 'Was this helpful?' with thumbs up/down buttons\n- Call `markViewed` on mount\n- Use `useResponsive` hook for tablet layouts\n\n## 6. Tab Bar Integration (app/(tabs)/_layout.tsx)\nAdd Insights tab with badge:\n- Use `IconSymbol` with 'lightbulb.fill' icon\n- Create `useInsightsBadge` hook that polls `insightsApi.getUnreadCount()` every 60 seconds\n- Use `useFocusEffect` to refresh count on focus\n- `tabBarBadge`: count > 0 ? count : undefined\n- `tabBarBadgeStyle`: `{ backgroundColor: colors.status.error }`\n\n## Theme References (lib/theme/colors.ts)\n- Primary: colors.primary.main (#8B5CF6)\n- Success: colors.status.success (#10B981)\n- Warning: colors.status.warning (#F59E0B)\n- Error: colors.status.error (#EF4444)\n- Info: colors.status.info (#3B82F6)\n- Card background: colors.background.tertiary (#1E2330)\n- Border: colors.border.secondary (#1F2937)\n- Gradients: gradients.primary (['#8B5CF6', '#EC4899'])",
        "testStrategy": "1. Component tests for InsightCard with react-native-testing-library for each insight type\n2. Test swipe-to-dismiss gesture triggers dismiss API call and callback\n3. Test long-press action sheet appears with correct options\n4. Test feedback button interactions update UI state and call API\n5. Test loading, error, and empty states render correctly\n6. Test priority-based sorting logic (CRITICAL > HIGH > MEDIUM > LOW, then by date)\n7. Test badge updates when unread count changes and hides when count is 0\n8. Test markViewed called on detail screen mount\n9. Accessibility tests for labels and roles\n10. Snapshot tests for visual consistency",
        "subtasks": [
          {
            "id": 1,
            "title": "Create insights TypeScript types and API client in lib/types/insights.ts and lib/api/insights.ts",
            "description": "Create TypeScript interfaces for Insight types matching ML service schemas, and build the API client module following health-metrics.ts patterns",
            "dependencies": [],
            "details": "**Create lib/types/insights.ts:**\nDefine TypeScript types mirroring ML service schemas from Task 8:\n- `MLInsightType` union: 'CORRELATION' | 'PREDICTION' | 'ANOMALY' | 'RECOMMENDATION' | 'GOAL_PROGRESS' | 'PATTERN_DETECTED'\n- `InsightPriority` union: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'\n- `Insight` interface with all fields (id, userId, insightType, priority, title, description, recommendation, correlation?, confidence, dataPoints, metadata?, viewed, viewedAt?, dismissed, dismissedAt?, helpful?, createdAt, expiresAt?)\n- `INSIGHT_TYPE_CONFIG` record mapping each type to { icon: string, color: string } using Ionicons names and colors from lib/theme/colors.ts\n- `PRIORITY_COLORS` record mapping priority to color from colors.status\n\n**Create lib/api/insights.ts:**\nFollow pattern from lib/api/health-metrics.ts (lines 1-250):\n- Import api from './client' and Insight type\n- Add isNotFoundError helper (same pattern as health-metrics.ts lines 244-250)\n- Implement insightsApi object with async methods:\n  - `getAll(limit?: number)`: GET /insights with optional limit param, return Insight[]\n  - `getById(id: string)`: GET /insights/:id, return Insight | null (use isNotFoundError)\n  - `markViewed(id: string)`: PUT /insights/:id/viewed\n  - `dismiss(id: string)`: PUT /insights/:id/dismissed\n  - `submitFeedback(id: string, helpful: boolean)`: PUT /insights/:id/feedback\n  - `getUnreadCount()`: GET /insights/unread-count, return number from response.data.count\n- Export types and api object",
            "status": "pending",
            "testStrategy": "Unit tests for API client methods using mock axios (jest.mock('./client')). Test getById returns null on 404. Test error propagation for non-404 errors. Verify type exports are accessible from other modules.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create InsightCard component with swipe-to-dismiss and type-specific rendering",
            "description": "Build reusable InsightCard component following SwipeableMealCard.tsx patterns with Swipeable gesture handling and type-specific visual rendering",
            "dependencies": [
              1
            ],
            "details": "**Create lib/components/insights/InsightCard.tsx:**\nFollow SwipeableMealCard.tsx (lines 1-213) patterns:\n\n**Imports:**\n- React, useRef from 'react'\n- View, Text, StyleSheet, TouchableOpacity, Animated from 'react-native'\n- Swipeable from 'react-native-gesture-handler'\n- Ionicons from '@expo/vector-icons'\n- LinearGradient from 'expo-linear-gradient'\n- { Insight, INSIGHT_TYPE_CONFIG, PRIORITY_COLORS } from '@/lib/types/insights'\n- { colors, spacing, borderRadius, typography, gradients } from '@/lib/theme/colors'\n- { showAlert } from '@/lib/utils/alert'\n- { formatDistanceToNow } from 'date-fns' (or manual relative time)\n\n**Props interface:**\n```typescript\ninterface InsightCardProps {\n  insight: Insight;\n  onPress: () => void;\n  onDismiss: () => void;\n}\n```\n\n**Component structure:**\n- useRef<Swipeable>(null) for swipeableRef\n- handleDismiss: close swipeable, call onDismiss\n- handleLongPress: showAlert with options ['View Details', 'Dismiss', 'Cancel']\n- renderRightActions: single dismiss action with X icon, 'Dismiss' label, colors.status.error background (similar to deleteAction in SwipeableMealCard.tsx lines 89-98)\n\n**Card content:**\n- Left: Icon container (36x36, borderRadius: 18, backgroundColor: colors.special.highlight) with type-specific icon from INSIGHT_TYPE_CONFIG\n- Priority band: 4px height LinearGradient or solid color at top of card using PRIORITY_COLORS[insight.priority]\n- Title: truncated to 2 lines\n- Description: truncated to 2 lines\n- Type-specific badge:\n  - CORRELATION: Show '|r| = {Math.abs(correlation).toFixed(2)}' badge\n  - PREDICTION: Show trending-up/trending-down icon based on metadata\n  - ANOMALY: Show alert-circle icon in amber background\n  - RECOMMENDATION: Show lightbulb icon\n- Bottom row: relative timestamp using formatDistanceToNow or manual calculation\n\n**Styling (follow mealCard pattern from SwipeableMealCard.tsx lines 140-150):**\n- backgroundColor: colors.background.tertiary\n- borderRadius: borderRadius.md\n- padding: spacing.md\n- borderWidth: 1\n- borderColor: colors.border.secondary\n- accessibilityLabel with insight title and type\n- accessibilityRole='button'",
            "status": "pending",
            "testStrategy": "Component tests with @testing-library/react-native. Test each insight type renders correct icon and badge. Test swipe gesture triggers onDismiss. Test long-press shows action sheet. Test accessibility labels. Snapshot tests for each insight type variant.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build insights feed screen at app/insights/index.tsx with FlatList and pull-to-refresh",
            "description": "Create the main insights feed screen following app/(tabs)/health.tsx patterns with sorted insight cards, pull-to-refresh, empty state, and navigation",
            "dependencies": [
              1,
              2
            ],
            "details": "**Create app/insights/index.tsx:**\nFollow app/(tabs)/health.tsx (lines 1-675) patterns:\n\n**Imports:**\n- useState, useCallback from 'react'\n- View, Text, StyleSheet, FlatList, TouchableOpacity, RefreshControl, ActivityIndicator from 'react-native'\n- useRouter from 'expo-router'\n- useFocusEffect from '@react-navigation/native'\n- SafeAreaView from 'react-native-safe-area-context'\n- Ionicons from '@expo/vector-icons'\n- LinearGradient from 'expo-linear-gradient'\n- { insightsApi } from '@/lib/api/insights'\n- { Insight, InsightPriority, PRIORITY_COLORS } from '@/lib/types/insights'\n- { InsightCard } from '@/lib/components/insights/InsightCard'\n- { colors, gradients, spacing, borderRadius, typography, shadows } from '@/lib/theme/colors'\n- { useResponsive } from '@/hooks/useResponsive'\n\n**State:**\n- insights: Insight[]\n- isLoading: boolean\n- refreshing: boolean\n- error: string | null\n\n**Data loading:**\n- loadInsights callback: fetch via insightsApi.getAll(), filter out dismissed, sort by priority then createdAt\n- Sorting: PRIORITY_ORDER = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3 }, sort by priority order asc, then createdAt desc\n- useFocusEffect to reload on screen focus (same pattern as health.tsx lines 112-118)\n- onRefresh callback with setRefreshing\n\n**Header:**\n- Custom header (not using Stack header): back button (chevron-back), 'Insights' title, date subtitle\n- Follow health.tsx header style (lines 443-458)\n\n**FlatList:**\n- data={insights}\n- keyExtractor={(item) => item.id}\n- renderItem with InsightCard, onPress navigates to /insights/[id], onDismiss calls handleDismiss\n- RefreshControl with tintColor={colors.primary.main}\n- contentContainerStyle with padding\n\n**Empty state (when insights.length === 0 && !isLoading):**\n- Follow emptyContainer pattern (health.tsx lines 524-557)\n- Icon: 'bulb-outline' or 'sparkles-outline' size 64\n- Title: 'No insights yet'\n- Subtitle: 'Keep logging meals to unlock insights'\n- CTA button: 'Go to Dashboard' navigating to /(tabs)\n\n**Loading state:**\n- Centered ActivityIndicator (follow loadingContainer pattern health.tsx lines 180-188)\n\n**Error state:**\n- Follow errorContainer pattern (health.tsx lines 261-269)\n- Retry button calling loadInsights\n\n**handleDismiss function:**\n- Call insightsApi.dismiss(id)\n- Remove from local state optimistically\n- Handle error with Alert\n\n**Register in app/_layout.tsx:**\nAdd Stack.Screen for 'insights/index' with headerShown: false, animation: 'slide_from_right'",
            "status": "pending",
            "testStrategy": "Test loading state shows ActivityIndicator. Test empty state renders when no insights. Test error state with retry button. Test pull-to-refresh triggers reload. Test insights sorted correctly (CRITICAL first, then by date). Test navigation to detail view on card press. Test dismiss removes insight from list.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create insight detail view at app/insights/[id].tsx with full content, feedback, and charts",
            "description": "Build detailed insight view screen following app/health/[metricType].tsx patterns with full description, recommendation CTA, supporting charts, and feedback interaction",
            "dependencies": [
              1,
              2
            ],
            "details": "**Create app/insights/[id].tsx:**\nFollow app/health/[metricType].tsx (lines 1-889) patterns:\n\n**Imports:**\n- useState, useEffect, useCallback from 'react'\n- View, Text, StyleSheet, ScrollView, TouchableOpacity, ActivityIndicator from 'react-native'\n- useLocalSearchParams, useRouter from 'expo-router'\n- SafeAreaView from 'react-native-safe-area-context'\n- Ionicons from '@expo/vector-icons'\n- LineChart from 'react-native-chart-kit'\n- { insightsApi } from '@/lib/api/insights'\n- { Insight, INSIGHT_TYPE_CONFIG, PRIORITY_COLORS } from '@/lib/types/insights'\n- { colors, gradients, spacing, borderRadius, typography, shadows } from '@/lib/theme/colors'\n- { useResponsive } from '@/hooks/useResponsive'\n- { showAlert } from '@/lib/utils/alert'\n- { getErrorMessage } from '@/lib/utils/errorHandling'\n\n**State:**\n- insight: Insight | null\n- isLoading: boolean\n- error: string | null\n- feedbackSubmitted: boolean\n- feedbackValue: boolean | null\n\n**Data loading:**\n- Get id from useLocalSearchParams\n- loadInsight callback: fetch via insightsApi.getById(id)\n- Call insightsApi.markViewed(id) on successful load (fire and forget)\n- useEffect to load on mount\n\n**Header:**\n- Follow health/[metricType].tsx header pattern (lines 332-341)\n- Back button (chevron-back), centered title (insight type icon + insight.title truncated), empty spacer\n\n**Content sections:**\n\n1. **Priority badge** at top: colored badge showing priority level\n\n2. **Full description**: Text with insight.description, lineHeight: 20\n\n3. **Recommendation card** (if insight.recommendation exists):\n- Card with lightbulb icon and 'Recommendation' title\n- Full recommendation text\n- CTA button if actionable (e.g., 'Log a meal' → navigates to /add-meal)\n\n4. **Supporting chart** (for CORRELATION/PREDICTION types):\n- Follow chartCard pattern (health/[metricType].tsx lines 715-727)\n- LineChart showing related metric data from insight.metadata if available\n- chartConfig matching existing theme (lines 291-309)\n\n5. **Confidence & data points card**:\n- Show confidence percentage and dataPoints count\n- Similar to statsContainer pattern (lines 730-762)\n\n6. **Feedback section:**\n- Title: 'Was this helpful?'\n- Two buttons: thumbs-up (success color) and thumbs-down (error color)\n- On press: call insightsApi.submitFeedback(id, helpful), update local state\n- Show confirmation state after submission ('Thanks for your feedback!')\n- Disabled state if already submitted\n\n**Loading/Error states:**\n- Follow same patterns as health/[metricType].tsx (lines 384-411)\n\n**Register in app/_layout.tsx:**\nAdd Stack.Screen for 'insights/[id]' with headerShown: false, animation: 'slide_from_right'",
            "status": "pending",
            "testStrategy": "Test insight data loads and displays all sections correctly. Test markViewed called on mount. Test feedback buttons call submitFeedback API with correct helpful value. Test feedback UI updates to confirmation state after submission. Test buttons disabled after feedback. Test error handling shows alert. Test chart renders for CORRELATION/PREDICTION types.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Insights tab to tab bar with unread badge and create useInsightsBadge hook",
            "description": "Integrate Insights tab into app/(tabs)/_layout.tsx with dynamic badge showing unread count using a polling hook",
            "dependencies": [
              1,
              3
            ],
            "details": "**Create app/(tabs)/insights.tsx placeholder:**\nSimple re-export or copy of app/insights/index.tsx content (or use a redirect component)\n\n**Update app/(tabs)/_layout.tsx:**\nFollow existing tab configuration (lines 1-94):\n\n**Add useInsightsBadge hook:**\n```typescript\nimport { useState, useCallback, useEffect } from 'react';\nimport { useFocusEffect } from '@react-navigation/native';\nimport { insightsApi } from '@/lib/api/insights';\n\nfunction useInsightsBadge() {\n  const [unreadCount, setUnreadCount] = useState(0);\n\n  const fetchCount = useCallback(async () => {\n    try {\n      const count = await insightsApi.getUnreadCount();\n      setUnreadCount(count);\n    } catch (error) {\n      // Silently fail - badge not critical\n      console.warn('Failed to fetch insight count:', error);\n    }\n  }, []);\n\n  // Fetch on focus\n  useFocusEffect(\n    useCallback(() => {\n      fetchCount();\n    }, [fetchCount])\n  );\n\n  // Poll every 60 seconds\n  useEffect(() => {\n    fetchCount(); // Initial fetch\n    const interval = setInterval(fetchCount, 60000);\n    return () => clearInterval(interval);\n  }, [fetchCount]);\n\n  return unreadCount > 0 ? unreadCount : undefined;\n}\n```\n\n**Add Insights tab (insert between Health and Profile tabs):**\n```typescript\nconst insightsBadge = useInsightsBadge();\n\n// In Tabs return:\n<Tabs.Screen\n  name=\"insights\"\n  options={{\n    title: 'Insights',\n    tabBarIcon: ({ color }) => <IconSymbol size={iconSize} name=\"lightbulb.fill\" color={color} />,\n    tabBarBadge: insightsBadge,\n    tabBarBadgeStyle: { \n      backgroundColor: colors.status.error,\n      fontSize: 10,\n      minWidth: 18,\n      height: 18,\n      borderRadius: 9,\n    },\n    tabBarTestID: 'tab-insights',\n  }}\n/>\n```\n\n**Create app/(tabs)/insights.tsx:**\nCopy content from app/insights/index.tsx or create a simple wrapper that imports and re-exports the InsightsFeed component.\n\n**Update navigation:**\nEnsure InsightCard onPress in insights/index.tsx uses router.push(`/insights/${insight.id}`) which will work with the insights/[id].tsx dynamic route.",
            "status": "pending",
            "testStrategy": "Test badge appears when unreadCount > 0. Test badge hidden when unreadCount is 0. Test badge updates after polling interval. Test badge updates on tab focus. Test tab navigation works to insights screen. Test IconSymbol renders lightbulb icon. Integration test: dismiss insight reduces badge count.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement AR Portion Size Measurement",
        "description": "Add AR capability to measure food portion dimensions and improve nutrition estimation accuracy.",
        "details": "1. Install AR dependencies:\n   - expo-three (already installed - three.js is in dependencies)\n   - expo-gl (already installed)\n   - @react-three/fiber for React Native\n\n2. Create AR measurement component in `lib/components/ARPortionMeasure.tsx`:\n   - Initialize AR session with plane detection\n   - Render measurement guides on detected surfaces\n   - Allow user to place measurement points\n   - Calculate bounding box dimensions (width, height, depth)\n   - Return dimensions in centimeters\n\n3. Update food scanning flow (`app/scan-food.tsx`):\n   - Add 'Measure with AR' button after capturing photo\n   - Launch AR measurement overlay\n   - Pass dimensions to food analysis API\n   - Update `mockMeasurements` with real AR data\n\n4. AR measurement flow:\n   1. User captures food photo\n   2. User taps 'Measure Portion'\n   3. AR view opens with plane detection\n   4. User taps to place corner points (4 points for bounding box)\n   5. App calculates volume and converts to portion weight\n   6. Dimensions sent to /api/food/analyze\n\n5. Dimension to weight conversion (in food_analysis_service.py):\n   - Already implemented in `_estimate_portion_from_dimensions()`\n   - Uses food density estimates\n   - Returns estimated weight in grams\n\n6. Calibration feature:\n   - Include reference object option (credit card, hand)\n   - Use known dimensions to calibrate scale\n   - Improve accuracy for subsequent measurements\n\n7. Fallback handling:\n   - If AR not supported (older devices), show manual size picker\n   - Options: Small, Medium, Large with example photos",
        "testStrategy": "1. Unit tests for dimension calculation\n2. Test AR component mounting/unmounting\n3. Test plane detection callbacks\n4. Integration test with mock AR data\n5. Test fallback to manual size picker\n6. Manual testing on physical device with AR support\n7. Test calibration accuracy with known objects",
        "priority": "low",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install AR Dependencies and Configure Native Modules",
            "description": "Add required AR dependencies for React Native/Expo including @react-three/fiber, react-three-fiber, and configure native AR capabilities for iOS (ARKit) and Android (ARCore).",
            "dependencies": [],
            "details": "1. Install @react-three/fiber and react-three-fiber packages\n2. Configure expo plugins for AR in app.json (expo-camera already configured)\n3. Set up iOS ARKit permissions in Info.plist (NSCameraUsageDescription already exists)\n4. Configure Android ARCore requirements in AndroidManifest.xml\n5. Verify expo-gl and three.js integration\n6. Create basic AR session test to verify setup\n7. Document AR capability requirements for devices (iOS 11+, ARCore-compatible Android)",
            "status": "done",
            "testStrategy": "1. Test package installation with npm/yarn\n2. Verify expo-gl renders basic 3D scene\n3. Test AR session initialization on iOS simulator (limited) and physical device\n4. Verify ARKit permissions prompt\n5. Test Android ARCore availability detection",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T19:10:26.758Z"
          },
          {
            "id": 2,
            "title": "Create Interactive AR Measurement Component",
            "description": "Build the core ARPortionMeasure component that allows users to tap 4 corner points to create a bounding box and measure food portion dimensions in real-world coordinates.",
            "dependencies": [
              1
            ],
            "details": "1. Create lib/components/ARPortionMeasure.tsx component\n2. Initialize AR session with plane detection enabled\n3. Implement tap-to-place point placement (4 corners for bounding box)\n4. Convert screen coordinates to world coordinates using AR raycasting\n5. Calculate real-world dimensions (width, height, depth) from placed points\n6. Display visual guides showing detected plane surface\n7. Render bounding box overlay with dimension labels\n8. Add point placement indicators and connection lines\n9. Implement reset/undo functionality for point placement\n10. Return ARMeasurement type with confidence scoring based on plane detection quality\n11. Handle edge cases: insufficient plane detection, invalid point placement",
            "status": "done",
            "testStrategy": "1. Unit tests for coordinate conversion calculations\n2. Component tests for point placement state management\n3. Test bounding box dimension calculations with known distances\n4. Test plane detection callbacks and state updates\n5. Integration test with mock AR session data\n6. Manual testing on physical device with various surfaces\n7. Test reset/undo functionality",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T19:16:24.790Z"
          },
          {
            "id": 3,
            "title": "Build AR Measurement Modal/Overlay Screen",
            "description": "Create the modal screen (app/ar-measure-portion.tsx) that launches the AR measurement experience with user instructions and controls.",
            "dependencies": [
              2
            ],
            "details": "1. Create app/ar-measure-portion.tsx as a modal screen\n2. Integrate ARPortionMeasure component into modal\n3. Design instruction UI:\n   - Step-by-step guide for users (detect plane, place 4 corners)\n   - Visual indicators for current step\n   - Progress indicator during plane detection\n4. Add control buttons:\n   - Confirm measurement (validates 4 points placed)\n   - Cancel and return to scan screen\n   - Reset measurement (clear all points)\n5. Display real-time measurement quality indicator\n6. Show current dimensions as user places points\n7. Handle AR session lifecycle (start on mount, cleanup on unmount)\n8. Add error states: no plane detected, AR not supported\n9. Implement navigation: return measured dimensions to caller",
            "status": "done",
            "testStrategy": "1. Component mounting/unmounting tests\n2. Test navigation with expo-router params\n3. Test confirm button validation (requires 4 points)\n4. Test cancel navigation back to scan screen\n5. Test reset functionality clears all state\n6. Integration test: full flow from scan to measurement to confirmation",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T19:22:51.508Z"
          },
          {
            "id": 4,
            "title": "Integrate AR Measurement into Food Scanning Flow",
            "description": "Update scan-food.tsx to include 'Measure with AR' button after photo capture, launch the AR measurement modal, and pass captured dimensions to the food analysis API.",
            "dependencies": [
              3
            ],
            "details": "1. Update scan-food.tsx after photo capture (line 114 area)\n2. Add 'Measure with AR' button alongside 'Analyze Food' button\n3. Implement AR measurement flow:\n   - Launch ar-measure-portion modal\n   - Receive ARMeasurement result from modal\n   - Store measurements in component state\n4. Update foodAnalysisApi.analyzeFood() call to include measurements\n5. Replace mockMeasurements with real AR data\n6. Display measurement quality indicator in UI (high/medium/low badge)\n7. Show captured dimensions in preview (width x height x depth)\n8. Allow re-measurement before final analysis\n9. Handle AR not available gracefully (hide button, show alternative)\n10. Update UI flow: Photo → Measure (optional) → Analyze → Results",
            "status": "done",
            "testStrategy": "1. Test button visibility after photo capture\n2. Test modal launch with expo-router\n3. Test receiving ARMeasurement data from modal\n4. Test API call includes measurements in request\n5. Test UI updates with measurement quality indicator\n6. Integration test: full scan flow with AR measurement\n7. Test fallback when AR not available",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Reference Object Calibration Feature",
            "description": "Build calibration wizard allowing users to use a credit card or other reference object to improve AR measurement accuracy.",
            "dependencies": [
              2
            ],
            "details": "1. Create lib/components/ARCalibration.tsx component\n2. Implement credit card calibration mode:\n   - Standard dimensions: 85.60mm × 53.98mm\n   - AR measurement of credit card\n   - Calculate calibration factor: measured/actual\n3. Build calibration wizard UI:\n   - Introduction screen explaining calibration\n   - Place credit card on surface instructions\n   - Measure card with AR (4 corner points)\n   - Validation: check if dimensions are reasonable (within 20% of standard)\n   - Success/failure feedback\n4. Store calibration factor in AsyncStorage/SecureStore\n5. Apply calibration to subsequent measurements (multiply by factor)\n6. Add calibration status indicator in AR measurement screen\n7. Optional: Allow re-calibration from settings\n8. Optional: Support other reference objects (smartphone, hand span)\n9. Create lib/utils/calibration.ts for storage and retrieval",
            "status": "done",
            "testStrategy": "1. Test calibration factor calculation\n2. Test storage and retrieval of calibration data\n3. Test validation of measured card dimensions\n4. Test applying calibration to measurements\n5. Component tests for calibration wizard\n6. Integration test: calibrate then measure food\n7. Test calibration persistence across app restarts",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create Fallback Manual Size Picker for Non-AR Devices",
            "description": "Build a manual size selection UI for devices without AR/LiDAR support, providing Small/Medium/Large presets with visual references.",
            "dependencies": [],
            "details": "1. Create lib/components/ManualSizePicker.tsx component\n2. Implement size selector options:\n   - Small (e.g., 5cm × 5cm × 5cm → ~87g assuming 0.7 density)\n   - Medium (e.g., 10cm × 10cm × 10cm → ~700g)\n   - Large (e.g., 15cm × 15cm × 15cm → ~2.3kg)\n   - Custom (slider input for each dimension)\n3. Add visual reference images for each size:\n   - Small: Size of a golf ball\n   - Medium: Size of a baseball\n   - Large: Size of a grapefruit\n4. Implement custom slider:\n   - Width slider (1-30cm)\n   - Height slider (1-30cm)\n   - Depth slider (1-30cm)\n   - Real-time volume calculation display\n5. Convert selected size to ARMeasurement type:\n   - Set confidence: 'low' (manual estimate)\n   - Set planeDetected: false\n   - Set distance, width, height, depth\n6. Integrate into scan-food.tsx as fallback when AR unavailable\n7. Show manual picker when device lacks AR support or user declines AR permissions",
            "status": "done",
            "testStrategy": "1. Component tests for size selection state\n2. Test dimension calculations for presets\n3. Test slider value updates and bounds\n4. Test conversion to ARMeasurement format\n5. Test integration with scan flow\n6. Visual regression tests for UI\n7. Test device AR capability detection",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T18:02:37.997Z"
          },
          {
            "id": 7,
            "title": "Add Dimension-to-Weight Conversion Utilities",
            "description": "Create client-side utilities for volume calculation, food density lookup, and weight estimation to complement the ML service's backend estimation.",
            "dependencies": [],
            "details": "1. Create lib/utils/portion-estimation.ts utility file\n2. Implement volume calculation:\n   - volumeFromDimensions(width, height, depth): cm³\n   - applyShapeFactor(volume, shapeFactor): adjusted cm³\n3. Create food density lookup table:\n   - Common foods with g/cm³ density values\n   - Categorized by food type (fruits, vegetables, proteins, grains)\n   - Default density for unknown foods\n4. Implement weight estimation:\n   - estimateWeight(volume, foodType): grams\n   - Confidence score based on food type match\n   - Apply min/max bounds (1g - 5000g)\n5. Add unit conversion helpers:\n   - cmToInches(cm), inchesToCm(inches)\n   - gramsToOz(grams), ozToGrams(oz)\n   - volumeCm3ToMl(cm3), mlToVolumeCm3(ml)\n6. Create TypeScript interfaces for density data\n7. Export utility functions for use in components",
            "status": "done",
            "testStrategy": "1. Unit tests for volume calculations with known dimensions\n2. Test shape factor application\n3. Test density lookup for various food types\n4. Test weight estimation accuracy\n5. Test unit conversions (bidirectional)\n6. Test bounds enforcement (min/max weight)\n7. Test confidence scoring logic",
            "updatedAt": "2025-12-05T17:51:26.304Z",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Write Comprehensive Tests for AR Measurement System",
            "description": "Create unit, component, and integration tests covering the entire AR measurement feature including edge cases and device compatibility.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "1. Unit tests for dimension calculations:\n   - Test bounding box calculation from 4 points\n   - Test coordinate conversion (screen to world)\n   - Test volume and weight calculations\n   - Test calibration factor application\n2. Component tests for ARPortionMeasure:\n   - Test point placement state management\n   - Test plane detection callbacks\n   - Test measurement completion validation\n   - Test reset functionality\n3. Component tests for ar-measure-portion modal:\n   - Test modal lifecycle (mount, unmount)\n   - Test navigation with params\n   - Test instruction UI state transitions\n4. Integration tests for measurement flow:\n   - Test full flow: scan → measure → analyze\n   - Test with calibration applied\n   - Test fallback to manual picker\n   - Test error handling (no plane, invalid points)\n5. Mock tests for devices without AR:\n   - Mock AR availability check\n   - Test manual picker display\n   - Test manual measurements passed to API\n6. Test calibration accuracy:\n   - Test with known reference object dimensions\n   - Test calibration persistence\n   - Test validation logic\n7. Add test fixtures:\n   - Mock ARMeasurement data\n   - Mock AR session responses\n   - Mock plane detection results\n8. Create test documentation in README or docs/testing.md",
            "status": "done",
            "testStrategy": "1. Run full test suite with jest\n2. Verify 80%+ code coverage for AR modules\n3. Test on iOS simulator (limited AR)\n4. Test on physical iOS device with ARKit\n5. Test on Android device with ARCore\n6. Test on older devices without AR support\n7. Regression testing after changes",
            "parentId": "undefined",
            "updatedAt": "2025-12-05T19:45:52.543Z"
          }
        ],
        "updatedAt": "2025-12-05T19:45:57.388Z"
      },
      {
        "id": 11,
        "title": "Generate OpenAPI Documentation and Polish Production Readiness",
        "description": "Add comprehensive API documentation, perform security audit, and optimize performance for production deployment.",
        "details": "1. Generate OpenAPI/Swagger documentation:\n   - Backend (Express): Add swagger-jsdoc and swagger-ui-express\n   - ML Service (FastAPI): Already has built-in docs at /docs\n   - Document all endpoints with request/response schemas\n   - Add authentication requirements\n   - Include example requests and responses\n\n2. Express API documentation setup:\n```javascript\nimport swaggerJsdoc from 'swagger-jsdoc';\nimport swaggerUi from 'swagger-ui-express';\n\nconst options = {\n  definition: {\n    openapi: '3.0.0',\n    info: { title: 'Nutri API', version: '1.0.0' },\n    servers: [{ url: '/api' }],\n    components: {\n      securitySchemes: {\n        bearerAuth: { type: 'http', scheme: 'bearer' }\n      }\n    }\n  },\n  apis: ['./src/routes/*.ts'],\n};\n\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerJsdoc(options)));\n```\n\n3. Performance optimization:\n   - Add database query logging to identify slow queries\n   - Implement connection pooling for PostgreSQL\n   - Add Redis caching for frequently accessed data (user profile, daily summary)\n   - Compress API responses with compression middleware\n   - Optimize Prisma queries with select/include\n\n4. Security audit checklist:\n   - Review all authentication flows\n   - Verify rate limiting is effective\n   - Check for SQL injection (Prisma handles this)\n   - Verify XSS prevention in sanitize middleware\n   - Review CORS configuration\n   - Ensure sensitive data not logged\n   - Check JWT secret rotation capability\n\n5. Production configuration:\n   - Environment variable validation on startup\n   - Health check endpoints for load balancers\n   - Graceful shutdown handling\n   - Error tracking integration (Sentry ready)\n   - Logging configuration (structured JSON logs)\n\n6. Mobile app optimization:\n   - Review bundle size\n   - Implement proper loading states\n   - Add offline detection and handling\n   - Optimize image handling\n\n7. Create deployment documentation:\n   - Docker setup for backend and ML service\n   - Environment variables reference\n   - Database migration guide\n   - Monitoring recommendations",
        "testStrategy": "1. Validate OpenAPI spec with swagger-cli validate\n2. Load testing with k6 or artillery (100 concurrent users)\n3. Security scan with npm audit and OWASP ZAP\n4. Test rate limiting triggers correctly\n5. Test graceful shutdown\n6. Verify logging output format\n7. Test health check endpoints\n8. Performance benchmark for critical endpoints",
        "priority": "low",
        "dependencies": [
          "2",
          "3",
          "4",
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Responsive UI Design for iPhone and iPad Devices",
        "description": "Comprehensive responsive design implementation covering all iPhone sizes (2020+) and iPads with both screen orientations. Lock iPhones to portrait mode while supporting iPad landscape/portrait. Test and optimize all 17 app screens across device categories.",
        "details": "## Technical Implementation Details\n\n### Breakpoint System (in logical pixels)\n```typescript\nconst breakpoints = {\n  // iPhones\n  iPhoneSE: { width: 375, height: 667 },      // iPhone SE 3rd gen\n  iPhoneMini: { width: 375, height: 812 },    // iPhone 12/13 Mini\n  iPhoneMedium: { width: 390, height: 844 },  // iPhone 12/13/14\n  iPhonePro: { width: 393, height: 852 },     // iPhone 14/15/16 Pro\n  iPhoneMax: { width: 430, height: 932 },     // iPhone Pro Max/Plus\n  \n  // iPads\n  iPadMini: { width: 744, height: 1133 },     // iPad Mini\n  iPad: { width: 820, height: 1180 },         // iPad/iPad Air 11\"\n  iPadPro11: { width: 834, height: 1194 },    // iPad Pro 11\"\n  iPadAir13: { width: 1032, height: 1376 },   // iPad Air 13\"\n  iPadPro13: { width: 1024, height: 1366 },   // iPad Pro 13\"\n};\n\nconst deviceCategories = {\n  small: ['iPhoneSE', 'iPhoneMini'],\n  medium: ['iPhoneMedium', 'iPhonePro'],\n  large: ['iPhoneMax'],\n  tablet: ['iPadMini', 'iPad', 'iPadPro11', 'iPadAir13', 'iPadPro13'],\n};\n```\n\n### Responsive Hook Example\n```typescript\n// lib/hooks/useResponsive.ts\nimport { useWindowDimensions, Platform } from 'react-native';\n\nexport function useResponsive() {\n  const { width, height } = useWindowDimensions();\n  \n  const isTablet = width >= 744;\n  const isLandscape = width > height;\n  const deviceCategory = getDeviceCategory(width);\n  \n  const scale = (size: number) => {\n    const baseWidth = 390; // iPhone 14 as baseline\n    return (width / baseWidth) * size;\n  };\n  \n  return { width, height, isTablet, isLandscape, deviceCategory, scale };\n}\n```\n\n### Orientation Lock (app.json)\n```json\n{\n  \"expo\": {\n    \"orientation\": \"portrait\",\n    \"ios\": {\n      \"supportsTablet\": true,\n      \"requireFullScreen\": false,\n      \"userInterfaceStyle\": \"automatic\"\n    }\n  }\n}\n```\n\n### iPad-specific orientation unlock (runtime)\n```typescript\n// In root _layout.tsx\nimport * as ScreenOrientation from 'expo-screen-orientation';\n\nuseEffect(() => {\n  async function configureOrientation() {\n    if (Platform.OS === 'ios' && Platform.isPad) {\n      await ScreenOrientation.unlockAsync();\n    } else {\n      await ScreenOrientation.lockAsync(\n        ScreenOrientation.OrientationLock.PORTRAIT_UP\n      );\n    }\n  }\n  configureOrientation();\n}, []);\n```\n\n### Simulator Testing Checklist\nEach screen must be tested on these simulators:\n- [ ] iPhone SE (3rd generation) - iOS 17+\n- [ ] iPhone 13 Mini - iOS 17+\n- [ ] iPhone 14 - iOS 17+\n- [ ] iPhone 15 Pro - iOS 17+\n- [ ] iPhone 15 Pro Max - iOS 17+\n- [ ] iPad Mini (6th generation) - Portrait\n- [ ] iPad Mini (6th generation) - Landscape\n- [ ] iPad Pro 11-inch - Portrait\n- [ ] iPad Pro 11-inch - Landscape\n- [ ] iPad Pro 13-inch - Portrait\n- [ ] iPad Pro 13-inch - Landscape\n\n### Safe Area Considerations\n- Use SafeAreaView consistently\n- Handle Dynamic Island on iPhone 14 Pro+\n- Handle home indicator on all Face ID devices\n- Handle notch on older Face ID devices\n- Handle status bar on iPhone SE\n\n### Testing Commands\n```bash\n# List available simulators\nxcrun simctl list devices available\n\n# Boot specific simulator\nxcrun simctl boot \"iPhone SE (3rd generation)\"\nxcrun simctl boot \"iPhone 15 Pro Max\"\nxcrun simctl boot \"iPad Pro 13-inch (M4)\"\n\n# Run app on specific simulator\nnpx expo run:ios --device \"iPhone SE (3rd generation)\"\nnpx expo run:ios --device \"iPad Pro 13-inch (M4)\"\n```",
        "testStrategy": "## Testing Strategy\n\n### Unit Tests\n- Test useResponsive hook returns correct device categories\n- Test scale functions produce expected values\n- Test breakpoint detection logic\n\n### Visual Regression Testing\n- Screenshot each screen on each device category\n- Compare layouts visually\n- Verify no text truncation or overflow\n- Verify touch targets are accessible (44pt minimum)\n\n### Manual Testing Checklist per Screen\n\n#### For each of the 17 screens, verify:\n1. **Layout Integrity**\n   - No horizontal scrolling when not intended\n   - Content fits within safe areas\n   - Proper padding/margins on all edges\n\n2. **Typography**\n   - All text is readable\n   - No text truncation (unless intentional with ellipsis)\n   - Font sizes appropriate for device\n\n3. **Interactive Elements**\n   - Buttons are tappable (44pt minimum)\n   - Form fields are usable\n   - Scrolling works smoothly\n\n4. **Orientation (iPad only)**\n   - Smooth rotation transition\n   - Layout adapts correctly\n   - No content loss during rotation\n\n### Device Matrix\n| Screen | SE | Mini | Medium | Pro Max | iPad Mini P | iPad Mini L | iPad Pro P | iPad Pro L |\n|--------|:--:|:----:|:------:|:-------:|:-----------:|:-----------:|:----------:|:----------:|\n| welcome | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| signin | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| signup | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| forgot-password | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| reset-password | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| home (tabs/index) | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| profile | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| health | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| add-meal | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| scan-food | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| ar-scan-food | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| ar-measure | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| health-settings | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| health/[metricType] | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| health/add | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| not-found | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n| layouts | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ | ☐ |\n\n### Acceptance Criteria\n- All screens render correctly on all device categories\n- No visual bugs, overflow, or truncation\n- Forms are usable on all devices\n- iPad supports both orientations seamlessly\n- Performance remains smooth on older devices (iPhone SE)\n- Safe areas properly respected on all devices",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Responsive Design Utility Library",
            "description": "Build the foundational responsive design utilities including breakpoint definitions, device category constants, and helper functions for device detection. Create lib/responsive/breakpoints.ts with all iPhone (2020+) and iPad screen dimensions.",
            "details": "Create the following files:\n- lib/responsive/breakpoints.ts - Device breakpoint constants\n- lib/responsive/types.ts - TypeScript types for device categories\n- lib/responsive/helpers.ts - Utility functions for device detection\n\nBreakpoints to define:\n- iPhoneSE: 375x667 pts\n- iPhoneMini: 375x812 pts  \n- iPhoneMedium: 390x844 pts\n- iPhonePro: 393x852 pts\n- iPhoneMax: 430x932 pts\n- iPadMini: 744x1133 pts\n- iPad: 820x1180 pts\n- iPadPro11: 834x1194 pts\n- iPadAir13: 1032x1376 pts\n- iPadPro13: 1024x1366 pts",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 12,
            "updatedAt": "2025-12-10T16:49:10.825Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure Orientation Lock for iPhone/iPad",
            "description": "Set up orientation locking - portrait-only for iPhones, both orientations for iPads. Update app.json and implement runtime orientation control using expo-screen-orientation.",
            "details": "1. Update app.json with orientation: \"portrait\" and ios.supportsTablet: true\n2. Install expo-screen-orientation if not present\n3. Implement runtime detection in _layout.tsx:\n   - Lock to PORTRAIT_UP for iPhone\n   - Unlock for iPad (Platform.isPad)\n4. Test orientation behavior on both device types",
            "status": "done",
            "dependencies": [
              "12.1"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-10T16:51:33.416Z"
          },
          {
            "id": 3,
            "title": "Implement useResponsive Hook",
            "description": "Create a comprehensive useResponsive hook that provides device category detection, scaling functions, and responsive utilities. This hook will be the primary interface for responsive design throughout the app.",
            "details": "Create lib/hooks/useResponsive.ts with:\n- useWindowDimensions integration\n- Device category detection (small/medium/large/tablet)\n- isTablet boolean\n- isLandscape boolean  \n- scale() function for proportional sizing\n- scaleFont() for typography\n- getSpacing() for responsive margins/padding\n- Platform-aware logic for iOS/Android differences\n\nExport types and hook from lib/hooks/index.ts",
            "status": "done",
            "dependencies": [
              "12.1"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-10T16:53:13.680Z"
          },
          {
            "id": 4,
            "title": "Create Responsive Typography and Spacing System",
            "description": "Build a responsive typography scale and spacing system that adapts to different device sizes. Create design tokens for font sizes, line heights, and spacing values.",
            "details": "Create lib/responsive/typography.ts:\n- Base font sizes for each device category\n- Responsive font scale (xs, sm, base, lg, xl, 2xl, 3xl)\n- Line height multipliers\n- Letter spacing values\n\nCreate lib/responsive/spacing.ts:\n- Spacing scale (xs: 4, sm: 8, md: 16, lg: 24, xl: 32, 2xl: 48)\n- Responsive padding/margin helpers\n- Safe area aware spacing\n\nEnsure minimum touch targets of 44pt on all devices",
            "status": "done",
            "dependencies": [
              "12.3"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-10T16:55:46.367Z"
          },
          {
            "id": 5,
            "title": "Build Responsive Component Primitives",
            "description": "Create reusable responsive component wrappers that handle common responsive patterns - containers, cards, grids, and form layouts that adapt to device size.",
            "details": "Create components in lib/components/responsive/:\n- ResponsiveContainer.tsx - Max-width container with padding\n- ResponsiveGrid.tsx - Adaptive grid (1-col phone, 2-col tablet)\n- ResponsiveCard.tsx - Card with adaptive sizing\n- ResponsiveForm.tsx - Form layout wrapper\n- ResponsiveText.tsx - Text with automatic font scaling\n\nEach component should:\n- Use useResponsive hook\n- Support iPad landscape/portrait layouts\n- Handle safe areas properly\n- Be fully typed with TypeScript",
            "status": "done",
            "dependencies": [
              "12.3",
              "12.4"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-10T16:58:06.022Z"
          },
          {
            "id": 6,
            "title": "Update Auth Screens for Responsive Design",
            "description": "Adapt all 5 authentication screens (welcome, signin, signup, forgot-password, reset-password) to be responsive across all device categories.",
            "details": "Update these screens:\n- app/auth/welcome.tsx\n- app/auth/signin.tsx\n- app/auth/signup.tsx\n- app/auth/forgot-password.tsx\n- app/auth/reset-password.tsx\n\nFor each screen:\n1. Import and use useResponsive hook\n2. Replace hardcoded dimensions with responsive values\n3. Ensure forms have appropriate widths on tablets (max-width)\n4. Adjust padding and margins for each device category\n5. Verify text is readable on all sizes\n6. Center content appropriately on larger screens\n7. Handle keyboard avoiding behavior on all sizes",
            "status": "done",
            "dependencies": [
              "12.5"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-10T18:18:05.270Z"
          },
          {
            "id": 7,
            "title": "Update Main Tab Screens for Responsive Design",
            "description": "Adapt the 3 main tab screens (home/index, profile, health) and tab layout to be responsive across all device categories.",
            "details": "Update these screens:\n- app/(tabs)/index.tsx - Home dashboard\n- app/(tabs)/profile.tsx - User profile\n- app/(tabs)/health.tsx - Health overview\n- app/(tabs)/_layout.tsx - Tab navigation\n\nFocus areas:\n1. Dashboard cards should use grid on tablets\n2. Profile layout may use side-by-side on landscape iPad\n3. Health metrics should display in responsive grid\n4. Tab bar should adapt sizing for tablets\n5. Charts and graphs must scale appropriately\n6. Lists should have appropriate row heights per device",
            "status": "done",
            "dependencies": [
              "12.5"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:07:23.738Z"
          },
          {
            "id": 8,
            "title": "Update Meal and Scanning Screens for Responsive Design",
            "description": "Adapt the 4 meal/scanning screens (add-meal, scan-food, ar-scan-food, ar-measure) to be responsive, with special attention to camera and AR views.",
            "details": "Update these screens:\n- app/add-meal.tsx - Manual meal entry form\n- app/scan-food.tsx - Camera food scanning\n- app/ar-scan-food.tsx - AR food recognition\n- app/ar-measure.tsx - AR portion measurement\n\nSpecial considerations:\n1. Camera views must fill appropriate area on all devices\n2. AR overlays need to scale with screen size\n3. Form inputs in add-meal need responsive widths\n4. Scanning UI controls must have 44pt+ touch targets\n5. Results display should use available space on tablets\n6. Modal presentations should be appropriately sized",
            "status": "done",
            "dependencies": [
              "12.5"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T17:01:14.494Z"
          },
          {
            "id": 9,
            "title": "Update Health Screens for Responsive Design",
            "description": "Adapt the 3 health-related screens (health-settings, health/[metricType], health/add) and error screen (+not-found) to be responsive.",
            "details": "Update these screens:\n- app/health-settings.tsx - Health settings\n- app/health/[metricType].tsx - Metric detail view\n- app/health/add.tsx - Add health metric\n- app/+not-found.tsx - 404 error page\n- app/_layout.tsx - Root layout\n\nFocus areas:\n1. Settings lists should have appropriate row heights\n2. Metric charts must scale for different screen sizes\n3. Add metric form should be responsive\n4. Error page should center content on all devices\n5. Root layout should handle safe areas consistently",
            "status": "done",
            "dependencies": [
              "12.5"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T17:06:57.390Z"
          },
          {
            "id": 10,
            "title": "iPhone Simulator Testing - All Categories",
            "description": "Run comprehensive simulator testing on all iPhone device categories (SE, Mini, Medium, Pro Max) verifying all 17 screens render correctly in portrait mode.",
            "details": "Test on these simulators:\n1. iPhone SE (3rd generation) - Small/Legacy (375x667)\n2. iPhone 13 Mini - Mini category (375x812)\n3. iPhone 14 - Medium category (390x844)\n4. iPhone 15 Pro - Pro category (393x852)\n5. iPhone 15 Pro Max - Max category (430x932)\n\nFor each device, verify ALL 17 screens:\n- Auth: welcome, signin, signup, forgot-password, reset-password\n- Tabs: home, profile, health\n- Meals: add-meal, scan-food, ar-scan-food, ar-measure\n- Health: health-settings, [metricType], add\n- System: not-found, layouts\n\nChecklist per screen:\n☐ No horizontal overflow\n☐ Text readable, no truncation\n☐ Touch targets >= 44pt\n☐ Safe areas respected\n☐ Forms usable with keyboard",
            "status": "done",
            "dependencies": [
              "12.6",
              "12.7",
              "12.8",
              "12.9"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T17:15:01.128Z"
          },
          {
            "id": 11,
            "title": "iPad Simulator Testing - Both Orientations",
            "description": "Run comprehensive simulator testing on iPad devices (Mini, Air, Pro) in both portrait and landscape orientations, verifying all 17 screens adapt correctly.",
            "details": "Test on these simulators:\n1. iPad Mini (6th generation) - Portrait & Landscape\n2. iPad Air 11-inch - Portrait & Landscape\n3. iPad Pro 11-inch - Portrait & Landscape\n4. iPad Pro 13-inch - Portrait & Landscape\n\nFor each device AND orientation, verify ALL 17 screens:\n- Auth: welcome, signin, signup, forgot-password, reset-password\n- Tabs: home, profile, health\n- Meals: add-meal, scan-food, ar-scan-food, ar-measure\n- Health: health-settings, [metricType], add\n- System: not-found, layouts\n\nChecklist per screen:\n☐ Layout adapts to orientation change\n☐ No content loss on rotation\n☐ Grids display correctly (multi-column where appropriate)\n☐ Forms centered with max-width\n☐ Charts scale appropriately\n☐ Touch targets >= 44pt\n☐ Smooth rotation animation",
            "status": "done",
            "dependencies": [
              "12.6",
              "12.7",
              "12.8",
              "12.9"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T17:16:45.237Z"
          },
          {
            "id": 12,
            "title": "Create Testing Documentation and Verification Report",
            "description": "Document all responsive design testing results, create a verification matrix with screenshots, and compile final report of any issues found and resolutions.",
            "details": "Create documentation in docs/responsive-design/:\n1. TESTING-MATRIX.md - Device x Screen verification grid\n2. BREAKPOINTS.md - Documentation of breakpoint system\n3. SCREENSHOTS/ - Folder with screenshots from each device\n4. ISSUES.md - Log of issues found and how resolved\n5. USAGE-GUIDE.md - How to use responsive utilities\n\nFinal verification matrix should show:\n| Screen | SE | Mini | Med | Max | iPad-P | iPad-L |\nWith ✓/✗ for each combination\n\nInclude simulator commands for future testing:\n- How to boot each simulator\n- How to run app on each device\n- How to take screenshots",
            "status": "done",
            "dependencies": [
              "12.10",
              "12.11"
            ],
            "parentTaskId": 12,
            "parentId": "undefined",
            "updatedAt": "2025-12-11T17:18:50.485Z"
          }
        ],
        "updatedAt": "2025-12-11T17:18:50.485Z",
        "complexity": 8,
        "recommendedSubtasks": 12,
        "expansionPrompt": "The task already has 12 well-defined subtasks that appropriately cover all aspects of the onboarding implementation. The subtask breakdown is comprehensive and follows the existing codebase patterns. No further expansion is needed. The subtasks cover: (1) Database schema with 4 new Prisma models, (2) Zod validation schemas for each step, (3) Backend API with 5 endpoints, (4) Config-driven mobile architecture, (5) State management with AsyncStorage persistence, (6-8) 6 onboarding step screens following existing auth screen patterns, (9) Router integration, (10) HealthKit/notification permissions integration, (11) Backend unit/integration tests, (12) E2E tests with Maestro. Each subtask is appropriately scoped for individual implementation with clear dependencies."
      },
      {
        "id": 13,
        "title": "Integrate USDA FoodData Central Database with Scalable Food Classification System",
        "description": "Integrate the USDA FoodData Central API to expand the food database from ~100 items to 500K+ foods, AND implement a scalable multi-tier food classification architecture. This addresses the critical question: yes, integrating USDA's 500K+ food database requires a fundamentally different classification approach than the current ~100-class model.",
        "details": "## Overview\nThe current food database in `ml-service/app/data/food_database.py` has approximately 100 items with a simple classifier (`FoodAnalysisService._classify_food`). Integrating USDA FoodData Central's 500K+ foods requires a **multi-tier classification architecture** because:\n\n1. **No ML model can reliably classify 500K+ food classes** - even state-of-the-art research focuses on 500-2000 classes\n2. **USDA uses 5 distinct data types** with different classification schemas (Foundation, SR Legacy, Survey/FNDDS, Branded, Experimental)\n3. **User search + AI-assisted refinement** is more practical than pure image classification\n\n## USDA FoodData Central API\n- **API Endpoint**: https://api.nal.usda.gov/fdc/v1/\n- **API Key**: Free, requires registration at https://fdc.nal.usda.gov/api-key-signup.html\n- **Rate Limits**: 1,000 requests/hour per IP (can request increase)\n- **Data Types**: \n  - Foundation Foods (unprocessed/lightly processed)\n  - SR Legacy (comprehensive, final release 2018)\n  - Survey/FNDDS (dietary studies 2021-2023)\n  - Branded (commercial products)\n  - Experimental (research data)\n\n## Multi-Tier Classification Architecture\n\n### Tier 1: Coarse-Grained Visual Classifier (ML Model)\n**Purpose**: Classify images into 20-50 high-level food categories\n**Implementation**: `ml-service/app/ml_models/food_classifier_v3.py`\n\n```python\nclass FoodCategory(str, Enum):\n    # 25-30 categories mapping to USDA food groups\n    FRUITS_FRESH = \"fruits_fresh\"\n    FRUITS_PROCESSED = \"fruits_processed\"\n    VEGETABLES_LEAFY = \"vegetables_leafy\"\n    VEGETABLES_ROOT = \"vegetables_root\"\n    VEGETABLES_OTHER = \"vegetables_other\"\n    MEAT_RED = \"meat_red\"\n    MEAT_POULTRY = \"meat_poultry\"\n    SEAFOOD_FISH = \"seafood_fish\"\n    SEAFOOD_SHELLFISH = \"seafood_shellfish\"\n    DAIRY_MILK = \"dairy_milk\"\n    DAIRY_CHEESE = \"dairy_cheese\"\n    DAIRY_YOGURT = \"dairy_yogurt\"\n    GRAINS_BREAD = \"grains_bread\"\n    GRAINS_PASTA = \"grains_pasta\"\n    GRAINS_RICE = \"grains_rice\"\n    GRAINS_CEREAL = \"grains_cereal\"\n    LEGUMES = \"legumes\"\n    NUTS_SEEDS = \"nuts_seeds\"\n    BEVERAGES_HOT = \"beverages_hot\"\n    BEVERAGES_COLD = \"beverages_cold\"\n    SNACKS_SWEET = \"snacks_sweet\"\n    SNACKS_SAVORY = \"snacks_savory\"\n    MIXED_DISHES = \"mixed_dishes\"\n    FAST_FOOD = \"fast_food\"\n    CONDIMENTS_SAUCES = \"condiments_sauces\"\n    # ... additional categories\n\n@dataclass\nclass CoarseClassification:\n    category: FoodCategory\n    confidence: float\n    subcategory_hints: List[str]  # \"appears sliced\", \"grilled texture\", etc.\n    color_profile: Dict[str, float]  # dominant colors for refinement\n    texture_features: Dict[str, float]  # smooth, grainy, fibrous, etc.\n```\n\n**Model Architecture**:\n- Base: EfficientNet-B4 or ConvNeXt-Base (pretrained on ImageNet)\n- Fine-tuned on Food-2K + custom dataset\n- Output: Top-3 categories with confidence scores\n- Inference time: <100ms on CPU, <20ms on GPU\n\n### Tier 2: Category-Specific Fine-Grained Classifier (Optional ML)\n**Purpose**: Refine within categories (e.g., \"apple\" vs \"pear\" within FRUITS_FRESH)\n**Implementation**: Specialized sub-models loaded on-demand\n\n```python\nclass FinegrainedClassifierRegistry:\n    \"\"\"Registry of category-specific classifiers\"\"\"\n    \n    CLASSIFIERS = {\n        FoodCategory.FRUITS_FRESH: \"models/fruits_classifier_v1.onnx\",\n        FoodCategory.MEAT_RED: \"models/red_meat_classifier_v1.onnx\",\n        FoodCategory.MIXED_DISHES: None,  # Too complex, skip to search\n        # ...\n    }\n    \n    async def classify_finegrained(\n        self, \n        image: Image.Image, \n        category: FoodCategory\n    ) -> Optional[List[FinegrainedPrediction]]:\n        \"\"\"Returns None if no specialized classifier available\"\"\"\n        model_path = self.CLASSIFIERS.get(category)\n        if not model_path:\n            return None\n        # Load and run category-specific model\n        ...\n```\n\n**Category Coverage**:\n- Fruits: ~200 classes (achievable with 85%+ accuracy)\n- Vegetables: ~150 classes\n- Meat/Poultry: ~100 classes\n- Seafood: ~150 classes\n- Branded/Processed: Skip (use text search)\n- Mixed dishes: Skip (use user input + search)\n\n### Tier 3: USDA Search Integration (Primary Lookup)\n**Purpose**: Map classifications to specific USDA FDC entries\n**Implementation**: `server/src/services/foodDatabaseService.ts`\n\n```typescript\ninterface USDASearchStrategy {\n  // Combine visual classification with text search\n  searchWithClassificationContext(\n    query: string,\n    classificationHints: ClassificationHints\n  ): Promise<USDASearchResult[]>;\n}\n\ninterface ClassificationHints {\n  coarseCategory: string;\n  finegrainedSuggestions?: string[];\n  colorProfile?: Record<string, number>;\n  cookingMethod?: string;\n  brandDetected?: string;  // OCR from packaging\n  portionEstimate?: number;  // grams from AR\n}\n\nconst searchWithContext = async (\n  userQuery: string,\n  hints: ClassificationHints\n): Promise<USDAFoodItem[]> => {\n  // 1. Build enhanced search query\n  const enhancedQuery = buildEnhancedQuery(userQuery, hints);\n  \n  // 2. Filter by USDA data types based on category\n  const dataTypes = getRelevantDataTypes(hints.coarseCategory);\n  // Foundation/SR Legacy for whole foods\n  // Branded for packaged foods\n  // Survey for mixed dishes\n  \n  // 3. Execute search with USDA API\n  const results = await usdaApi.search({\n    query: enhancedQuery,\n    dataType: dataTypes,\n    pageSize: 25,\n    sortBy: 'dataType.keyword',  // Prefer Foundation over Branded\n  });\n  \n  // 4. Re-rank results using classification hints\n  return rerankResults(results, hints);\n};\n```\n\n### Tier 4: User Confirmation + Learning Loop\n**Purpose**: Correct misclassifications and improve over time\n**Implementation**: Feedback-driven learning system\n\n```typescript\n// server/src/services/foodFeedbackService.ts\ninterface FoodFeedback {\n  originalPrediction: string;\n  userSelection: string;  // FDC ID selected\n  imageHash: string;      // For deduplication\n  classificationHints: ClassificationHints;\n  timestamp: Date;\n  userId: string;\n}\n\n// Aggregate feedback for model retraining triggers\nconst aggregateFeedback = async (): Promise<RetrainingSignal> => {\n  // When >100 corrections for a category, signal retraining\n  ...\n};\n```\n\n## Backend API Routes (Extended)\n\n### Food Search Endpoints\n```\nGET /api/foods/search?q={query}&limit={limit}&page={page}&dataType={type}\nGET /api/foods/:fdcId\nGET /api/foods/:fdcId/nutrients\nGET /api/foods/popular\nGET /api/foods/recent  (user's recent selections)\n```\n\n### Classification-Assisted Endpoints\n```\nPOST /api/foods/classify-and-search\n  Body: { image: base64, dimensions?: ARDimensions }\n  Response: {\n    classification: { category, confidence, suggestions },\n    searchResults: USDAFoodItem[],\n    portionEstimate?: number\n  }\n\nPOST /api/foods/feedback\n  Body: { classificationId, selectedFdcId, wasCorrect }\n```\n\n## Caching Strategy (Multi-Layer)\n\n### Layer 1: Edge Cache (CDN)\n- Popular food queries: 24-hour TTL\n- Static food data: 7-day TTL\n\n### Layer 2: Redis Cache\n```typescript\n// Search results: 1-hour TTL\nawait redis.setex(`search:${hash(query+dataTypes)}`, 3600, JSON.stringify(results));\n\n// Individual food data: 24-hour TTL\nawait redis.setex(`food:${fdcId}`, 86400, JSON.stringify(foodData));\n\n// User's recent foods: 30-day TTL\nawait redis.zadd(`user:${userId}:foods`, timestamp, fdcId);\n\n// Classification results: 1-hour TTL (for same image)\nawait redis.setex(`classify:${imageHash}`, 3600, JSON.stringify(classification));\n```\n\n### Layer 3: Local SQLite Cache (Mobile)\n```typescript\n// Cache top 10K most searched foods locally\n// Weekly sync for updates\n// Enables offline search with degraded ranking\n```\n\n## Nutrient Mapping (Extended)\n\nMap USDA nutrient IDs to our schema (expanded set):\n```typescript\nconst NUTRIENT_MAPPING = {\n  // Core macros\n  1003: 'protein',      // g\n  1004: 'fat',          // g\n  1005: 'carbs',        // g (by difference)\n  1008: 'calories',     // kcal\n  \n  // Fiber & sugars\n  1079: 'fiber',        // g\n  2000: 'sugars_total', // g\n  1235: 'sugars_added', // g\n  \n  // Fats breakdown\n  1258: 'saturated_fat',     // g\n  1292: 'monounsaturated_fat', // g\n  1293: 'polyunsaturated_fat', // g\n  1257: 'trans_fat',         // g\n  1253: 'cholesterol',       // mg\n  \n  // Minerals\n  1093: 'sodium',       // mg\n  1092: 'potassium',    // mg\n  1087: 'calcium',      // mg\n  1089: 'iron',         // mg\n  1090: 'magnesium',    // mg\n  \n  // Vitamins\n  1106: 'vitamin_a',    // mcg RAE\n  1162: 'vitamin_c',    // mg\n  1114: 'vitamin_d',    // mcg\n  \n  // Amino acids (for Lysine/Arginine tracking)\n  1213: 'lysine',       // g\n  1220: 'arginine',     // g\n};\n```\n\n## ML Model Training Pipeline\n\n### Phase 1: Coarse Classifier Training\n```python\n# ml-service/scripts/train_coarse_classifier.py\n\n# Dataset: Food-2K + custom images\n# Classes: 25-30 food categories\n# Architecture: EfficientNet-B4\n# Training: 50 epochs, cosine LR schedule\n# Target: >90% top-1 accuracy, >98% top-3 accuracy\n\nfrom torchvision.models import efficientnet_b4\nfrom torch.utils.data import DataLoader\n\ndef train_coarse_classifier():\n    model = efficientnet_b4(pretrained=True)\n    model.classifier[-1] = nn.Linear(1792, NUM_CATEGORIES)\n    \n    # Training config\n    optimizer = AdamW(model.parameters(), lr=1e-4)\n    scheduler = CosineAnnealingLR(optimizer, T_max=50)\n    \n    # Mixed precision training\n    scaler = GradScaler()\n    \n    for epoch in range(50):\n        train_epoch(model, train_loader, optimizer, scaler)\n        validate(model, val_loader)\n        scheduler.step()\n```\n\n### Phase 2: Fine-Grained Classifier Training (Per Category)\n```python\n# Only for categories with clear visual distinctions\n# Skip: mixed dishes, branded foods, beverages\n\nTRAINABLE_CATEGORIES = [\n    'fruits_fresh',    # ~200 classes\n    'vegetables',      # ~150 classes\n    'meat_raw',        # ~50 classes\n    'seafood',         # ~150 classes\n]\n\ndef train_finegrained_classifier(category: str):\n    # Filter USDA FDC images for category\n    # Use Foundation Foods data type for quality images\n    # Augmentation: color jitter, rotation, scale\n    # Model: ResNet-50 or ConvNeXt-Small\n    ...\n```\n\n### Phase 3: Continuous Learning Pipeline\n```python\n# Trigger retraining when:\n# 1. >100 corrections for a category\n# 2. Monthly scheduled retraining\n# 3. New USDA data release\n\n@celery.task\ndef check_retraining_triggers():\n    feedback_stats = aggregate_user_feedback()\n    for category, stats in feedback_stats.items():\n        if stats.correction_count > 100:\n            queue_retraining_job(category, stats.feedback_data)\n```\n\n## Environment Variables (Extended)\n```env\n# USDA API\nUSDA_API_KEY=your-api-key-here\nUSDA_API_BASE_URL=https://api.nal.usda.gov/fdc/v1\nUSDA_RATE_LIMIT_PER_HOUR=1000\n\n# ML Model Configuration\nML_MODEL_COARSE_PATH=models/food_coarse_v1.onnx\nML_MODEL_INFERENCE_DEVICE=cpu  # or cuda\nML_MODEL_CONFIDENCE_THRESHOLD=0.6\n\n# Caching\nREDIS_URL=redis://localhost:6379\nCACHE_SEARCH_TTL_SECONDS=3600\nCACHE_FOOD_TTL_SECONDS=86400\n\n# Feature Flags\nENABLE_FINEGRAINED_CLASSIFICATION=true\nENABLE_BRANDED_FOOD_SEARCH=true\nENABLE_FEEDBACK_COLLECTION=true\n```\n\n## Feasibility Analysis\n\n### What IS Feasible:\n1. ✅ Integrating USDA API for 500K+ food search\n2. ✅ Coarse classification into 25-50 categories (>90% accuracy achievable)\n3. ✅ Fine-grained classification for select categories (fruits, vegetables, meat)\n4. ✅ Hybrid search combining visual hints + text queries\n5. ✅ Progressive enhancement with user feedback\n\n### What is NOT Feasible:\n1. ❌ Direct 500K-class image classifier (no model can do this reliably)\n2. ❌ Accurate classification of branded/packaged foods (need barcode/OCR)\n3. ❌ Mixed dishes classification without user input\n4. ❌ Real-time model retraining (must be batch/scheduled)\n\n### Recommended Approach:\n**Hybrid Search-First Architecture**\n- Use ML for coarse categorization + portion estimation\n- Let user search/select from USDA results\n- Learn from corrections to improve suggestions\n- Barcode scanning for packaged foods (Phase 2)\n\n## Success Metrics (Extended)\n- Coarse classification: >90% top-1, >98% top-3 accuracy\n- Search returns results in <500ms (with caching)\n- 95%+ of common foods found in search\n- User selects from top-5 suggestions >80% of time\n- Nutrition data accuracy verified against USDA source\n- Model retraining pipeline completes in <4 hours",
        "testStrategy": "## Testing Strategy (Comprehensive)\n\n### Unit Tests\n\n#### ML Classification Tests\n```python\n# ml-service/tests/test_coarse_classifier.py\nclass TestCoarseClassifier:\n    def test_classification_output_shape(self):\n        \"\"\"Verify model outputs correct number of categories\"\"\"\n        \n    def test_confidence_scores_sum_to_one(self):\n        \"\"\"Softmax outputs should sum to ~1.0\"\"\"\n        \n    def test_inference_time_under_threshold(self):\n        \"\"\"Inference should complete in <100ms CPU\"\"\"\n        \n    def test_batch_inference(self):\n        \"\"\"Multiple images processed correctly\"\"\"\n        \n    def test_model_handles_various_image_sizes(self):\n        \"\"\"Resizing/preprocessing works for any input size\"\"\"\n        \n    def test_model_handles_grayscale_images(self):\n        \"\"\"Graceful handling of non-RGB input\"\"\"\n```\n\n#### USDA API Client Tests\n```typescript\n// server/src/__tests__/foodDatabaseService.test.ts\ndescribe('FoodDatabaseService', () => {\n  test('searchFoods returns properly typed results');\n  test('searchFoods handles empty query gracefully');\n  test('searchFoods respects dataType filter');\n  test('searchFoods paginates correctly');\n  test('getFoodById returns complete nutrition data');\n  test('getFoodById handles non-existent FDC ID');\n  test('nutrient mapping transforms USDA format to app schema');\n  test('nutrient mapping handles missing nutrients gracefully');\n  test('rate limit handling backs off appropriately');\n});\n```\n\n#### Caching Tests\n```typescript\ndescribe('FoodCacheService', () => {\n  test('cache hit returns data without API call');\n  test('cache miss fetches from API and caches');\n  test('cache expiration triggers fresh fetch');\n  test('cache handles Redis connection failure gracefully');\n  test('search result deduplication works correctly');\n});\n```\n\n### Integration Tests\n\n#### Classification Pipeline Tests\n```python\n# ml-service/tests/integration/test_classification_pipeline.py\nclass TestClassificationPipeline:\n    async def test_end_to_end_classification(self):\n        \"\"\"Image → Coarse → Fine-grained → Search suggestions\"\"\"\n        \n    async def test_classification_with_ar_dimensions(self):\n        \"\"\"Classification combined with portion estimation\"\"\"\n        \n    async def test_fallback_when_classifier_unavailable(self):\n        \"\"\"System degrades gracefully without ML model\"\"\"\n        \n    async def test_classification_caching(self):\n        \"\"\"Same image hash returns cached result\"\"\"\n```\n\n#### USDA API Integration Tests\n```typescript\n// Run with actual API (rate-limited test account)\ndescribe('USDA API Integration', () => {\n  test('search for \"apple\" returns Foundation Foods results');\n  test('search for \"coca cola\" returns Branded results');\n  test('getFoodById retrieves full nutrient profile');\n  test('API handles special characters in query');\n  test('API timeout is handled gracefully');\n  test('concurrent requests respect rate limits');\n});\n```\n\n#### Hybrid Search Tests\n```typescript\ndescribe('Hybrid Search', () => {\n  test('classification hints improve search ranking');\n  test('color profile helps distinguish similar foods');\n  test('cooking method hint filters appropriate results');\n  test('portion estimate affects serving size suggestions');\n});\n```\n\n### Mobile Tests\n\n#### Search UI Tests\n```typescript\n// __tests__/screens/FoodSearchScreen.test.tsx\ndescribe('FoodSearchScreen', () => {\n  test('renders search input and results list');\n  test('debounces search input (300ms)');\n  test('displays loading state during search');\n  test('displays error state on API failure');\n  test('displays empty state with suggestions');\n  test('tapping result opens food detail');\n  test('recent searches displayed on focus');\n  test('clear search button works');\n});\n```\n\n#### Classification Integration Tests\n```typescript\ndescribe('FoodClassificationScreen', () => {\n  test('camera capture triggers classification');\n  test('classification results displayed with confidence');\n  test('user can override classification');\n  test('AR dimensions captured when available');\n  test('portion estimate displayed');\n  test('proceed to search with classification hints');\n});\n```\n\n#### Offline Behavior Tests\n```typescript\ndescribe('Offline Mode', () => {\n  test('cached foods searchable offline');\n  test('recent selections available offline');\n  test('graceful degradation message shown');\n  test('classification works offline (model in app)');\n  test('sync queue for pending feedback');\n});\n```\n\n### Performance Tests\n\n#### Classification Performance\n```python\ndef test_coarse_classifier_latency():\n    \"\"\"Target: <100ms on CPU, <20ms on GPU\"\"\"\n    model = load_coarse_classifier()\n    images = load_test_images(100)\n    \n    start = time.time()\n    for img in images:\n        model.predict(img)\n    avg_latency = (time.time() - start) / 100\n    \n    assert avg_latency < 0.1  # 100ms\n\ndef test_finegrained_classifier_latency():\n    \"\"\"Target: <150ms on CPU\"\"\"\n    ...\n```\n\n#### Search Performance\n```typescript\ndescribe('Search Performance', () => {\n  test('cached search returns in <50ms');\n  test('uncached search returns in <500ms');\n  test('concurrent searches (10) complete in <2s');\n  test('large result sets (100 items) render in <100ms');\n});\n```\n\n#### Memory Tests\n```python\ndef test_model_memory_footprint():\n    \"\"\"Coarse model should use <500MB RAM\"\"\"\n    import tracemalloc\n    tracemalloc.start()\n    \n    model = load_coarse_classifier()\n    current, peak = tracemalloc.get_traced_memory()\n    \n    assert peak < 500 * 1024 * 1024  # 500MB\n```\n\n### Accuracy Tests\n\n#### Classification Accuracy\n```python\n# Run on held-out test set\ndef test_coarse_classifier_accuracy():\n    \"\"\"Target: >90% top-1, >98% top-3\"\"\"\n    model = load_coarse_classifier()\n    test_set = load_test_dataset()\n    \n    top1_correct = 0\n    top3_correct = 0\n    \n    for image, label in test_set:\n        predictions = model.predict_top_k(image, k=3)\n        if predictions[0].label == label:\n            top1_correct += 1\n        if label in [p.label for p in predictions]:\n            top3_correct += 1\n    \n    top1_acc = top1_correct / len(test_set)\n    top3_acc = top3_correct / len(test_set)\n    \n    assert top1_acc > 0.90\n    assert top3_acc > 0.98\n\ndef test_per_category_accuracy():\n    \"\"\"Ensure no category has <80% accuracy\"\"\"\n    ...\n```\n\n#### Nutrition Data Accuracy\n```typescript\ndescribe('Nutrition Data Accuracy', () => {\n  test('calories within 5% of USDA source');\n  test('macros within 5% of USDA source');\n  test('portion scaling maintains ratios');\n  test('cooking method adjustments reasonable');\n});\n```\n\n### Edge Case Tests\n\n#### Classification Edge Cases\n```python\ndef test_multiple_foods_in_image():\n    \"\"\"Should return primary classification or multi-food flag\"\"\"\n    \ndef test_partially_eaten_food():\n    \"\"\"Should still classify correctly\"\"\"\n    \ndef test_food_in_packaging():\n    \"\"\"Should suggest barcode scanning\"\"\"\n    \ndef test_non_food_image():\n    \"\"\"Should return low confidence / 'unknown'\"\"\"\n    \ndef test_blurry_image():\n    \"\"\"Should request better image or proceed with caution\"\"\"\n```\n\n#### Search Edge Cases\n```typescript\ndescribe('Search Edge Cases', () => {\n  test('handles Unicode characters (日本語, émoji)');\n  test('handles very long queries (>200 chars)');\n  test('handles SQL injection attempts');\n  test('handles empty/whitespace-only queries');\n  test('handles queries with only special characters');\n});\n```\n\n#### API Failure Edge Cases\n```typescript\ndescribe('API Resilience', () => {\n  test('handles USDA API timeout');\n  test('handles USDA API 500 errors');\n  test('handles rate limit exceeded (429)');\n  test('handles malformed USDA response');\n  test('circuit breaker activates after repeated failures');\n  test('fallback to cached data when API unavailable');\n});\n```\n\n### Feedback Loop Tests\n\n```typescript\ndescribe('Feedback Collection', () => {\n  test('feedback submitted successfully');\n  test('feedback deduplication works');\n  test('feedback aggregation triggers retraining signal');\n  test('feedback privacy (no PII stored)');\n});\n```\n\n### Load Tests\n\n```typescript\ndescribe('Load Testing', () => {\n  test('100 concurrent searches complete in <5s');\n  test('1000 searches/minute sustained without errors');\n  test('cache hit ratio >80% after warmup');\n  test('memory usage stable under load');\n});\n```\n\n### Acceptance Criteria\n\n#### Core Functionality\n- [ ] Search returns relevant results for common foods\n- [ ] Classification correctly categorizes >90% of test images\n- [ ] Nutrition data matches USDA source within 5%\n- [ ] Performance meets latency targets (search <500ms, classify <100ms)\n\n#### User Experience\n- [ ] User selects from top-5 suggestions >80% of time\n- [ ] Search autocomplete feels responsive (<300ms)\n- [ ] Classification confidence displayed helpfully\n- [ ] Graceful degradation when services unavailable\n\n#### System Reliability\n- [ ] Circuit breaker prevents cascade failures\n- [ ] Rate limiting prevents USDA API abuse\n- [ ] Caching reduces API calls by >80%\n- [ ] Offline mode provides useful functionality\n\n#### Data Quality\n- [ ] Nutrient mapping covers all essential nutrients\n- [ ] Serving size conversions accurate\n- [ ] Cooking method adjustments reasonable\n- [ ] Feedback loop improves suggestions over time",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create USDA FoodData Central API Client Service",
            "description": "Create a TypeScript service in server/src/services/usdaApiService.ts to connect to USDA FoodData Central API with rate limiting, error handling, and response typing.",
            "dependencies": [],
            "details": "Implement a USDAApiService class following the existing service pattern in server/src/services/. Include:\n\n1. API client setup with axios instance configured for USDA FDC API (https://api.nal.usda.gov/fdc/v1/)\n2. Environment variable support for USDA_API_KEY in server/.env\n3. Rate limiting middleware using a token bucket algorithm (1000 requests/hour as per USDA limits)\n4. Typed interfaces for USDA response structures (USDASearchResult, USDAFoodItem, USDANutrient)\n5. Methods: searchFoods(query, options), getFoodById(fdcId), getFoodNutrients(fdcId), getBulkFoods(fdcIds[])\n6. Support for dataType filtering: Foundation, SR Legacy, Survey (FNDDS), Branded\n7. Error handling with custom USDAApiError class for timeout, rate limit, and validation errors\n8. Request retry logic with exponential backoff (similar to lib/api/food-analysis.ts pattern)\n9. Response transformation to normalize USDA data format\n10. Logging integration using existing config/logger pattern",
            "status": "done",
            "testStrategy": "Unit tests for rate limiter, response transformation, and error handling. Integration tests mocking USDA API responses for search and detail endpoints. Test rate limit behavior with concurrent requests.",
            "updatedAt": "2025-12-23T16:48:10.702Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Nutrient ID Mapping Service",
            "description": "Create server/src/services/nutrientMappingService.ts to map USDA nutrient IDs to app schema fields with support for 30+ nutrients.",
            "dependencies": [
              1
            ],
            "details": "Build on the existing nutrition schema from mealService.ts (lines 22-48) to map USDA nutrient IDs:\n\n1. Create NUTRIENT_ID_MAP constant mapping USDA IDs to app fields:\n   - Core: 1003→protein, 1004→fat, 1005→carbs, 1008→calories\n   - Fiber/Sugar: 1079→fiber, 2000→sugar, 1235→addedSugar\n   - Fats: 1258→saturatedFat, 1257→transFat, 1253→cholesterol\n   - Minerals: 1093→sodium, 1092→potassium, 1087→calcium, 1089→iron, 1090→magnesium, 1095→zinc, 1091→phosphorus\n   - Vitamins: 1106→vitaminA, 1162→vitaminC, 1114→vitaminD, 1109→vitaminE, 1185→vitaminK, 1175→vitaminB6, 1178→vitaminB12, 1177→folate, 1165→thiamin, 1166→riboflavin, 1167→niacin\n   - Amino acids: 1213→lysine, 1220→arginine\n2. Create mapUSDANutrients(usdaNutrients[]) function returning typed NutritionInfo\n3. Handle unit conversions (mg to mcg for vitamins where needed)\n4. Support per-100g normalization (USDA uses various serving sizes)\n5. Integrate with existing NutritionInfo type from lib/types/food-analysis.ts",
            "status": "done",
            "testStrategy": "Unit tests verifying correct mapping for all 30+ nutrients. Test edge cases: missing nutrients, zero values, alternate units. Verify output matches existing NutritionInfo interface.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T16:50:39.813Z"
          },
          {
            "id": 3,
            "title": "Create Food Search Backend Routes and Controller",
            "description": "Implement /api/foods endpoints (search, getById, getNutrients, popular, recent) in server/src/routes/foodRoutes.ts and server/src/controllers/foodController.ts.",
            "dependencies": [
              1,
              2
            ],
            "details": "Following existing route patterns (see foodAnalysisRoutes.ts):\n\n1. Create server/src/routes/foodRoutes.ts with endpoints:\n   - GET /api/foods/search?q={query}&limit={limit}&page={page}&dataType={type}\n   - GET /api/foods/:fdcId - Get single food with full nutrition\n   - GET /api/foods/:fdcId/nutrients - Get just nutrients for a food\n   - GET /api/foods/popular - Popular foods (cached)\n   - GET /api/foods/recent - User's recently selected foods (requires auth)\n\n2. Create server/src/controllers/foodController.ts with:\n   - searchFoods() - Validates query params via Zod schema, calls usdaApiService\n   - getFoodById() - Fetches and transforms single food\n   - getFoodNutrients() - Returns mapped nutrients\n   - getPopularFoods() - Returns cached popular items\n   - getRecentFoods() - Queries user's food history from DB\n\n3. Add Zod validation schemas in server/src/validation/schemas.ts for search params\n4. Register routes in server/src/index.ts (follow existing pattern line ~50)\n5. Add auth middleware to /recent endpoint only",
            "status": "done",
            "testStrategy": "Integration tests for all 5 endpoints. Test search pagination, dataType filtering, and sorting. Test authentication on /recent. Test 404 handling for invalid fdcId. Load test search endpoint.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T16:53:43.337Z"
          },
          {
            "id": 4,
            "title": "Implement Multi-Tier Redis Caching Layer",
            "description": "Create Redis caching service for USDA data with tiered TTLs: search results (1hr), food data (24hr), user recent foods (30 days).",
            "dependencies": [
              1,
              3
            ],
            "details": "Extend existing Redis patterns from ml-service/app/redis_client.py for the backend:\n\n1. Create server/src/services/foodCacheService.ts:\n   - cacheSearchResults(queryHash, results, ttl=3600) - 1 hour cache\n   - getCachedSearch(queryHash) - Returns cached or null\n   - cacheFood(fdcId, foodData, ttl=86400) - 24 hour cache\n   - getCachedFood(fdcId) - Returns cached food or null\n   - addUserRecentFood(userId, fdcId, ttl=2592000) - 30 day sorted set\n   - getUserRecentFoods(userId, limit=20) - Get user's recent selections\n\n2. Cache key patterns:\n   - search:{sha256(query+params)} for search results\n   - food:{fdcId} for individual foods\n   - user:{userId}:foods (sorted set by timestamp)\n\n3. Configure Redis connection using existing env vars from server/.env\n4. Add cache-aside pattern to foodController.ts methods\n5. Include cache hit/miss metrics logging\n6. Add cache invalidation method for manual refresh",
            "status": "done",
            "testStrategy": "Unit tests for cache key generation and TTL handling. Integration tests with Redis mock verifying cache hits/misses. Test cache invalidation. Load test to verify caching reduces API calls by >80%.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T16:58:07.332Z"
          },
          {
            "id": 5,
            "title": "Create Coarse-Grained Food Category Classifier",
            "description": "Implement 25-30 category food classifier in ml-service using CLIP or fine-tuned EfficientNet for tier-1 classification into high-level food groups.",
            "dependencies": [],
            "details": "Extend existing ml-service/app/ml_models/ following ensemble_classifier.py patterns:\n\n1. Create ml-service/app/ml_models/coarse_classifier.py:\n   - Define FoodCategory enum with 25-30 categories mapped to USDA food groups:\n     FRUITS_FRESH, FRUITS_PROCESSED, VEGETABLES_LEAFY, VEGETABLES_ROOT, VEGETABLES_OTHER,\n     MEAT_RED, MEAT_POULTRY, SEAFOOD_FISH, SEAFOOD_SHELLFISH, DAIRY_MILK, DAIRY_CHEESE,\n     DAIRY_YOGURT, GRAINS_BREAD, GRAINS_PASTA, GRAINS_RICE, GRAINS_CEREAL, LEGUMES,\n     NUTS_SEEDS, BEVERAGES_HOT, BEVERAGES_COLD, SNACKS_SWEET, SNACKS_SAVORY, MIXED_DISHES,\n     FAST_FOOD, CONDIMENTS_SAUCES\n\n2. Leverage existing CLIP classifier (clip_food_classifier.py) with modified prompts:\n   - Create category-specific prompts: \"a photo of {category} food\"\n   - Return top-3 categories with confidence scores\n\n3. Add CoarseClassification dataclass with:\n   - category: FoodCategory\n   - confidence: float\n   - subcategory_hints: List[str]\n   - texture_features: Dict[str, float]\n\n4. Target: >90% top-1 accuracy, >98% top-3 accuracy, <100ms CPU inference",
            "status": "done",
            "testStrategy": "Create test dataset with 100 images across all 25 categories. Measure top-1 and top-3 accuracy. Profile inference time on CPU. Test edge cases: multiple foods, partially visible foods.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T17:01:58.813Z"
          },
          {
            "id": 6,
            "title": "Implement Classification-Assisted Search Endpoint",
            "description": "Create POST /api/foods/classify-and-search endpoint that combines ML classification with USDA search for hybrid food identification.",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Integrate classification hints with USDA search:\n\n1. Create endpoint in foodRoutes.ts:\n   POST /api/foods/classify-and-search\n   Body: { image: base64, dimensions?: ARDimensions }\n   Response: { classification, searchResults, portionEstimate? }\n\n2. Implement in foodController.ts:\n   - Forward image to ML service for coarse classification\n   - Build enhanced search query using classification hints\n   - Filter USDA dataTypes based on category:\n     * Whole foods → Foundation, SR Legacy\n     * Packaged → Branded\n     * Mixed dishes → Survey (FNDDS)\n   - Re-rank USDA results using classification confidence\n   - Include portion estimate if AR dimensions provided\n\n3. Create ClassificationHints interface:\n   { coarseCategory, finegrainedSuggestions?, colorProfile?, cookingMethod?, brandDetected?, portionEstimate? }\n\n4. Add ML service endpoint /api/food/coarse-classify in food_analysis.py\n5. Cache classification results by image hash for 1 hour",
            "status": "done",
            "testStrategy": "E2E tests with sample images verifying classification+search returns relevant results. Test with/without AR dimensions. Benchmark response time <2s. Test caching of identical images.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T17:04:27.829Z"
          },
          {
            "id": 7,
            "title": "Create Food Feedback Collection System",
            "description": "Implement POST /api/foods/feedback endpoint for user corrections and aggregation logic for learning loop.",
            "dependencies": [
              3,
              6
            ],
            "details": "Build on existing feedback pattern from ml-service/app/services/feedback_service.py:\n\n1. Create server/src/services/foodFeedbackService.ts:\n   - submitFeedback(userId, feedbackData) - Store correction\n   - aggregateFeedback() - Compute correction patterns\n   - getTopMisclassifications(limit) - Return common errors\n\n2. Add Prisma model FoodFeedback in schema.prisma:\n   - id, userId, originalPrediction, selectedFdcId\n   - classificationHints (JSON), imageHash, timestamp\n\n3. Create endpoint POST /api/foods/feedback:\n   Body: { classificationId, selectedFdcId, wasCorrect, originalPrediction }\n\n4. Implement aggregation query to find patterns:\n   - When >10 corrections for same original→corrected pair, flag for model review\n   - Store aggregated stats in Redis with 24hr TTL\n\n5. Add GET /api/foods/feedback/stats for analytics\n\n6. Integrate with existing ml-service feedback_service.py refresh_correction_cache()",
            "status": "done",
            "testStrategy": "Unit tests for feedback storage and aggregation logic. Integration tests verifying correction patterns are detected. Test threshold triggers for retraining signals.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T17:08:39.387Z"
          },
          {
            "id": 8,
            "title": "Create Mobile Food Search UI Screen",
            "description": "Implement FoodSearchScreen in app/food-search.tsx with debounced search, dataType filters, and result cards displaying nutrition preview.",
            "dependencies": [
              3
            ],
            "details": "Following existing scan screens patterns (scan-food.tsx, scan-barcode.tsx):\n\n1. Create app/food-search.tsx with:\n   - Search input with 300ms debounce\n   - Filter tabs: All, Whole Foods, Branded, Meals\n   - FlatList of search results with virtualization\n   - Each result card shows: name, brand, calories, macros preview\n   - Loading/empty/error states\n\n2. Create lib/api/foods.ts API client:\n   - searchFoods(query, options) → USDASearchResult[]\n   - getFoodById(fdcId) → USDAFoodItem\n   - getRecentFoods() → USDAFoodItem[]\n\n3. Create lib/components/FoodSearchCard.tsx:\n   - Display food name, brand (if branded), nutriscore\n   - Show mini macros bar (protein/carbs/fat ratio)\n   - Tap to select/view details\n\n4. Add navigation from scan-food.tsx to food-search.tsx as fallback\n5. Register screen in app/_layout.tsx with headerShown: false\n\n6. Use existing theme colors from lib/theme/colors.ts",
            "status": "done",
            "testStrategy": "Component tests for FoodSearchCard rendering. Test debounced search with mock API. Test filter switching. Visual regression tests. Test keyboard handling and scroll behavior.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T17:16:36.249Z"
          },
          {
            "id": 9,
            "title": "Integrate Classification Flow with Search UI",
            "description": "Connect camera/image capture from scan-food.tsx to classification pipeline, then display USDA search results with classification hints.",
            "dependencies": [
              6,
              8
            ],
            "details": "Extend existing scan-food.tsx flow:\n\n1. Modify scan-food.tsx to call /api/foods/classify-and-search:\n   - After image capture, show loading state\n   - Display classification result with confidence\n   - Show top-5 USDA matches from enhanced search\n   - Allow user to confirm or search manually\n\n2. Create lib/components/ClassificationResult.tsx:\n   - Display detected category with confidence bar\n   - Show \"Is this correct?\" confirmation UI\n   - \"Search instead\" button → food-search.tsx\n\n3. Update FoodAnalysisResponse type in lib/types/food-analysis.ts:\n   - Add classificationHints, usdaSearchResults fields\n\n4. Implement confirmation flow:\n   - If user confirms → save meal with USDA nutrition\n   - If user rejects → open food-search.tsx with query prefilled\n   - Track feedback via /api/foods/feedback\n\n5. Handle low-confidence (<0.8) classifications:\n   - Show needs_confirmation UI from existing FoodItem type\n   - Display alternatives prominently",
            "status": "done",
            "testStrategy": "E2E test: capture image → view classification → confirm → meal saved. Test rejection flow navigates to search. Test low-confidence UI display. Measure classification+search latency.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T17:20:52.383Z"
          },
          {
            "id": 10,
            "title": "Implement Offline Food Cache with SQLite",
            "description": "Create SQLite cache on mobile for top 10K popular foods and user's recent selections to enable offline search.",
            "dependencies": [
              8
            ],
            "details": "Implement offline-first food search:\n\n1. Create lib/storage/foodCache.ts using expo-sqlite:\n   - initFoodCache() - Create tables on app start\n   - syncPopularFoods() - Download top 10K foods weekly\n   - cacheRecentFood(food) - Store user selections\n   - searchOffline(query) - FTS5 search on cached foods\n   - getCachedFood(fdcId) - Get single food\n\n2. SQLite schema:\n   - popular_foods: fdcId, name, brand, dataType, calories, protein, carbs, fat, lastSync\n   - recent_foods: fdcId, userId, timestamp, fullData (JSON)\n   - Create FTS5 virtual table for name+brand search\n\n3. Background sync logic:\n   - On app launch, check lastSync timestamp\n   - If >7 days, queue background sync\n   - Sync incrementally (1000 foods at a time)\n\n4. Integrate with food-search.tsx:\n   - Search offline cache first (immediate results)\n   - Then search API (network results appended)\n   - Indicate source: \"Cached\" vs \"Online\"\n\n5. Storage budget: ~20MB for 10K foods with nutrition",
            "status": "done",
            "testStrategy": "Test SQLite schema creation and migrations. Test FTS5 search accuracy. Test sync with network interruption. Measure offline search latency (<50ms). Test storage size with 10K foods.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T17:24:38.936Z"
          },
          {
            "id": 11,
            "title": "Support All USDA Data Types with Ranking",
            "description": "Implement dataType handling for Foundation, SR Legacy, Survey/FNDDS, and Branded foods with appropriate ranking logic.",
            "dependencies": [
              1,
              3
            ],
            "details": "Enhance USDA API service for comprehensive data type support:\n\n1. Update usdaApiService.ts with dataType handling:\n   - Foundation Foods: Unprocessed, highest quality data → rank 1\n   - SR Legacy: Comprehensive standard reference → rank 2\n   - Survey (FNDDS): Mixed dishes from dietary studies → rank 3\n   - Branded: Commercial products with variable quality → rank 4\n\n2. Create server/src/utils/foodRanking.ts:\n   - rankSearchResults(results, hints?) - Apply ranking algorithm\n   - Score factors: dataType weight, name match, category match, data completeness\n   - Boost Foundation/SR Legacy for whole foods searches\n   - Boost Branded for barcode-style queries (product names)\n\n3. Add dataType filter to search endpoint:\n   - Support multiple: ?dataType=Foundation,SR%20Legacy\n   - Default to all types\n\n4. Display dataType in UI:\n   - Badge on FoodSearchCard: \"USDA\", \"Brand\", \"Recipe\"\n   - Different styling per type\n\n5. Handle data quality indicators:\n   - Flag incomplete nutrition data\n   - Prefer foods with more complete nutrient profiles",
            "status": "done",
            "testStrategy": "Test ranking algorithm with mixed dataType results. Verify Foundation foods rank higher for whole food queries. Test branded ranking for product searches. Validate UI badges display correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T10:21:53.746Z"
          },
          {
            "id": 12,
            "title": "Create Integration Tests and Validation Suite",
            "description": "Implement comprehensive E2E tests for USDA search, classification, caching, and nutrition accuracy validation against USDA source data.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11
            ],
            "details": "Create comprehensive test suite:\n\n1. Server integration tests (server/src/__tests__/foods/):\n   - test-usda-search.test.ts: Search accuracy, pagination, filtering\n   - test-food-cache.test.ts: Cache hits/misses, TTL expiration\n   - test-nutrient-mapping.test.ts: Mapping accuracy for all 30+ nutrients\n   - test-classify-search.test.ts: E2E classification+search flow\n   - test-feedback.test.ts: Feedback collection and aggregation\n\n2. ML service tests (ml-service/tests/):\n   - test_coarse_classifier.py: Category classification accuracy\n   - test_usda_integration.py: Search enhancement with hints\n\n3. Nutrition accuracy validation:\n   - Select 50 common foods from USDA\n   - Verify mapped nutrition matches USDA values exactly\n   - Create golden dataset for regression testing\n\n4. Performance benchmarks:\n   - Search response time: <500ms (with cache)\n   - Classification+search: <2s total\n   - Cache hit rate: >80% for popular queries\n\n5. E2E mobile tests (e2e/tests/):\n   - food-search-flow.yaml: Maestro test for search UI\n   - classify-confirm-flow.yaml: Camera → classification → confirm",
            "status": "pending",
            "testStrategy": "Run full test suite in CI. Track test coverage >80%. Monitor performance metrics against benchmarks. Compare nutrition values against USDA reference data for 50 foods.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-26T12:01:56.517Z"
      },
      {
        "id": 14,
        "title": "Implement Barcode Scanner with Open Food Facts Integration",
        "description": "Add barcode scanning capability to the food logging flow using the device camera and integrate with Open Food Facts API for instant nutrition lookup. This addresses a critical competitive gap - MyFitnessPal's barcode scanner is one of their most-used features.",
        "details": "## Overview\nBarcode scanning is the #1 most requested feature for calorie tracking apps. Users expect instant food lookup by simply pointing their camera at a product barcode.\n\n## Technical Implementation\n\n### 1. Camera Barcode Scanner\n- Use `expo-camera` with barcode scanning enabled\n- Support EAN-13, EAN-8, UPC-A, UPC-E formats (standard food barcodes)\n- Implement scanning UI with viewfinder overlay and haptic feedback\n- Handle low-light conditions with torch toggle\n\n### 2. Open Food Facts API Integration\n- API endpoint: https://world.openfoodfacts.org/api/v0/product/{barcode}.json\n- Free, open-source database with 2M+ products\n- No API key required (rate limit: be respectful)\n- Implement caching layer to reduce API calls\n- Store successfully scanned products locally for offline access\n\n### 3. Data Mapping\nMap Open Food Facts response to Nutri's nutrition schema:\n- nutriments.energy-kcal_100g → calories (per 100g)\n- nutriments.proteins_100g → protein\n- nutriments.carbohydrates_100g → carbs\n- nutriments.fat_100g → fat\n- nutriments.fiber_100g → fiber\n- nutriments.sugars_100g → sugar\n- nutriments.sodium_100g → sodium\n- serving_size → portion reference\n\n### 4. UI/UX Flow\n1. User taps barcode icon in add-meal screen\n2. Camera opens with scanning viewfinder\n3. Barcode detected → API lookup\n4. Results shown: product name, image, nutrition per serving\n5. User can adjust serving size\n6. One-tap to add to meal log\n\n### 5. Fallback Handling\n- Product not found: Offer manual entry or AI food scanner\n- Network error: Check local cache first\n- Invalid barcode: Show helpful error message\n\n### 6. Files to Create/Modify\n- `app/scan-barcode.tsx` - New barcode scanner screen\n- `lib/api/openfoodfacts.ts` - API client\n- `lib/types/barcode.ts` - Type definitions\n- `app/add-meal.tsx` - Add barcode scanner button\n- `server/src/routes/foods.ts` - Cache endpoint (optional)\n\n## Success Metrics\n- Scanner accuracy: >95% successful reads\n- API hit rate: >80% products found\n- User adoption: 50%+ of food logs use barcode\n\n## Dependencies\n- expo-camera (already installed)\n- expo-haptics (for feedback)",
        "testStrategy": "1. Unit tests for Open Food Facts API client (mock responses)\n2. Unit tests for nutrition data mapping\n3. Integration tests for barcode detection\n4. E2E test: scan sample barcode → verify nutrition displayed\n5. Test offline caching behavior\n6. Test fallback flows (product not found, network error)",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-11T18:26:51.696Z"
      },
      {
        "id": 15,
        "title": "Build What-If Simulation Engine for Nutrition Impact Prediction",
        "description": "Create an interactive simulation feature that allows users to see predicted health impacts of potential nutrition changes before making them. This is a unique differentiator leveraging our ML correlation engine that no competitor offers.",
        "status": "pending",
        "dependencies": [
          "13"
        ],
        "priority": "high",
        "details": "## Overview\nWhat-If Simulation answers: \"If I change my diet in X way, how will it affect my health metrics?\" This transforms our ML predictions from passive insights to actionable planning tools.\n\n## EXISTING INFRASTRUCTURE (Already Implemented)\n\n### 1. WhatIfService (`ml-service/app/services/what_if.py` - 757 lines)\nALREADY IMPLEMENTS:\n- `test_what_if_scenarios(request: WhatIfRequest)` - Tests multiple scenarios against trained LSTM\n- `generate_counterfactual(request: CounterfactualRequest)` - Generates counterfactual explanations\n- `_apply_scenario_changes()` - Applies feature changes to baseline\n- `_search_counterfactual_changes()` - Greedy search for minimal changes\n- `_load_model_artifacts()` - Loads trained LSTM, scalers, feature names\n- Integrates with DataPreparationService for feature preparation\n- Uses trained per-user LSTM models from models_dir\n\n### 2. Interpretability Schemas (`ml-service/app/schemas/interpretability.py` - 399 lines)\nALREADY DEFINES:\n- WhatIfRequest, WhatIfResponse, WhatIfResult, WhatIfScenario\n- WhatIfChange: feature_name, current_value, new_value, change_description\n- CounterfactualRequest with target_type (IMPROVE, TARGET_VALUE, MINIMIZE_CHANGE)\n- CounterfactualResponse, CounterfactualExplanation, CounterfactualChange\n- PredictionMetric enum reused from predictions.py\n\n### 3. API Routes (`ml-service/app/api/interpretability.py`)\nALREADY EXPOSES:\n- POST `/api/v1/interpret/what-if` - Test what-if scenarios\n- POST `/api/v1/interpret/counterfactual` - Generate counterfactual explanations\n- POST `/api/v1/interpret/explain` - SHAP feature importance\n\n### 4. CorrelationEngineService (`ml-service/app/services/correlation_engine.py`)\nALREADY IMPLEMENTS:\n- `analyze_lag()` - Time-lag correlation analysis (0h to max_lag_hours)\n- LagAnalysisResult with lag_hours, correlation, p_value, is_significant\n- `_apply_lag()` - Shifts feature values to test delayed effects\n- `_calculate_effect_duration()` - Duration of significant effects\n\n## GAPS TO FILL (Actual Work Required)\n\n### 1. Multi-Day Trajectory Generation (NOT YET IMPLEMENTED)\nCurrent what-if is single-day only. Need to EXTEND WhatIfService with:\n- `generate_trajectory()` method for 7/14/30 day projections\n- Autoregressive prediction (use each day's prediction as next input)\n- Accumulating uncertainty over time for confidence bands\n\n### 2. Confidence Interval Calculation (MARKED TODO)\nCurrent code has `confidence_score=0.85` hardcoded (see what_if.py:167, 213)\nNeed to:\n- Calculate actual confidence from model validation MAE\n- Widen confidence bands over longer projection periods\n- Return confidence_lower[] and confidence_upper[] arrays\n\n### 3. Time-Lag Integration (PARTIALLY DONE)\nCorrelationEngineService has lag analysis but WhatIfService doesn't use it.\nNeed to:\n- Import and use CorrelationEngineService in WhatIfService\n- Apply discovered time-lag correlations (e.g., protein affects HRV after 48h)\n- Integrate LagAnalysisResult data into trajectory predictions\n\n### 4. Mobile UI (NOT IMPLEMENTED)\nCreate:\n- `app/simulate.tsx` - Main simulation screen\n- `lib/api/simulation.ts` - API client for simulation endpoints\n- `lib/components/SimulationChart.tsx` - Trajectory visualization with confidence bands\n- `lib/components/SimulationResultCard.tsx` - Result display\n\nUI patterns from `app/health/[metricType].tsx` to follow:\n- SafeAreaView with custom header (back button, title, spacer pattern)\n- ScrollView with RefreshControl\n- LineChart from react-native-chart-kit\n- Stats cards with trend indicators\n- Theme colors: colors.primary.main (#8B5CF6)\n- Responsive design using useResponsive hook\n\n### 5. Safety Guardrails (NOT IMPLEMENTED)\nAdd validation layer:\n- Input validation for extreme changes (>50% warning)\n- Data sufficiency check (min 30 days data)\n- Extrapolation warnings when values outside historical range\n- Medical disclaimer text\n\n## TypeScript Types to Create (matching existing Pydantic schemas)\n```typescript\n// lib/types/simulation.ts\ninterface WhatIfScenario {\n  scenario_name: string;\n  changes: WhatIfChange[];\n}\ninterface WhatIfChange {\n  feature_name: string;\n  current_value: number;\n  new_value: number;\n  change_description: string;\n}\ninterface WhatIfRequest {\n  user_id: string;\n  metric: PredictionMetric;\n  target_date: string;\n  scenarios: WhatIfScenario[];\n  include_baseline?: boolean;\n}\ninterface WhatIfResult {\n  scenario_name: string;\n  predicted_value: number;\n  change_from_baseline: number;\n  percent_change: number;\n  confidence_score: number;\n  biggest_drivers: string[];\n}\ninterface WhatIfResponse {\n  user_id: string;\n  metric: PredictionMetric;\n  target_date: string;\n  baseline_prediction: number;\n  baseline_confidence: number;\n  scenarios: WhatIfResult[];\n  best_scenario: string;\n  best_value: number;\n  worst_scenario: string;\n  worst_value: number;\n  summary: string;\n  recommendation: string;\n}\n// NEW: Trajectory types for multi-day simulation\ninterface SimulationTrajectory {\n  metric: PredictionMetric;\n  baseline_value: number;\n  projected_final_value: number;\n  trajectory: number[];  // daily values\n  confidence_lower: number[];\n  confidence_upper: number[];\n  timestamps: string[];\n}\ninterface SimulationResponse {\n  user_id: string;\n  duration_days: number;\n  predictions: SimulationTrajectory[];\n  confidence_score: number;\n  based_on_correlations: string[];\n  warnings: string[];\n}\n```\n\n## Success Metrics\n- Simulation accuracy: predictions within 15% of actual outcomes\n- User engagement: 30%+ users try simulation feature\n- Goal conversion: 20%+ of simulations saved as goals\n\n## Dependencies\n- Task 6: LSTM models - Core dependency, provides trained models\n- Task 13: USDA database - Optional enhancement for nutrition data",
        "testStrategy": "1. Unit tests for trajectory generation with mock LSTM models\n2. Test confidence interval calculation matches model MAE\n3. Integration tests for extended WhatIfService with trajectory methods\n4. Validation: run simulations on historical data, compare to actual outcomes\n5. E2E test: create simulation → verify trajectory displayed with confidence bands\n6. Test safety guardrails (extreme values, insufficient data, extrapolation)\n7. Mobile component tests for slider interactions and chart rendering\n8. Test API client integration with mock responses",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend WhatIfService with Multi-Day Trajectory Generation",
            "description": "Add generate_trajectory() method to existing WhatIfService that produces 7/14/30 day projections with confidence intervals using autoregressive LSTM predictions.",
            "dependencies": [],
            "details": "Extend ml-service/app/services/what_if.py (NOT create new service):\n\n1. Add new method `generate_trajectory()` to WhatIfService class:\n   - Input: user_id, nutrition changes (deltas), duration_days (7|14|30), metrics_to_predict\n   - Load trained LSTM model using existing `_load_model_artifacts()`\n   - Use existing `_apply_scenario_changes()` to apply nutrition deltas\n\n2. Implement autoregressive day-by-day prediction:\n   - Start with baseline features from DataPreparationService\n   - For each day in duration:\n     a. Apply hypothetical nutrition changes to feature vector\n     b. Run LSTM prediction using loaded model\n     c. Store prediction as part of trajectory\n     d. Use prediction as input feature for next day's prediction\n\n3. Calculate confidence intervals:\n   - Load model MAE from metadata.pkl (exists in model artifacts)\n   - Base confidence on model MAE: confidence_interval = prediction ± (1.96 * MAE)\n   - Accumulate uncertainty: widen bands by sqrt(day_number) factor\n   - Return confidence_lower[] and confidence_upper[] arrays\n\n4. Integrate with CorrelationEngineService for time-lag effects:\n   - Import CorrelationEngineService\n   - Use existing `analyze_lag()` to get optimal lag for nutrition→metric\n   - Apply lag offset when making predictions (e.g., protein change shows in HRV after 48h)\n\n5. Return SimulationTrajectory dataclass with: metric, baseline_value, projected_final_value, trajectory[], confidence_lower[], confidence_upper[], timestamps[]",
            "status": "pending",
            "testStrategy": "Unit tests for trajectory generation with mock LSTM model. Verify autoregressive predictions chain correctly. Test confidence interval widening over time. Verify time-lag integration from CorrelationEngineService. Compare trajectory predictions against historical validation data.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add SimulationTrajectory Schema and Trajectory API Endpoint",
            "description": "Extend existing interpretability schemas with SimulationTrajectory types and add trajectory endpoint to interpretability.py router.",
            "dependencies": [
              1
            ],
            "details": "Extend ml-service/app/schemas/interpretability.py with new schemas:\n\n1. Add SimulationTrajectoryRequest schema:\n   - user_id: str\n   - changes: List[NutritionChange] where NutritionChange has nutrient (protein/carbs/fat/calories/fiber/sugar), delta (float), unit (g/kcal)\n   - duration_days: int (7, 14, or 30)\n   - metrics_to_predict: List[PredictionMetric] (reuse existing enum)\n\n2. Add SimulationTrajectoryResponse schema:\n   - user_id: str\n   - duration_days: int\n   - predictions: List[MetricTrajectory]\n   - MetricTrajectory has: metric, baseline_value, projected_final_value, trajectory (list of daily values), confidence_lower (list), confidence_upper (list), timestamps (list of ISO dates)\n   - confidence_score: float (0-1, overall simulation confidence)\n   - based_on_correlations: List[str] (feature correlations used)\n   - warnings: List[str] (safety messages)\n\n3. Extend ml-service/app/api/interpretability.py:\n   - Add POST `/simulate/trajectory` endpoint\n   - Call WhatIfService.generate_trajectory()\n   - Add GET `/simulate/user-readiness/{user_id}` - Check if user has sufficient data (min 30 days) and trained model\n\n4. Reuse existing patterns from what-if endpoint for error handling and response formatting\n\n5. Keep existing endpoints unchanged - this is additive only",
            "status": "pending",
            "testStrategy": "Integration tests for new trajectory endpoint with mock simulation service. Test request validation for invalid nutrients, out-of-range durations. Test response serialization of trajectory arrays. E2E test of full simulation request flow. Test user-readiness endpoint for users with/without sufficient data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build Mobile Simulation Screen with Nutrient Adjustment Sliders",
            "description": "Create app/simulate.tsx screen with slider controls for nutrition adjustments, following patterns from app/health/[metricType].tsx.",
            "dependencies": [
              2
            ],
            "details": "Create app/simulate.tsx following patterns from app/health/[metricType].tsx (889 lines):\n\n1. Screen structure:\n   - SafeAreaView with custom header (back button, 'What-If Simulation' title, spacer)\n   - ScrollView with contentContainerStyle for responsive padding\n   - Use useResponsive hook for tablet layouts (see line 37-45)\n   - Register route in app/_layout.tsx with headerShown: false\n\n2. Slider controls section (using @react-native-community/slider):\n   - Protein: -50g to +50g (step: 5g)\n   - Carbohydrates: -100g to +100g (step: 10g)\n   - Fat: -30g to +30g (step: 5g)\n   - Calories: -500 to +500 (step: 50)\n   - Sugar: -30g to +30g (step: 5g)\n   - Display current delta value with color coding (+green, -red)\n\n3. Duration selector (similar to dateRangeContainer in [metricType].tsx:354-382):\n   - TouchableOpacity buttons for 7D, 14D, 30D\n   - LinearGradient for active state\n\n4. Metric selection:\n   - Checkboxes for RHR, HRV SDNN, Recovery Score\n   - Use theme colors from lib/theme/colors.ts\n\n5. State management:\n   - nutritionChanges: Record<string, number>\n   - selectedMetrics: PredictionMetric[]\n   - durationDays: 7 | 14 | 30\n   - isLoading, error, simulationResult states\n\n6. Create lib/api/simulation.ts:\n   - simulateTrajectory(request: SimulationTrajectoryRequest) - POST to /api/v1/interpret/simulate/trajectory\n   - getSimulationReadiness(userId: string) - GET /api/v1/interpret/simulate/user-readiness/{userId}\n   - Use existing client.ts axios instance pattern (see lib/api/meals.ts for example)\n\n7. Create lib/types/simulation.ts with TypeScript interfaces matching Pydantic schemas",
            "status": "pending",
            "testStrategy": "Component tests for slider interactions and state changes. Test duration selector toggle. Test API integration with mock responses. Test loading/error states render correctly. Verify accessibility labels on all interactive elements. Test responsive layout on tablet.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Trajectory Visualization with Confidence Bands",
            "description": "Create chart components to visualize predicted trajectories with confidence interval bands, following react-native-chart-kit patterns from health screens.",
            "dependencies": [
              3
            ],
            "details": "Create lib/components/SimulationChart.tsx following LineChart patterns from app/health/[metricType].tsx (lines 414-433):\n\n1. Chart structure:\n   - X-axis: Days (0 to duration) with labels like Day 1, Day 7, etc.\n   - Y-axis: Metric value (auto-scaled)\n   - Use chartConfig pattern from [metricType].tsx:291-309\n   - Match chartWidth calculation (line 41-45)\n\n2. Data layers using react-native-chart-kit:\n   - Solid purple line (#8B5CF6): Projected trajectory\n   - Dashed gray line: Baseline (current trend continuation)\n   - Area fill: 95% confidence interval band (use rgba for transparency)\n\n3. Color coding logic:\n   - Green gradient (colors.status.success) for improvement\n   - Red gradient (colors.status.error) for concerning predictions\n   - Logic based on metric: lower RHR = good, higher HRV = good\n   - Follow getTrendColor pattern from [metricType].tsx:161-174\n\n4. Create SimulationResultCard.tsx:\n   - Metric name header with icon\n   - Current value → projected final value with arrow\n   - Percentage change badge (green/red based on improvement)\n   - Confidence score badge\n   - Embedded SimulationChart component\n   - Style following statCard and trendCard patterns\n\n5. Create SimulationSummary.tsx:\n   - Overall impact summary text\n   - List of key correlations that drove the prediction\n   - Warning messages display (yellow alert style)\n   - Medical disclaimer at bottom\n\n6. Comparison overlay feature:\n   - Toggle button to show/hide baseline comparison line\n   - Visual highlighting of improvement/decline areas",
            "status": "pending",
            "testStrategy": "Snapshot tests for chart rendering with various trajectory shapes. Test color coding logic for different metric types (RHR vs HRV). Test responsive behavior on different screen widths. Visual regression testing for confidence band rendering. Test empty/error states.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Safety Guardrails and Validation Layer",
            "description": "Implement safety guardrails for extreme changes, data sufficiency checks, and user warnings across ML service and mobile UI.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add validation across the stack:\n\n1. In ml-service/app/services/what_if.py - add validation methods:\n   - validate_changes(): Reject changes >50% of typical daily values\n     - Protein: max ±100g/day\n     - Carbs: max ±200g/day\n     - Fat: max ±100g/day\n     - Calories: max ±1000kcal/day\n     - Flag combinations totaling >30% calorie change\n   - check_data_sufficiency(): Require minimum 30 days of data for reliable predictions\n   - cap_confidence(): Reduce confidence_score if user has <30 days data OR if model R² <0.5\n   - detect_extrapolation(): Warn if predicted values fall outside user's historical range (min/max)\n\n2. Warning messages in SimulationTrajectoryResponse:\n   - 'extreme_change': 'This represents a significant dietary change. Consider consulting a nutritionist.'\n   - 'low_confidence': 'Prediction confidence is reduced due to limited historical data (<30 days).'\n   - 'extrapolation': 'Predicted values are outside your historical range - treat with caution.'\n   - 'disclaimer': 'These predictions are estimates and should not replace medical advice.'\n\n3. Mobile UI warnings in app/simulate.tsx:\n   - Display warning banner (yellow background) when extreme values detected\n   - Color-code slider values that exceed safe thresholds (red tint)\n   - Disable 'Run Simulation' button if validation fails\n   - Show medical disclaimer at bottom of results (always)\n   - Use Ionicons 'warning-outline' for warning displays\n\n4. Add 'Save as Goal' feature:\n   - Button in SimulationResultCard to save successful simulation\n   - Store target nutrition values (baseline + deltas) as goal\n   - Link to existing user profile goal tracking\n   - POST to existing user goals endpoint\n\n5. Insufficient data handling:\n   - Check user-readiness before showing simulation screen\n   - Show onboarding prompt if <30 days data: 'Track your nutrition for X more days to unlock predictions'",
            "status": "pending",
            "testStrategy": "Unit tests for all validation rules with edge cases (exact thresholds, combinations). Test warning message generation for each scenario. Test UI behavior when validation fails (button disabled, sliders colored). Integration test verifying disclaimers always appear in API responses. Test Save as Goal flow end-to-end.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 16,
        "title": "Integrate Continuous Glucose Monitor (CGM) Data Sources",
        "description": "Add real-time glucose monitoring integration with major CGM platforms (Dexcom, Abbott Libre, Levels). This enables groundbreaking meal-specific glucose response tracking and positions Nutri as the premier nutrition-metabolic health app.",
        "details": "## Overview\nCGM integration is the next frontier in personalized nutrition. By correlating individual meal consumption with glucose response curves, we can provide unprecedented insights into how specific foods affect each user.\n\n## Technical Implementation\n\n### 1. CGM Platform Integrations\n\n#### Dexcom API\n- OAuth 2.0 authentication\n- Endpoints: /egvs (estimated glucose values)\n- 5-minute reading intervals\n- Developer portal: https://developer.dexcom.com/\n\n#### Abbott LibreView API\n- OAuth 2.0 authentication\n- Historical glucose data access\n- Developer access via partnership application\n\n#### Levels Health API (for Levels users)\n- REST API with API key\n- Enriched glucose data with metabolic scores\n- Partnership integration\n\n### 2. Data Models\n\nNew Prisma models:\n```prisma\nmodel GlucoseReading {\n  id          String   @id @default(uuid())\n  userId      String\n  value       Float    // mg/dL\n  source      GlucoseSource\n  recordedAt  DateTime\n  user        User     @relation(fields: [userId], references: [id])\n  \n  @@index([userId, recordedAt])\n}\n\nenum GlucoseSource {\n  DEXCOM\n  LIBRE\n  LEVELS\n  MANUAL\n}\n\nmodel MealGlucoseResponse {\n  id              String   @id @default(uuid())\n  mealId          String   @unique\n  meal            Meal     @relation(fields: [mealId], references: [id])\n  baselineGlucose Float\n  peakGlucose     Float\n  peakTime        Int      // minutes after meal\n  returnToBaseline Int     // minutes\n  areaUnderCurve  Float\n  glucoseScore    Float    // 0-100 metabolic response score\n}\n```\n\n### 3. Meal-Glucose Correlation\n\nNew ML service: `ml-service/app/services/glucose_analysis.py`\n\nFeatures:\n- Detect meal timing from glucose spikes\n- Calculate glucose response metrics per meal\n- Identify problematic foods for individual users\n- Learn personal glycemic index adjustments\n\n### 4. API Endpoints\n\n```\nPOST /api/v1/integrations/cgm/connect\nPOST /api/v1/integrations/cgm/sync\nGET /api/v1/glucose/readings?from=&to=\nGET /api/v1/glucose/meal-response/:mealId\nGET /api/v1/glucose/insights\n```\n\n### 5. Mobile UI\n\n- `app/settings/cgm-connect.tsx` - OAuth connection flow\n- `app/(tabs)/glucose.tsx` - Glucose dashboard tab (optional)\n- Glucose response card on meal detail view\n- Real-time glucose widget on home screen\n- Glucose trend visualization\n\n### 6. Privacy & Security\n\n- Encrypted storage of CGM credentials\n- User consent flow for data access\n- Data retention policies\n- HIPAA considerations for health data\n\n## Success Metrics\n- Integration success rate: >90% successful connections\n- Data sync reliability: >99% uptime\n- User value: 80%+ of CGM users find insights valuable\n\n## Dependencies\n- Backend OAuth infrastructure\n- Secure credential storage\n- Existing meal logging system",
        "testStrategy": "1. Unit tests for glucose data processing\n2. Mock OAuth flow tests\n3. Integration tests for each CGM provider API\n4. Test meal-glucose correlation calculations\n5. E2E test: connect CGM → sync data → view meal response\n6. Security audit for credential handling\n7. Test reconnection and token refresh flows",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Prisma Schema for GlucoseReading and MealGlucoseResponse Models",
            "description": "Extend the existing Prisma schema with new models for CGM data storage: GlucoseReading for raw glucose values from CGM devices, MealGlucoseResponse for meal-specific glucose response analytics, CGMConnection for OAuth credential storage, and GlucoseSource enum for data provenance tracking.",
            "dependencies": [],
            "details": "1. Add GlucoseSource enum (DEXCOM, LIBRE, LEVELS, MANUAL) to `server/prisma/schema.prisma`\n2. Create GlucoseReading model with fields: id (cuid), userId (relation to User), value (Float for mg/dL), source (GlucoseSource), trendArrow (optional String), recordedAt (DateTime), sourceId (optional), metadata (Json). Add indexes on [userId, recordedAt] and [userId, source, recordedAt]\n3. Create MealGlucoseResponse model with fields: id, mealId (unique relation to Meal), baselineGlucose, peakGlucose, peakTime (Int minutes), returnToBaseline (Int minutes), areaUnderCurve, glucoseScore (0-100), analyzedAt DateTime\n4. Create CGMConnection model for OAuth tokens: id, userId (unique), provider (GlucoseSource), accessToken (encrypted), refreshToken (encrypted), expiresAt, scope, lastSyncAt, isActive. Note: This codebase uses Prisma with PostgreSQL, so leverage existing patterns from User model for relations.\n5. Add 'cgmConnections' and 'glucoseReadings' relations to User model\n6. Run `npm run db:generate` to regenerate Prisma client after schema changes\n7. Create and run migration with `npm run db:migrate`",
            "status": "pending",
            "testStrategy": "Run `npm run db:generate` and verify Prisma client compiles. Run `npm run db:push` in dev environment and verify tables are created. Write unit test in `server/src/__tests__/glucose/models.test.ts` to verify CRUD operations on new models using test fixtures pattern from `setup.ts`.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement OAuth Integration Service for Dexcom and Libre APIs",
            "description": "Create a new CGM OAuth integration service in the backend that handles OAuth 2.0 authentication flows for Dexcom and Abbott Libre APIs, including token management, refresh logic, and secure credential storage using encryption.",
            "dependencies": [
              1
            ],
            "details": "1. Create `server/src/services/cgmIntegrationService.ts` following existing service patterns (see healthMetricService.ts for structure)\n2. Implement OAuth 2.0 authorization code flow for Dexcom API (https://developer.dexcom.com/):\n   - Generate authorization URL with required scopes (egv.read)\n   - Handle callback with authorization code exchange\n   - Store encrypted tokens in CGMConnection model\n   - Implement automatic token refresh using refreshToken before expiry\n3. Implement similar flow for Abbott LibreView API (partnership API)\n4. Add encryption utility in `server/src/utils/encryption.ts` for token storage (use crypto module with AES-256-GCM)\n5. Add new environment variables: DEXCOM_CLIENT_ID, DEXCOM_CLIENT_SECRET, DEXCOM_REDIRECT_URI, LIBRE_CLIENT_ID, LIBRE_CLIENT_SECRET\n6. Create controller `server/src/controllers/cgmController.ts` with methods: initiateConnect, handleCallback, disconnect, getConnectionStatus\n7. Add routes in `server/src/routes/cgmRoutes.ts` following existing route patterns with authenticate middleware\n8. Add Zod validation schemas in `server/src/validation/schemas.ts` for CGM endpoints\n9. Add rate limiting for OAuth endpoints (5 requests/15 min per user) in rateLimiter.ts",
            "status": "pending",
            "testStrategy": "Unit tests with mocked OAuth responses in `server/src/__tests__/cgm/integration.test.ts`. Test token encryption/decryption roundtrip. Mock Dexcom API responses for authorization code exchange. Test token refresh logic with expired tokens. Integration test with mock OAuth server for full connect flow.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build Glucose Data Sync Service with Background Processing",
            "description": "Create a glucose sync service that fetches glucose readings from connected CGM platforms, handles incremental syncing, stores data efficiently, and supports real-time updates with proper error handling and retry logic.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create `server/src/services/glucoseSyncService.ts` with methods:\n   - syncDexcomReadings(userId, cgmConnection): Fetch EGV data from /v3/users/self/egvs endpoint, handle 5-minute intervals\n   - syncLibreReadings(userId, cgmConnection): Fetch historical data from LibreView API\n   - syncAll(userId): Orchestrate sync across all connected providers\n   - getLastSyncTimestamp(userId, source): Get incremental sync start point\n2. Implement incremental sync logic using lastSyncAt from CGMConnection, fetching only new readings since last sync\n3. Create bulk insert method in glucoseReadingService using Prisma createMany with skipDuplicates (pattern from healthMetricService.createBulkHealthMetrics)\n4. Add API endpoints in cgmRoutes.ts:\n   - POST /api/cgm/sync (trigger manual sync)\n   - GET /api/glucose/readings (with startDate, endDate, source query params)\n   - GET /api/glucose/latest (most recent reading)\n5. Handle API rate limits with exponential backoff (Dexcom: 60 requests/hour)\n6. Map CGM trend arrows to standardized format (RISING, FALLING, STABLE, etc.)\n7. Add error handling for common scenarios: expired tokens, API downtime, invalid data\n8. Update CGMConnection.lastSyncAt after successful sync\n9. Add glucose source type to HealthMetricSource enum or create dedicated GlucoseSource type",
            "status": "pending",
            "testStrategy": "Mock Dexcom/Libre API responses for unit tests. Test incremental sync correctly fetches only new data. Test bulk insert deduplication. Test error handling for API failures. Test rate limit handling. E2E test: connect → sync → verify data stored → query readings.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop Meal-Glucose Correlation Analysis in ML Service",
            "description": "Create a new glucose analysis service in the ML service that correlates meal consumption with glucose response curves, calculates metabolic response metrics (peak, baseline, AUC), and generates personalized glucose scores for each meal.",
            "dependencies": [
              1,
              3
            ],
            "details": "1. Create `ml-service/app/services/glucose_analysis.py` following existing service patterns (see food_analysis_service.py for structure)\n2. Implement core analysis functions:\n   - detect_meal_glucose_window(meal_time, glucose_readings, window_hours=3): Find glucose readings within meal impact window\n   - calculate_baseline(readings, minutes_before=30): Average glucose before meal\n   - find_peak(readings, meal_time): Identify peak glucose and time-to-peak\n   - calculate_auc(readings, baseline, duration): Area under curve above baseline\n   - calculate_glucose_score(peak, time_to_peak, return_time, auc): 0-100 metabolic response score\n3. Create Pydantic schemas in `ml-service/app/schemas/glucose_analysis.py`: GlucoseReadingInput, MealGlucoseAnalysisRequest, MealGlucoseResponse\n4. Add API routes in `ml-service/app/api/glucose_analysis.py`:\n   - POST /analyze-meal-response: Analyze specific meal's glucose impact\n   - POST /batch-analyze: Analyze multiple meals\n   - GET /user-patterns/{user_id}: Get aggregate patterns for user\n5. Implement personal glycemic index adjustment: Learn from historical data which foods cause higher responses for individual user\n6. Add statistical analysis for identifying problematic foods (foods with consistently high glucose scores)\n7. Create glucose_analysis router and register in main.py\n8. Add Redis caching for computed meal responses (24h TTL) using existing redis_client pattern",
            "status": "pending",
            "testStrategy": "Unit tests with synthetic glucose curves (known peaks, baselines). Test AUC calculation accuracy. Test glucose score formula produces expected range. Test pattern detection with simulated meal+glucose data. Integration test: submit meal + glucose data → receive analysis with expected metrics.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Mobile UI for CGM Connection and Glucose Dashboard",
            "description": "Build the mobile UI components for CGM platform connection flow (OAuth), real-time glucose display, meal-glucose response visualization, and glucose trends dashboard that integrates with the existing health tab and settings.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "1. Create `app/settings/cgm-connect.tsx` - CGM connection settings screen:\n   - List of available CGM platforms (Dexcom, Libre, Levels) with connection status\n   - OAuth flow initiation via in-app browser (expo-auth-session or expo-web-browser)\n   - Handle OAuth callback and store connection status\n   - Disconnect option with confirmation dialog\n   - Follow existing health-settings.tsx patterns for UI consistency\n2. Create `lib/api/glucose.ts` - API client functions:\n   - connectCGM(provider), disconnectCGM(), getCGMStatus()\n   - syncGlucose(), getGlucoseReadings(params), getLatestGlucose()\n   - getMealGlucoseResponse(mealId)\n3. Add glucose display to meal detail view (`app/edit-meal/[id].tsx`):\n   - GlucoseResponseCard component showing peak, baseline, score, AUC\n   - Mini glucose curve chart using existing chart patterns\n4. Create reusable components in `lib/components/glucose/`:\n   - GlucoseValueDisplay: Current glucose with trend arrow and color coding\n   - GlucoseTrendChart: 24h glucose line chart\n   - MealGlucoseResponseCard: Metrics display for meal impact\n5. Add glucose widget to home dashboard (`app/(tabs)/index.tsx`):\n   - Current glucose reading with trend\n   - Time since last reading\n   - Quick link to detailed glucose view\n6. Optional: Create `app/(tabs)/glucose.tsx` as dedicated glucose tab (or add section to health tab)\n7. Register new screens in `app/_layout.tsx` with headerShown: false\n8. Add Ionicons/IconSymbol for glucose-related icons (water-drop, analytics)\n9. Use existing theme colors, spacing, and typography from `lib/theme/colors.ts`",
            "status": "pending",
            "testStrategy": "Component tests for GlucoseValueDisplay, GlucoseTrendChart with mock data. Test OAuth flow UI states (connecting, connected, error). Test meal response card renders all metrics. E2E test with Maestro: navigate to CGM settings → initiate connection → verify status display. Visual regression tests for glucose dashboard.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 17,
        "title": "Design Hierarchical Food Recognition Architecture",
        "description": "Document and implement the hierarchical food recognition architecture where the image classifier outputs food CATEGORIES (300-500 classes) that serve as search queries for USDA FoodData Central, NOT direct 500K-class classification which is infeasible.",
        "details": "## Architecture Decision Record\n\n### Problem Statement\nUSDA FoodData Central contains 500K+ foods. Should we train a classifier to recognize all of them?\n\n### Decision: NO - Use Hierarchical Architecture\n\n### Rationale\n\n**State of the Art Accuracy by Class Count:**\n- Food-101 (101 classes): 95% accuracy\n- Food-172 (172 classes): 94% accuracy  \n- Food-251 (251 classes): 81% accuracy\n- Food-256 (256 classes): 83% accuracy\n\nPattern: Every 2.5x increase = ~13% accuracy drop. At 500K classes, accuracy would be effectively random.\n\n**Visual Ambiguity Problem:**\nMany USDA items are visually identical:\n- \"Chicken breast, grilled, skin removed\" vs \"with skin\"\n- \"Brown rice, cooked\" vs \"white rice, cooked\"\n- Different brands of identical products\n\nNo classifier can distinguish these - only metadata and user confirmation can.\n\n### Target Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                    FOOD RECOGNITION FLOW                     │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  📷 Photo ──► Classifier (300-500 categories)               │\n│                    │                                        │\n│                    ▼                                        │\n│              \"chicken_breast\" (89% confidence)              │\n│                    │                                        │\n│                    ▼                                        │\n│  USDA Search: query=\"chicken breast\"                        │\n│                    │                                        │\n│                    ▼                                        │\n│  Results: [grilled/fried/roasted/raw variants...]           │\n│                    │                                        │\n│                    ▼                                        │\n│  User Confirms: \"Chicken breast, grilled, no skin\"          │\n│                    │                                        │\n│                    ▼                                        │\n│  AR Portion: 150g × nutrition/100g = Final Nutrition        │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Parallel Path: Barcode Scanner\n```\n📦 Barcode ──► USDA Branded Lookup ──► Exact Nutrition\n```\n\n### Implementation Tasks\n\n1. **Classifier Upgrade (Task 2)**\n   - Expand from 111 → 300-500 categories\n   - Architecture: Vision Transformer (ViT-B/16) or EfficientNet-B4\n   - Target: 85%+ top-5 accuracy\n   - Output: category string for USDA search\n\n2. **USDA Integration (Task 13)**\n   - Implement search API\n   - Category → search results mapping\n   - User confirmation UI\n\n3. **Barcode Scanner (Task 14)**\n   - Direct USDA branded lookup\n   - No classification needed\n\n### Category Taxonomy Design\n\nExpand current 111 classes following USDA structure:\n- Proteins: chicken_breast, chicken_thigh, beef_steak, ground_beef, salmon_fillet...\n- Grains: white_rice, brown_rice, pasta, bread_white, bread_wheat...\n- Vegetables: broccoli, spinach, carrot, potato_baked, potato_mashed...\n- Fruits: apple, banana, orange, strawberry, blueberry...\n- Dairy: milk, yogurt_plain, yogurt_greek, cheese_cheddar...\n- Mixed: pizza, burger, sandwich, salad, soup...\n\n### Success Metrics\n- Classifier top-5 accuracy: >85%\n- USDA search recall: >95% (correct item in top 10 results)\n- User confirmation rate: <2 taps to find correct item\n- End-to-end nutrition accuracy: within 10% of actual\n\n### References\n- SOTA Food Classification: ViT achieving 95% on Food-101\n- MyFitnessPal Meal Scan: Uses same hierarchical approach\n- USDA FoodData Central API: https://fdc.nal.usda.gov/api-guide/",
        "testStrategy": "1. Document review with team\n2. Validate category taxonomy covers 95%+ of common foods\n3. Prototype search flow with mock classifier output\n4. User testing of confirmation UI (target <2 taps)\n5. Accuracy benchmarking on held-out food images",
        "status": "pending",
        "dependencies": [
          "13"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Create Backend API Dockerfile",
        "description": "Create an optimized multi-stage Dockerfile for the Express.js backend server with proper caching, security configurations, and health check support.",
        "details": "Create `server/Dockerfile` with the following implementation:\n\n**Stage 1 - Dependencies:**\n```dockerfile\nFROM node:20-alpine AS deps\nWORKDIR /app\nCOPY package.json package-lock.json ./\nRUN npm ci --only=production\n```\n\n**Stage 2 - Builder:**\n```dockerfile\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package.json package-lock.json ./\nRUN npm ci\nCOPY prisma ./prisma/\nRUN npx prisma generate\nCOPY tsconfig.json ./\nCOPY src ./src/\nRUN npm run build\n```\n\n**Stage 3 - Production:**\n```dockerfile\nFROM node:20-alpine AS runner\nWORKDIR /app\nENV NODE_ENV=production\n\n# Create non-root user\nRUN addgroup --system --gid 1001 nodejs && \\\n    adduser --system --uid 1001 expressjs\n\n# Copy production dependencies and built assets\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma\nCOPY --from=builder /app/prisma ./prisma\nCOPY package.json ./\n\nUSER expressjs\nEXPOSE 3000\n\nHEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 \\\n  CMD node -e \"require('http').get('http://localhost:3000/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))\"\n\nCMD [\"node\", \"dist/index.js\"]\n```\n\n**Also create `server/.dockerignore`:**\n```\nnode_modules\ndist\n.env*\n*.log\ncoverage\n__tests__\n*.md\n.git\n```\n\n**Key requirements:**\n- Target image size under 200MB\n- Run as non-root user (expressjs)\n- Include Prisma client generation\n- HEALTHCHECK instruction pointing to /health endpoint\n- Proper layer caching for node_modules",
        "testStrategy": "1. Build image locally: `docker build -t nutri-backend:test ./server`\n2. Verify image size: `docker images nutri-backend:test` (should be <200MB)\n3. Run container: `docker run -d -p 3000:3000 --name test-backend nutri-backend:test`\n4. Check health: `docker inspect --format='{{.State.Health.Status}}' test-backend`\n5. Verify non-root: `docker exec test-backend whoami` (should output 'expressjs')\n6. Test API: `curl http://localhost:3000/health`",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create multi-stage Dockerfile with dependency caching",
            "description": "Set up the base multi-stage Dockerfile structure with three stages (deps, builder, runner) using node:20-alpine base images and proper layer caching for node_modules.",
            "dependencies": [],
            "details": "Create `server/Dockerfile` with:\n\n**Stage 1 (deps):** Install production dependencies only using `npm ci --only=production`. This stage caches node_modules for production.\n\n**Stage 2 (builder):** Install all dependencies (including devDependencies) with `npm ci`. This stage will be used for TypeScript compilation and Prisma generation.\n\n**Stage 3 (runner):** Create the final production image by copying production node_modules from deps stage. Use node:20-alpine as base and set NODE_ENV=production.\n\nEach stage should have proper WORKDIR /app and copy package files first to leverage Docker layer caching when dependencies don't change.",
            "status": "pending",
            "testStrategy": "Build the Dockerfile locally: `docker build -t nutri-backend:stage1 ./server`. Verify the build completes successfully and check that layer caching works by running build twice - second build should use cached layers for dependencies.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure Prisma generation and TypeScript build in builder stage",
            "description": "Add Prisma client generation and TypeScript compilation steps to the builder stage, ensuring the compiled dist folder and .prisma client are available for production.",
            "dependencies": [
              1
            ],
            "details": "In the builder stage of `server/Dockerfile`:\n\n1. Copy prisma schema: `COPY prisma ./prisma/`\n2. Generate Prisma client: `RUN npx prisma generate`\n3. Copy TypeScript configuration: `COPY tsconfig.json ./`\n4. Copy source code: `COPY src ./src/`\n5. Build TypeScript: `RUN npm run build`\n\nThis produces:\n- `dist/` folder with compiled JavaScript\n- `node_modules/.prisma/` with generated Prisma client\n\nBoth will be copied to the production stage in the next subtask.",
            "status": "pending",
            "testStrategy": "Verify builder stage produces expected artifacts by running: `docker build --target builder -t nutri-backend:builder ./server` then inspect the image: `docker run --rm nutri-backend:builder ls -la dist/` and `docker run --rm nutri-backend:builder ls -la node_modules/.prisma/` to confirm files exist.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create production runtime with security hardening and health checks",
            "description": "Configure the final production stage with non-root user, copy built artifacts from previous stages, add health check, and create .dockerignore file for optimal image size.",
            "dependencies": [
              2
            ],
            "details": "Complete the runner stage in `server/Dockerfile`:\n\n1. Create non-root user: `RUN addgroup --system --gid 1001 nodejs && adduser --system --uid 1001 expressjs`\n2. Copy artifacts:\n   - `COPY --from=deps /app/node_modules ./node_modules`\n   - `COPY --from=builder /app/dist ./dist`\n   - `COPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma`\n   - `COPY --from=builder /app/prisma ./prisma`\n   - `COPY package.json ./`\n3. Switch user: `USER expressjs`\n4. Expose port: `EXPOSE 3000`\n5. Add HEALTHCHECK: `HEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 CMD node -e \"require('http').get('http://localhost:3000/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))\"`\n6. Set entrypoint: `CMD [\"node\", \"dist/index.js\"]`\n\n**Create `server/.dockerignore`:**\n```\nnode_modules\ndist\n.env*\n*.log\ncoverage\n__tests__\n*.md\n.git\n.gitignore\nnpm-debug.log*\n.DS_Store\n```",
            "status": "pending",
            "testStrategy": "1. Build final image: `docker build -t nutri-backend:test ./server`\n2. Verify size under 200MB: `docker images nutri-backend:test`\n3. Run container: `docker run -d -p 3000:3000 --env DATABASE_URL=postgresql://test:test@localhost:5432/test --env JWT_SECRET=test-secret --name test-backend nutri-backend:test`\n4. Check health status: `docker inspect --format='{{.State.Health.Status}}' test-backend` (should show 'healthy' after ~30s)\n5. Verify non-root user: `docker exec test-backend whoami` (should show 'expressjs')\n6. Test endpoint: `curl http://localhost:3000/health`\n7. Cleanup: `docker stop test-backend && docker rm test-backend`",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the Dockerfile creation into: 1) Set up multi-stage build structure with proper base images and dependency caching, 2) Configure Prisma client generation and TypeScript compilation in builder stage, 3) Create production runtime stage with non-root user, health checks, and security hardening. Include .dockerignore creation and local testing.",
        "updatedAt": "2025-12-17T23:20:53.506Z"
      },
      {
        "id": 19,
        "title": "Enhance ML Service Dockerfile for Production",
        "description": "Update the existing ML service Dockerfile to run as non-root user and optimize for production deployment with proper security configurations.",
        "details": "Update `ml-service/Dockerfile` to add non-root user support:\n\n**Modifications to existing Dockerfile:**\n```dockerfile\n# Stage 2: Runtime (update existing)\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Install runtime dependencies\nRUN apt-get update && apt-get install -y \\\n    libpq5 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Create non-root user\nRUN groupadd --system --gid 1001 mlservice && \\\n    useradd --system --uid 1001 --gid mlservice mlservice\n\n# Copy Python dependencies from builder (update ownership)\nCOPY --from=builder --chown=mlservice:mlservice /root/.local /home/mlservice/.local\n\n# Update PATH for non-root user\nENV PATH=/home/mlservice/.local/bin:$PATH\n\n# Copy application code\nCOPY --chown=mlservice:mlservice ./app /app/app\n\n# Create directories for ML models with correct ownership\nRUN mkdir -p /app/app/ml_models && chown -R mlservice:mlservice /app\n\n# Switch to non-root user\nUSER mlservice\n\n# Expose port\nEXPOSE 8000\n\n# Environment variables\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \\\n    CMD python -c \"import urllib.request; urllib.request.urlopen('http://localhost:8000/health')\"\n\n# Run the application\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\", \"--workers\", \"4\"]\n```\n\n**Create `ml-service/.dockerignore`:**\n```\n__pycache__\n*.pyc\n*.pyo\n.pytest_cache\n.mypy_cache\nvenv\n.env*\n*.log\ncoverage\ntests\n*.md\n.git\n```\n\n**Key changes:**\n- Add non-root user 'mlservice'\n- Set PYTHONDONTWRITEBYTECODE and PYTHONUNBUFFERED\n- Proper ownership of files\n- Keep existing health check and multi-stage build",
        "testStrategy": "1. Build image: `cd ml-service && docker build -t nutri-ml:test .`\n2. Verify non-root: `docker run --rm nutri-ml:test whoami` (should output 'mlservice')\n3. Test health endpoint: `docker run -d -p 8000:8000 --name test-ml nutri-ml:test && sleep 5 && curl http://localhost:8000/health`\n4. Check container health: `docker inspect --format='{{.State.Health.Status}}' test-ml`\n5. Verify image size is reasonable (target <1.5GB due to ML dependencies)",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Modify Dockerfile to add non-root user with proper ownership",
            "description": "Update the existing ml-service/Dockerfile to create and configure a non-root user 'mlservice' with proper file ownership, PATH configuration, and security best practices.",
            "dependencies": [],
            "details": "Update the Dockerfile runtime stage to:\n1. Create system group 'mlservice' (GID 1001) and user 'mlservice' (UID 1001)\n2. Copy Python dependencies from builder with --chown=mlservice:mlservice to /home/mlservice/.local\n3. Update PATH environment variable to include /home/mlservice/.local/bin\n4. Copy application code with --chown=mlservice:mlservice\n5. Create /app/app/ml_models directory with proper ownership (chown -R mlservice:mlservice /app)\n6. Switch to non-root user with USER mlservice directive\n7. Ensure existing health check, multi-stage build, and uvicorn CMD remain functional\n8. Keep existing runtime dependencies (libpq5) installation",
            "status": "done",
            "testStrategy": "1. Build image: `cd ml-service && docker build -t nutri-ml:test .`\n2. Verify non-root user: `docker run --rm nutri-ml:test whoami` (expected: 'mlservice')\n3. Check user ID: `docker run --rm nutri-ml:test id` (expected: uid=1001(mlservice) gid=1001(mlservice))\n4. Verify file ownership: `docker run --rm nutri-ml:test ls -la /app` (all files should be owned by mlservice:mlservice)\n5. Test service starts: `docker run -d -p 8000:8000 --name test-ml nutri-ml:test && sleep 5 && curl http://localhost:8000/health`",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T16:36:41.396Z"
          },
          {
            "id": 2,
            "title": "Create .dockerignore and add production environment variables",
            "description": "Create a .dockerignore file to exclude unnecessary files from the Docker build context and add PYTHONDONTWRITEBYTECODE and PYTHONUNBUFFERED environment variables for production security and performance.",
            "dependencies": [
              1
            ],
            "details": "1. Create ml-service/.dockerignore with exclusions:\n   - Python cache files: __pycache__, *.pyc, *.pyo\n   - Test and coverage directories: .pytest_cache, .mypy_cache, coverage, tests\n   - Virtual environments and configs: venv, .env*, *.log\n   - Documentation and version control: *.md, .git\n2. Add environment variables to Dockerfile:\n   - PYTHONDONTWRITEBYTECODE=1 (prevents .pyc file generation)\n   - PYTHONUNBUFFERED=1 (ensures real-time logging)\n3. Verify existing EXPOSE 8000 and HEALTHCHECK directives remain intact\n4. Ensure CMD uvicorn with --workers 4 configuration is preserved",
            "status": "done",
            "testStrategy": "1. Verify .dockerignore: `docker build -t nutri-ml:test . --progress=plain` and check build context size is reduced\n2. Build image and verify environment variables: `docker run --rm nutri-ml:test env | grep PYTHON` (should show both variables)\n3. Test health check works: `docker run -d -p 8000:8000 --name test-ml nutri-ml:test && sleep 40 && docker inspect --format='{{.State.Health.Status}}' test-ml` (expected: 'healthy')\n4. Verify no .pyc files: `docker run --rm nutri-ml:test find /app -name '*.pyc'` (should be empty)\n5. Full integration test: Start container, verify service runs as mlservice user, health endpoint responds, and logs are unbuffered",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T16:36:41.444Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) Modify existing Dockerfile to add non-root user 'mlservice' with proper file ownership and PATH configuration, 2) Create .dockerignore and update environment variables for production security. Test that the service runs as non-root and health check works correctly.",
        "updatedAt": "2025-12-23T16:36:41.444Z"
      },
      {
        "id": 20,
        "title": "Create Production Docker Compose Configuration",
        "description": "Create docker-compose.prod.yml that mirrors production environment for local testing, including all services with production-like settings and .env.example documentation.",
        "details": "**Create `docker-compose.prod.yml`:**\n```yaml\nversion: '3.8'\n\nservices:\n  backend:\n    build:\n      context: ./server\n      dockerfile: Dockerfile\n    container_name: nutri-backend\n    restart: unless-stopped\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=${DATABASE_URL}\n      - JWT_SECRET=${JWT_SECRET}\n      - JWT_EXPIRES_IN=${JWT_EXPIRES_IN:-7d}\n      - PORT=3000\n      - REDIS_URL=${REDIS_URL}\n      - ML_SERVICE_URL=http://ml-service:8000\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"node\", \"-e\", \"require('http').get('http://localhost:3000/health', r => process.exit(r.statusCode === 200 ? 0 : 1))\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n    networks:\n      - nutri-network\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n        max-file: \"3\"\n\n  ml-service:\n    build:\n      context: ./ml-service\n      dockerfile: Dockerfile\n    container_name: nutri-ml-service\n    restart: unless-stopped\n    environment:\n      - DATABASE_URL=${ML_DATABASE_URL:-postgresql+asyncpg://postgres:postgres@postgres:5432/nutri_db}\n      - REDIS_URL=${REDIS_URL:-redis://redis:6379/0}\n      - ENVIRONMENT=production\n      - DEBUG=false\n      - LOG_LEVEL=INFO\n    expose:\n      - \"8000\"\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"python\", \"-c\", \"import urllib.request; urllib.request.urlopen('http://localhost:8000/health')\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n    networks:\n      - nutri-network\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n        max-file: \"3\"\n\n  postgres:\n    image: postgres:16-alpine\n    container_name: nutri-postgres-prod\n    restart: unless-stopped\n    environment:\n      POSTGRES_USER: ${POSTGRES_USER:-postgres}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n      POSTGRES_DB: ${POSTGRES_DB:-nutri_db}\n    volumes:\n      - postgres_prod_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U ${POSTGRES_USER:-postgres}\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    networks:\n      - nutri-network\n\n  redis:\n    image: redis:7-alpine\n    container_name: nutri-redis-prod\n    restart: unless-stopped\n    command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru\n    volumes:\n      - redis_prod_data:/data\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    networks:\n      - nutri-network\n\nvolumes:\n  postgres_prod_data:\n  redis_prod_data:\n\nnetworks:\n  nutri-network:\n    driver: bridge\n```\n\n**Create/Update `.env.example`:**\n```env\n# Database (Required)\nDATABASE_URL=postgresql://postgres:password@localhost:5432/nutri_db\nML_DATABASE_URL=postgresql+asyncpg://postgres:password@localhost:5432/nutri_db\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=your-secure-password\nPOSTGRES_DB=nutri_db\n\n# Redis\nREDIS_URL=redis://localhost:6379/0\n\n# JWT (Required)\nJWT_SECRET=your-256-bit-secret-key-change-in-production\nJWT_EXPIRES_IN=7d\n\n# Environment\nNODE_ENV=production\n```",
        "testStrategy": "1. Copy `.env.example` to `.env.prod` and fill in test values\n2. Run: `docker-compose -f docker-compose.prod.yml --env-file .env.prod up --build`\n3. Verify all services start: `docker-compose -f docker-compose.prod.yml ps`\n4. Test backend: `curl http://localhost:3000/health`\n5. Verify ML service is only internally accessible (not on host port)\n6. Test backend can reach ML service internally\n7. Check logs: `docker-compose -f docker-compose.prod.yml logs backend`",
        "priority": "high",
        "dependencies": [
          "18",
          "19"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create docker-compose.prod.yml with backend service configuration",
            "description": "Create the production Docker Compose file with backend service including health checks, restart policies, environment variables, port mappings, and dependency configuration on postgres and redis services.",
            "dependencies": [],
            "details": "Create `docker-compose.prod.yml` in the project root with version 3.8. Configure the backend service with:\n- Build context pointing to ./server with Dockerfile\n- Container name: nutri-backend\n- Restart policy: unless-stopped\n- Environment variables: NODE_ENV=production, DATABASE_URL, JWT_SECRET, JWT_EXPIRES_IN (default 7d), PORT=3000, REDIS_URL, ML_SERVICE_URL=http://ml-service:8000\n- Port mapping: 3000:3000\n- Dependencies on postgres and redis with health check conditions\n- Health check using Node.js HTTP request to /health endpoint (interval: 30s, timeout: 10s, retries: 3)\n- Network: nutri-network\n- JSON file logging with max-size 10m and max-file 3",
            "status": "pending",
            "testStrategy": "Build and start backend service: `docker-compose -f docker-compose.prod.yml up backend --build`. Verify container starts successfully, health check passes, and service responds to `curl http://localhost:3000/health`. Check logs show production environment.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add ML service with internal networking and resource configuration",
            "description": "Configure the ml-service in docker-compose.prod.yml with internal-only networking (no host port exposure), proper dependencies, health checks, and production-appropriate settings.",
            "dependencies": [
              1
            ],
            "details": "Add ml-service to docker-compose.prod.yml:\n- Build context: ./ml-service with Dockerfile\n- Container name: nutri-ml-service\n- Restart policy: unless-stopped\n- Environment: DATABASE_URL (ML_DATABASE_URL with default), REDIS_URL (with default), ENVIRONMENT=production, DEBUG=false, LOG_LEVEL=INFO\n- Expose port 8000 internally only (no ports mapping to host)\n- Dependencies on postgres and redis with health check conditions\n- Health check using Python urllib to call /health endpoint (interval: 30s, timeout: 10s, retries: 3, start_period: 40s)\n- Network: nutri-network\n- JSON file logging with max-size 10m and max-file 3\n\nEnsure ML service is only accessible from backend service via internal network.",
            "status": "pending",
            "testStrategy": "Start all services: `docker-compose -f docker-compose.prod.yml up --build`. Verify ml-service container starts, health check passes, and is NOT accessible from host (`curl http://localhost:8000/health` should fail). Test backend can reach ML service by checking backend logs for successful ML_SERVICE_URL connections.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configure postgres and redis services with production volumes and health checks",
            "description": "Set up postgres and redis services in docker-compose.prod.yml with named volumes for data persistence, health checks, restart policies, and production-optimized configurations.",
            "dependencies": [
              1
            ],
            "details": "Add postgres service:\n- Image: postgres:16-alpine\n- Container name: nutri-postgres-prod\n- Restart policy: unless-stopped\n- Environment: POSTGRES_USER (default postgres), POSTGRES_PASSWORD, POSTGRES_DB (default nutri_db)\n- Volume: postgres_prod_data:/var/lib/postgresql/data\n- Health check: pg_isready command (interval: 10s, timeout: 5s, retries: 5)\n- Network: nutri-network\n\nAdd redis service:\n- Image: redis:7-alpine\n- Container name: nutri-redis-prod\n- Restart policy: unless-stopped\n- Command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru\n- Volume: redis_prod_data:/data\n- Health check: redis-cli ping (interval: 10s, timeout: 5s, retries: 5)\n- Network: nutri-network\n\nDefine volumes section with postgres_prod_data and redis_prod_data.\nDefine networks section with nutri-network using bridge driver.",
            "status": "pending",
            "testStrategy": "Start postgres and redis: `docker-compose -f docker-compose.prod.yml up postgres redis`. Verify both services start with healthy status: `docker-compose -f docker-compose.prod.yml ps`. Check volumes are created: `docker volume ls | grep prod`. Test postgres connection: `docker exec nutri-postgres-prod pg_isready`. Test redis: `docker exec nutri-redis-prod redis-cli ping`.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create/update .env.example with comprehensive documentation",
            "description": "Create or update .env.example file with all required environment variables, sensible defaults, security notes, and clear documentation for production deployment configuration.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create `.env.example` in project root with documented sections:\n\n**Database (Required):**\n- DATABASE_URL=postgresql://postgres:password@localhost:5432/nutri_db\n- ML_DATABASE_URL=postgresql+asyncpg://postgres:password@localhost:5432/nutri_db\n- POSTGRES_USER=postgres\n- POSTGRES_PASSWORD=your-secure-password (with security note)\n- POSTGRES_DB=nutri_db\n\n**Redis:**\n- REDIS_URL=redis://localhost:6379/0\n\n**JWT (Required):**\n- JWT_SECRET=your-256-bit-secret-key-change-in-production (with strong security warning)\n- JWT_EXPIRES_IN=7d\n\n**Environment:**\n- NODE_ENV=production\n\nInclude comments explaining each variable's purpose, required vs optional status, and security implications. Add header with instructions to copy to .env.prod for local testing.",
            "status": "pending",
            "testStrategy": "Copy .env.example to .env.prod and fill in test values. Run full stack: `docker-compose -f docker-compose.prod.yml --env-file .env.prod up --build`. Verify all services start successfully: `docker-compose -f docker-compose.prod.yml ps`. Test inter-service communication: backend health check, backend to ML service connection, postgres connectivity, redis connectivity. Verify environment variables are correctly passed to containers.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Divide into: 1) Create docker-compose.prod.yml with backend service configuration including health checks and dependencies, 2) Add ML service with internal-only networking and proper resource limits, 3) Configure postgres and redis services with production volumes and health checks, 4) Create/update .env.example with all required environment variables and documentation. Test full stack startup and inter-service communication.",
        "updatedAt": "2025-12-26T10:19:35.073Z"
      },
      {
        "id": 21,
        "title": "Implement Comprehensive Health Check Endpoints",
        "description": "Enhance the backend health endpoint to check database and Redis connectivity, and add similar comprehensive checks to the ML service. Support both liveness and readiness probes.",
        "details": "**Update `server/src/index.ts` - Replace simple health check:**\n```typescript\nimport { PrismaClient } from '@prisma/client';\nimport { Redis } from 'ioredis'; // or use existing redis client\n\nconst prisma = new PrismaClient();\nconst packageJson = require('../package.json');\n\n// Liveness probe - just checks if server is running\napp.get('/health/live', (_req, res) => {\n  res.status(200).json({ status: 'ok' });\n});\n\n// Readiness probe - checks all dependencies\napp.get('/health', async (_req, res) => {\n  const checks: Record<string, { status: string; latency_ms?: number; error?: string }> = {};\n  let overallStatus = 'healthy';\n\n  // Database check\n  const dbStart = Date.now();\n  try {\n    await prisma.$queryRaw`SELECT 1`;\n    checks.database = { status: 'healthy', latency_ms: Date.now() - dbStart };\n  } catch (error) {\n    checks.database = { status: 'unhealthy', error: (error as Error).message };\n    overallStatus = 'unhealthy';\n  }\n\n  // Redis check (if configured)\n  if (process.env.REDIS_URL) {\n    const redisStart = Date.now();\n    try {\n      // Ping redis\n      checks.redis = { status: 'healthy', latency_ms: Date.now() - redisStart };\n    } catch (error) {\n      checks.redis = { status: 'unhealthy', error: (error as Error).message };\n      overallStatus = 'degraded'; // Redis is optional\n    }\n  }\n\n  // ML Service check (optional, don't fail if unavailable)\n  if (process.env.ML_SERVICE_URL) {\n    const mlStart = Date.now();\n    try {\n      const response = await fetch(`${process.env.ML_SERVICE_URL}/health`, {\n        signal: AbortSignal.timeout(5000),\n      });\n      if (response.ok) {\n        checks.ml_service = { status: 'healthy', latency_ms: Date.now() - mlStart };\n      } else {\n        checks.ml_service = { status: 'degraded', latency_ms: Date.now() - mlStart };\n      }\n    } catch (error) {\n      checks.ml_service = { status: 'unavailable', error: (error as Error).message };\n    }\n  }\n\n  const statusCode = overallStatus === 'healthy' ? 200 : overallStatus === 'degraded' ? 200 : 503;\n  res.status(statusCode).json({\n    status: overallStatus,\n    version: packageJson.version,\n    timestamp: new Date().toISOString(),\n    checks,\n  });\n});\n```\n\n**Update ML Service `ml-service/app/main.py`:**\n```python\nfrom fastapi import FastAPI\nfrom datetime import datetime\nimport time\nfrom app.config import settings\n\n@app.get('/health')\nasync def health_check():\n    checks = {}\n    overall_status = 'healthy'\n    \n    # Database check\n    db_start = time.time()\n    try:\n        async with get_db() as db:\n            await db.execute('SELECT 1')\n        checks['database'] = {'status': 'healthy', 'latency_ms': int((time.time() - db_start) * 1000)}\n    except Exception as e:\n        checks['database'] = {'status': 'unhealthy', 'error': str(e)}\n        overall_status = 'unhealthy'\n    \n    # Redis check\n    redis_start = time.time()\n    try:\n        await redis_client.ping()\n        checks['redis'] = {'status': 'healthy', 'latency_ms': int((time.time() - redis_start) * 1000)}\n    except Exception as e:\n        checks['redis'] = {'status': 'unhealthy', 'error': str(e)}\n        overall_status = 'degraded'\n    \n    # Model check\n    checks['model'] = {'status': 'healthy' if model_loaded else 'unavailable'}\n    \n    status_code = 200 if overall_status in ['healthy', 'degraded'] else 503\n    return JSONResponse(\n        status_code=status_code,\n        content={\n            'status': overall_status,\n            'version': settings.VERSION,\n            'timestamp': datetime.utcnow().isoformat() + 'Z',\n            'checks': checks\n        }\n    )\n\n@app.get('/health/live')\nasync def liveness():\n    return {'status': 'ok'}\n```",
        "testStrategy": "1. Unit test health endpoint with mocked dependencies\n2. Integration test with real DB/Redis: verify response structure\n3. Test failure scenarios: stop postgres, verify status=unhealthy and 503\n4. Test degraded state: stop redis, verify status=degraded and 200\n5. Verify /health/live always returns 200\n6. Test response latency <100ms under normal conditions\n7. Verify version field matches package.json",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance backend /health endpoint with database connectivity check",
            "description": "Update server/src/index.ts to add Prisma database connectivity check with latency measurement and proper error handling",
            "dependencies": [],
            "details": "Import PrismaClient and use $queryRaw to execute SELECT 1 query. Measure latency using Date.now() before and after query. Wrap in try-catch to handle errors. Return status 'healthy' on success with latency_ms, or 'unhealthy' with error message on failure. Set overall status to 'unhealthy' if database check fails. Import package.json to include version in response.",
            "status": "pending",
            "testStrategy": "Unit test with mocked Prisma client. Integration test with real database connection. Test failure scenario by stopping PostgreSQL and verifying 503 status code and unhealthy status in response.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Redis connectivity check with optional dependency handling",
            "description": "Implement Redis ping check in /health endpoint with proper error handling for when Redis is not configured or unavailable",
            "dependencies": [
              1
            ],
            "details": "Check if REDIS_URL environment variable exists. If configured, initialize Redis client (ioredis) and ping. Measure latency. On success, add redis check with 'healthy' status. On failure, add 'unhealthy' status but set overall status to 'degraded' (not unhealthy) since Redis is optional. Skip Redis check entirely if REDIS_URL not set.",
            "status": "pending",
            "testStrategy": "Test with REDIS_URL configured: verify ping succeeds and returns healthy. Test with Redis stopped: verify degraded status (200 status code, not 503). Test without REDIS_URL: verify no redis check in response.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add ML service reachability check from backend",
            "description": "Implement optional ML service health check using fetch with timeout to verify connectivity to ml-service",
            "dependencies": [
              1
            ],
            "details": "Check if ML_SERVICE_URL environment variable exists. Use fetch with AbortSignal.timeout(5000) to call ${ML_SERVICE_URL}/health. On successful response (response.ok), mark as 'healthy' with latency. On error or non-ok response, mark as 'unavailable' or 'degraded'. Don't fail overall health check if ML service is down (it's optional).",
            "status": "pending",
            "testStrategy": "Test with ML_SERVICE_URL configured and service running: verify healthy status. Test with service unreachable: verify unavailable status but overall health remains healthy/degraded. Test timeout scenario with 5s limit. Test without ML_SERVICE_URL: verify no ml_service check in response.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement /health/live liveness probe endpoint",
            "description": "Create simple liveness probe endpoint that returns immediate OK status without dependency checks",
            "dependencies": [],
            "details": "Add GET /health/live route in server/src/index.ts. Return simple JSON response {status: 'ok'} with 200 status code. No async checks, no database/redis/ml connectivity verification. This endpoint is for container orchestrators to verify the process is running.",
            "status": "pending",
            "testStrategy": "Unit test verifying /health/live returns 200 and {status: 'ok'}. Test that it responds even when database is down (unlike /health). Verify response time is <10ms.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create comprehensive health checks for ML service in Python",
            "description": "Implement /health and /health/live endpoints in ml-service FastAPI app with database, Redis, and model status checks",
            "dependencies": [
              4
            ],
            "details": "Update ml-service/app/main.py. Add /health/live endpoint returning {'status': 'ok'}. Enhance /health endpoint: 1) Database check using async db.execute('SELECT 1') with latency measurement, 2) Redis check using await redis_client.ping() with latency, 3) Model status check (healthy if model_loaded else unavailable). Set overall_status to 'healthy', 'degraded' (if Redis fails), or 'unhealthy' (if DB fails). Return 200 for healthy/degraded, 503 for unhealthy. Include version from settings.VERSION and timestamp.",
            "status": "pending",
            "testStrategy": "Unit tests with mocked database/redis clients. Integration tests with real connections. Test database failure: verify unhealthy status and 503. Test Redis failure: verify degraded status and 200. Test model not loaded: verify model check shows unavailable. Test /health/live returns ok regardless of dependencies.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Enhance backend /health endpoint to check database connectivity with Prisma and measure latency, 2) Add Redis connectivity check with proper error handling for optional dependency, 3) Add ML service reachability check from backend, 4) Implement /health/live liveness probe endpoint, 5) Create similar comprehensive health checks for ML service in Python with database and redis checks. Write tests for all health check scenarios.",
        "updatedAt": "2025-12-26T10:19:35.180Z"
      },
      {
        "id": 22,
        "title": "Create GitHub Actions Test Workflow Enhancement",
        "description": "Enhance the existing CI workflow to improve caching, add security scanning, and prepare for the build workflow integration.",
        "details": "**Update `.github/workflows/ci.yml` to enhance existing workflow:**\n\nAdd security scanning job after existing jobs:\n```yaml\n  security-scan:\n    name: Security Scan\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n          cache: 'npm'\n\n      - name: Run npm audit (root)\n        run: npm audit --audit-level=high || true\n        continue-on-error: true\n\n      - name: Run npm audit (server)\n        run: cd server && npm audit --audit-level=high || true\n        continue-on-error: true\n\n      - name: Setup Python for ML service scan\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Run safety check (ML service)\n        run: |\n          pip install safety\n          cd ml-service && safety check -r requirements.txt || true\n        continue-on-error: true\n\n      - name: Run Trivy vulnerability scanner\n        uses: aquasecurity/trivy-action@master\n        with:\n          scan-type: 'fs'\n          scan-ref: '.'\n          severity: 'CRITICAL,HIGH'\n          exit-code: '0'  # Don't fail build, just report\n```\n\nUpdate ci-success job to include security-scan:\n```yaml\n  ci-success:\n    name: CI Success\n    runs-on: ubuntu-latest\n    needs: [lint, backend-tests, mobile-tests, ml-service-lint, security-scan]\n    if: always()\n    steps:\n      - name: Check all jobs\n        run: |\n          if [[ \"${{ needs.lint.result }}\" != \"success\" ]] || \\\n             [[ \"${{ needs.backend-tests.result }}\" != \"success\" ]] || \\\n             [[ \"${{ needs.mobile-tests.result }}\" != \"success\" ]] || \\\n             [[ \"${{ needs.ml-service-lint.result }}\" != \"success\" ]]; then\n            echo \"One or more jobs failed!\"\n            exit 1\n          fi\n          # Security scan is informational, don't fail on it\n          echo \"All required CI jobs passed!\"\n```\n\n**Add caching improvements for backend tests:**\n```yaml\n      - name: Cache Prisma client\n        uses: actions/cache@v4\n        with:\n          path: server/node_modules/.prisma\n          key: prisma-${{ runner.os }}-${{ hashFiles('server/prisma/schema.prisma') }}\n```",
        "testStrategy": "1. Create a PR and verify workflow runs\n2. Check security-scan job executes without blocking\n3. Verify caching works - second run should be faster\n4. Check Trivy reports in workflow output\n5. Verify npm audit runs for both root and server\n6. Confirm ci-success job still requires core jobs to pass",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add security-scan job with npm audit, safety check, and Trivy scanner",
            "description": "Create a new security-scan job in .github/workflows/ci.yml that runs after existing jobs. Include npm audit for root and server directories, safety check for ML service Python dependencies, and Trivy filesystem vulnerability scanner.",
            "dependencies": [],
            "details": "Add a new job to .github/workflows/ci.yml after ml-service-lint job:\n\n1. Configure job to run on ubuntu-latest\n2. Checkout code using actions/checkout@v4\n3. Setup Node.js using actions/setup-node@v4 with cache: 'npm'\n4. Run npm audit for root directory with --audit-level=high, use continue-on-error: true\n5. Run npm audit for server directory with --audit-level=high, use continue-on-error: true\n6. Setup Python 3.11 using actions/setup-python@v5\n7. Install safety package and run safety check on ml-service/requirements.txt with continue-on-error: true\n8. Add Trivy vulnerability scanner using aquasecurity/trivy-action@master with scan-type: 'fs', scan-ref: '.', severity: 'CRITICAL,HIGH', and exit-code: '0'\n\nAll security checks should be informational only (not fail the build) using continue-on-error or exit-code: '0'.",
            "status": "pending",
            "testStrategy": "1. Push changes and verify security-scan job appears in workflow run\n2. Check npm audit executes for both root and server directories\n3. Verify safety check runs on ML service requirements\n4. Confirm Trivy scanner produces vulnerability report in workflow output\n5. Test that security issues don't block the workflow (continue-on-error works)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Prisma client caching to backend-tests job",
            "description": "Enhance the backend-tests job with Prisma client caching to improve CI performance by avoiding regeneration of Prisma client on subsequent runs when schema hasn't changed.",
            "dependencies": [],
            "details": "Update the backend-tests job in .github/workflows/ci.yml:\n\n1. Add a new step after Node.js setup and before dependency installation\n2. Use actions/cache@v4 to cache Prisma client\n3. Set cache path to 'server/node_modules/.prisma'\n4. Use cache key format: prisma-${{ runner.os }}-${{ hashFiles('server/prisma/schema.prisma') }}\n5. This ensures cache is invalidated only when schema.prisma changes\n\nThe caching step should be positioned strategically to maximize reuse while ensuring Prisma client is available for tests.",
            "status": "pending",
            "testStrategy": "1. Push changes and trigger workflow twice\n2. On second run, verify 'Cache Prisma client' step shows cache hit\n3. Compare backend-tests job duration between first run (cache miss) and second run (cache hit)\n4. Verify tests still pass with cached Prisma client\n5. Modify schema.prisma and confirm cache is invalidated (new cache key generated)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update ci-success job to include security-scan dependency",
            "description": "Modify the ci-success job to include security-scan in its needs array while ensuring it doesn't fail the build. Security scan results should be informational only.",
            "dependencies": [
              1
            ],
            "details": "Update the ci-success job in .github/workflows/ci.yml:\n\n1. Add 'security-scan' to the needs array: [lint, backend-tests, mobile-tests, ml-service-lint, security-scan]\n2. Keep if: always() condition to ensure job runs even if security-scan has issues\n3. Update the check script to only verify core jobs (lint, backend-tests, mobile-tests, ml-service-lint) succeeded\n4. Do NOT check security-scan result in the failure logic\n5. Add a comment in the success echo statement noting that security scan is informational\n6. Ensure the job still returns exit code 1 if any core jobs fail, but ignores security-scan status\n\nThis makes security-scan visible in the workflow without blocking merges.",
            "status": "pending",
            "testStrategy": "1. Create PR and verify workflow runs with all jobs including security-scan\n2. Verify ci-success job waits for security-scan to complete\n3. Confirm ci-success passes even if security-scan finds issues\n4. Test that ci-success fails if core jobs (lint, backend-tests, etc.) fail\n5. Check workflow summary shows security-scan results but doesn't block PR\n6. Verify final success message acknowledges all required jobs passed",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split into: 1) Add security-scan job with npm audit for both root and server, safety check for ML service, and Trivy filesystem scanner, 2) Add Prisma client caching to backend-tests job to improve performance, 3) Update ci-success job dependencies to include security-scan (informational only, don't fail build on security issues). Test that workflow runs successfully with all checks.",
        "updatedAt": "2025-12-26T10:19:35.261Z"
      },
      {
        "id": 23,
        "title": "Create GitHub Actions Build and Push Workflow",
        "description": "Create a new workflow that builds Docker images for backend and ML service, scans them for vulnerabilities, and pushes to GitHub Container Registry on merge to main.",
        "details": "**Create `.github/workflows/build.yml`:**\n```yaml\nname: Build and Push\n\non:\n  push:\n    branches: [master]\n  workflow_dispatch:  # Allow manual trigger\n\nenv:\n  REGISTRY: ghcr.io\n  BACKEND_IMAGE: ghcr.io/${{ github.repository }}/backend\n  ML_SERVICE_IMAGE: ghcr.io/${{ github.repository }}/ml-service\n\njobs:\n  build-backend:\n    name: Build Backend\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ${{ env.BACKEND_IMAGE }}\n          tags: |\n            type=sha,prefix=\n            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/master' }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v5\n        with:\n          context: ./server\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n\n      - name: Run Trivy vulnerability scanner\n        uses: aquasecurity/trivy-action@master\n        with:\n          image-ref: ${{ env.BACKEND_IMAGE }}:${{ github.sha }}\n          format: 'sarif'\n          output: 'trivy-backend.sarif'\n          severity: 'CRITICAL,HIGH'\n\n      - name: Upload Trivy scan results\n        uses: github/codeql-action/upload-sarif@v3\n        if: always()\n        with:\n          sarif_file: 'trivy-backend.sarif'\n\n    outputs:\n      image: ${{ env.BACKEND_IMAGE }}\n      digest: ${{ steps.meta.outputs.digest }}\n\n  build-ml-service:\n    name: Build ML Service\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ${{ env.ML_SERVICE_IMAGE }}\n          tags: |\n            type=sha,prefix=\n            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/master' }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v5\n        with:\n          context: ./ml-service\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n\n      - name: Run Trivy vulnerability scanner\n        uses: aquasecurity/trivy-action@master\n        with:\n          image-ref: ${{ env.ML_SERVICE_IMAGE }}:${{ github.sha }}\n          format: 'sarif'\n          output: 'trivy-ml.sarif'\n          severity: 'CRITICAL,HIGH'\n\n      - name: Upload Trivy scan results\n        uses: github/codeql-action/upload-sarif@v3\n        if: always()\n        with:\n          sarif_file: 'trivy-ml.sarif'\n\n    outputs:\n      image: ${{ env.ML_SERVICE_IMAGE }}\n      digest: ${{ steps.meta.outputs.digest }}\n\n  build-success:\n    name: Build Success\n    runs-on: ubuntu-latest\n    needs: [build-backend, build-ml-service]\n    steps:\n      - name: Summary\n        run: |\n          echo \"## Build Summary\" >> $GITHUB_STEP_SUMMARY\n          echo \"\" >> $GITHUB_STEP_SUMMARY\n          echo \"✅ Backend Image: \\`${{ needs.build-backend.outputs.image }}:${{ github.sha }}\\`\" >> $GITHUB_STEP_SUMMARY\n          echo \"✅ ML Service Image: \\`${{ needs.build-ml-service.outputs.image }}:${{ github.sha }}\\`\" >> $GITHUB_STEP_SUMMARY\n```",
        "testStrategy": "1. Push to master branch and verify workflow triggers\n2. Check images appear in GitHub Packages\n3. Verify image tags include SHA and 'latest'\n4. Check Trivy scan results in Security tab\n5. Pull and run images locally to verify they work\n6. Test manual workflow_dispatch trigger\n7. Verify build time <10 minutes with caching",
        "priority": "high",
        "dependencies": [
          "18",
          "19"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create build.yml workflow file with triggers and environment configuration",
            "description": "Create the initial `.github/workflows/build.yml` file with workflow triggers (push to master branch and workflow_dispatch), and define environment variables for GitHub Container Registry (GHCR) and image names.",
            "dependencies": [],
            "details": "Create `.github/workflows/build.yml` with:\n- Workflow name: 'Build and Push'\n- Triggers: `on.push.branches: [master]` and `on.workflow_dispatch` for manual runs\n- Environment variables: REGISTRY (ghcr.io), BACKEND_IMAGE, ML_SERVICE_IMAGE using `${{ github.repository }}` for dynamic repo name\n- Ensure proper YAML formatting and indentation\n\nThis establishes the workflow foundation that subsequent jobs will build upon.",
            "status": "pending",
            "testStrategy": "Verify workflow file syntax with `actionlint` or GitHub's workflow validator. Check that file is properly placed in `.github/workflows/` directory. Confirm environment variable interpolation is correct.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement build-backend job with Docker Buildx and GHCR authentication",
            "description": "Create the build-backend job that sets up Docker Buildx, authenticates with GitHub Container Registry, extracts metadata for image tagging, and builds/pushes the backend Docker image with layer caching.",
            "dependencies": [
              1
            ],
            "details": "Add build-backend job with:\n- Job permissions: `contents: read`, `packages: write`\n- Steps: checkout@v4, setup-buildx-action@v3, login-action@v3 (using GITHUB_TOKEN)\n- metadata-action@v5 for tags: SHA prefix and latest (conditional on master branch)\n- build-push-action@v5 with context: ./server, push: true, GitHub Actions cache (type=gha)\n- Job outputs: image name and digest from metadata step\n\nReferences Task 18 (Backend Dockerfile) which must exist at ./server/Dockerfile.",
            "status": "pending",
            "testStrategy": "Push to master and verify: 1) Buildx setup succeeds, 2) GHCR login succeeds, 3) Image builds and pushes to ghcr.io, 4) Image has both SHA and latest tags, 5) Cache is utilized on subsequent runs (check build time improvement).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement build-ml-service job with same Docker build pattern",
            "description": "Create the build-ml-service job that mirrors the backend build process but targets the ML service, running in parallel with the backend build job.",
            "dependencies": [
              1
            ],
            "details": "Add build-ml-service job (parallel to build-backend) with:\n- Same permissions and step structure as build-backend\n- Context changed to: ./ml-service\n- Image metadata using ML_SERVICE_IMAGE environment variable\n- Same tagging strategy (SHA + latest on master)\n- Same caching strategy (GitHub Actions cache)\n- Job outputs: ML service image name and digest\n\nReferences Task 19 (ML Service Dockerfile) which must exist at ./ml-service/Dockerfile.",
            "status": "pending",
            "testStrategy": "Push to master and verify: 1) Both jobs run in parallel (check workflow timeline), 2) ML service image builds successfully, 3) Image pushed to ghcr.io with correct tags, 4) Build completes even if backend job is still running.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Trivy vulnerability scanning with SARIF upload for both images",
            "description": "Integrate Trivy security scanning into both build jobs to scan Docker images for CRITICAL and HIGH severity vulnerabilities, output results in SARIF format, and upload to GitHub Security tab via CodeQL action.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add to both build-backend and build-ml-service jobs:\n- trivy-action@master step after build-push\n- Scan image-ref using SHA tag: `${{ env.*_IMAGE }}:${{ github.sha }}`\n- Output format: 'sarif', severity filter: 'CRITICAL,HIGH'\n- Separate output files: trivy-backend.sarif and trivy-ml.sarif\n- codeql-action/upload-sarif@v3 with `if: always()` to upload even on scan failures\n- Ensure SARIF files are uploaded to GitHub Security tab for vulnerability tracking",
            "status": "pending",
            "testStrategy": "After workflow runs: 1) Check Security tab for Trivy scan results, 2) Verify SARIF files are uploaded even if vulnerabilities found, 3) Confirm only CRITICAL/HIGH severities reported, 4) Test with known vulnerable base image to ensure scanner detects issues.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create build-success summary job with image output reporting",
            "description": "Implement the final build-success job that depends on both build jobs completing successfully and outputs a formatted summary of built images with their tags and digests to the GitHub Actions summary.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add build-success job with:\n- Depends on: [build-backend, build-ml-service] using `needs`\n- Single step that writes to $GITHUB_STEP_SUMMARY\n- Output format: Markdown with build summary header\n- Display both image names with SHA tags using job outputs: `${{ needs.build-backend.outputs.image }}:${{ github.sha }}`\n- Include digest information from metadata outputs\n- Use checkmark emojis (✅) for visual clarity\n\nThis provides clear deployment information for the subsequent deploy workflow (Task 24).",
            "status": "pending",
            "testStrategy": "After successful workflow run: 1) Verify build-success job only runs if both builds succeed, 2) Check workflow summary displays formatted output with correct image tags, 3) Test failure scenario by breaking one build job - confirm summary job doesn't run, 4) Verify image tags match actual pushed images in GHCR.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Create build.yml workflow with triggers (push to master, workflow_dispatch), 2) Implement build-backend job with Docker Buildx, GHCR authentication, metadata extraction, and caching, 3) Implement build-ml-service job with same pattern, 4) Add Trivy vulnerability scanning for both images with SARIF output and GitHub Security integration, 5) Create build-success summary job that outputs image tags and digests. Test workflow with actual push to master.",
        "updatedAt": "2025-12-18T08:54:50.236Z"
      },
      {
        "id": 24,
        "title": "Create GitHub Actions Deploy Workflow",
        "description": "Create a deployment workflow that triggers Coolify webhook after successful build, verifies deployment health, and sends notifications.",
        "details": "**Create `.github/workflows/deploy.yml`:**\n```yaml\nname: Deploy\n\non:\n  workflow_run:\n    workflows: [\"Build and Push\"]\n    types: [completed]\n    branches: [master]\n  workflow_dispatch:  # Manual trigger for rollback\n    inputs:\n      image_tag:\n        description: 'Image tag to deploy (default: latest)'\n        required: false\n        default: 'latest'\n\njobs:\n  deploy:\n    name: Deploy to Production\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Trigger Coolify Backend Deployment\n        id: deploy-backend\n        run: |\n          response=$(curl -s -w \"\\n%{http_code}\" -X POST \\\n            -H \"Authorization: Bearer ${{ secrets.COOLIFY_WEBHOOK_SECRET }}\" \\\n            \"${{ secrets.COOLIFY_BACKEND_WEBHOOK_URL }}\")\n          http_code=$(echo \"$response\" | tail -n1)\n          body=$(echo \"$response\" | sed '$d')\n          echo \"HTTP Status: $http_code\"\n          echo \"Response: $body\"\n          if [ \"$http_code\" != \"200\" ] && [ \"$http_code\" != \"201\" ]; then\n            echo \"Backend deployment trigger failed!\"\n            exit 1\n          fi\n\n      - name: Trigger Coolify ML Service Deployment\n        id: deploy-ml\n        run: |\n          response=$(curl -s -w \"\\n%{http_code}\" -X POST \\\n            -H \"Authorization: Bearer ${{ secrets.COOLIFY_WEBHOOK_SECRET }}\" \\\n            \"${{ secrets.COOLIFY_ML_WEBHOOK_URL }}\")\n          http_code=$(echo \"$response\" | tail -n1)\n          body=$(echo \"$response\" | sed '$d')\n          echo \"HTTP Status: $http_code\"\n          echo \"Response: $body\"\n          if [ \"$http_code\" != \"200\" ] && [ \"$http_code\" != \"201\" ]; then\n            echo \"ML service deployment trigger failed!\"\n            exit 1\n          fi\n\n      - name: Wait for deployment\n        run: sleep 60  # Wait for containers to start\n\n      - name: Verify Backend Health\n        id: health-backend\n        run: |\n          for i in {1..10}; do\n            response=$(curl -s -o /dev/null -w \"%{http_code}\" \\\n              --connect-timeout 5 \\\n              --max-time 10 \\\n              \"${{ secrets.PRODUCTION_API_URL }}/health\" || echo \"000\")\n            echo \"Attempt $i: HTTP $response\"\n            if [ \"$response\" = \"200\" ]; then\n              echo \"Backend is healthy!\"\n              exit 0\n            fi\n            sleep 10\n          done\n          echo \"Backend health check failed!\"\n          exit 1\n\n      - name: Send Success Notification\n        if: success()\n        run: |\n          curl -X POST \"${{ secrets.DISCORD_WEBHOOK_URL }}\" \\\n            -H \"Content-Type: application/json\" \\\n            -d '{\n              \"embeds\": [{\n                \"title\": \"✅ Deployment Successful\",\n                \"description\": \"Nutri has been deployed to production\",\n                \"color\": 5763719,\n                \"fields\": [\n                  {\"name\": \"Commit\", \"value\": \"'\"${{ github.sha }}\"'\", \"inline\": true},\n                  {\"name\": \"Branch\", \"value\": \"master\", \"inline\": true}\n                ],\n                \"timestamp\": \"'\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"'\"\n              }]\n            }' || true\n\n      - name: Send Failure Notification\n        if: failure()\n        run: |\n          curl -X POST \"${{ secrets.DISCORD_WEBHOOK_URL }}\" \\\n            -H \"Content-Type: application/json\" \\\n            -d '{\n              \"embeds\": [{\n                \"title\": \"❌ Deployment Failed\",\n                \"description\": \"Nutri deployment to production failed\",\n                \"color\": 15548997,\n                \"fields\": [\n                  {\"name\": \"Commit\", \"value\": \"'\"${{ github.sha }}\"'\", \"inline\": true},\n                  {\"name\": \"Action\", \"value\": \"[View Logs]('\"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"')\", \"inline\": true}\n                ],\n                \"timestamp\": \"'\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"'\"\n              }]\n            }' || true\n```\n\n**Required GitHub Secrets:**\n- COOLIFY_WEBHOOK_SECRET\n- COOLIFY_BACKEND_WEBHOOK_URL\n- COOLIFY_ML_WEBHOOK_URL\n- PRODUCTION_API_URL\n- DISCORD_WEBHOOK_URL (optional)",
        "testStrategy": "1. Set up test Coolify webhook URLs\n2. Add required secrets to GitHub repository\n3. Trigger workflow manually with workflow_dispatch\n4. Verify Coolify receives webhook calls\n5. Test health check retry logic\n6. Verify Discord notifications are sent\n7. Test failure notification by using invalid webhook URL\n8. Test manual rollback trigger with specific image tag",
        "priority": "high",
        "dependencies": [
          "23"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create deploy.yml with workflow triggers and inputs",
            "description": "Create `.github/workflows/deploy.yml` with workflow_run trigger listening to 'Build and Push' workflow completion, and workflow_dispatch for manual deployments with image_tag input parameter.",
            "dependencies": [],
            "details": "Set up the workflow file with two trigger types: 1) workflow_run that triggers on successful completion of 'Build and Push' workflow on master branch, 2) workflow_dispatch with optional image_tag input (default: 'latest'). Configure the deploy job to run on ubuntu-latest and only execute if the workflow_run was successful OR if manually triggered. This establishes the foundation for the deployment workflow.",
            "status": "pending",
            "testStrategy": "Verify workflow file syntax with `actionlint .github/workflows/deploy.yml`, check that workflow appears in GitHub Actions UI, test manual trigger via workflow_dispatch to ensure input parameter is captured correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Coolify webhook triggers with authentication",
            "description": "Add steps to trigger Coolify webhooks for both backend and ML service deployments with proper authentication headers and response validation.",
            "dependencies": [
              1
            ],
            "details": "Create two separate steps using curl to POST to Coolify webhook URLs with Authorization Bearer token from COOLIFY_WEBHOOK_SECRET. Capture both HTTP status code and response body using `-s -w \"\\n%{http_code}\"`. Validate that responses are 200 or 201, otherwise fail the workflow. Add echo statements for debugging. Structure: COOLIFY_BACKEND_WEBHOOK_URL first, then COOLIFY_ML_WEBHOOK_URL. Include proper error messages if triggers fail.",
            "status": "pending",
            "testStrategy": "Test with mock webhook endpoints (webhook.site or similar) to verify request format and headers, validate error handling by testing with invalid URLs, confirm both backend and ML service triggers execute in sequence.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add deployment wait period and health check with retry logic",
            "description": "Implement a 60-second wait period followed by backend health check verification with 10 retry attempts and exponential backoff.",
            "dependencies": [
              2
            ],
            "details": "Add sleep 60 step to allow containers to start. Create health check step that polls PRODUCTION_API_URL/health endpoint up to 10 times with 10-second intervals. Use curl with --connect-timeout 5 and --max-time 10 flags. Handle connection failures by defaulting to '000' status code. Exit with success (0) on first 200 response, or fail (1) after all retries exhausted. Include iteration counter in echo output for debugging.",
            "status": "pending",
            "testStrategy": "Test health check logic locally with a mock endpoint that returns 503 for first 3 attempts then 200, verify timeout handling by testing against a non-responsive endpoint, confirm retry loop exits immediately on success.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Discord notification integration for deployment status",
            "description": "Add success and failure notification steps that send rich embed messages to Discord webhook with deployment details and links.",
            "dependencies": [
              3
            ],
            "details": "Create two conditional notification steps: 1) Success notification (if: success()) with green embed (color: 5763719) showing ✅ title, commit SHA, branch, and timestamp, 2) Failure notification (if: failure()) with red embed (color: 15548997) showing ❌ title, commit SHA, and link to workflow run logs. Use curl to POST JSON payloads to DISCORD_WEBHOOK_URL. Include `|| true` to prevent notification failures from affecting workflow status. Format timestamp using `date -u +%Y-%m-%dT%H:%M:%SZ`.",
            "status": "pending",
            "testStrategy": "Send test notifications to Discord webhook during development, verify embed formatting and colors display correctly, test that notification failures don't break the workflow (|| true works), validate that GitHub links in failure messages are clickable and correct.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configure required GitHub repository secrets",
            "description": "Document and configure all required GitHub secrets: COOLIFY_WEBHOOK_SECRET, COOLIFY_BACKEND_WEBHOOK_URL, COOLIFY_ML_WEBHOOK_URL, PRODUCTION_API_URL, and DISCORD_WEBHOOK_URL.",
            "dependencies": [],
            "details": "Create a secrets checklist and add placeholder values to GitHub repository settings. Required secrets: 1) COOLIFY_WEBHOOK_SECRET - Bearer token for Coolify authentication, 2) COOLIFY_BACKEND_WEBHOOK_URL - Full webhook URL for backend deployment, 3) COOLIFY_ML_WEBHOOK_URL - Full webhook URL for ML service, 4) PRODUCTION_API_URL - Base URL for health checks (e.g., https://api.nutri.com), 5) DISCORD_WEBHOOK_URL - Discord webhook endpoint (optional but recommended). Document these in deployment docs and ensure they're referenced correctly in workflow file.",
            "status": "pending",
            "testStrategy": "Verify all secrets are accessible in workflow by adding debug steps that echo masked values (first 4 chars only), test with intentionally incorrect secrets to ensure proper error messages, confirm DISCORD_WEBHOOK_URL is truly optional (workflow succeeds without it).",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "End-to-end workflow testing with actual Coolify deployment",
            "description": "Test the complete deployment workflow with real Coolify webhooks, verify health checks, monitor deployment process, and validate notifications.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Execute full workflow test: 1) Merge a test PR to trigger 'Build and Push' workflow, 2) Verify deploy workflow triggers automatically on completion, 3) Monitor Coolify for webhook reception and deployment start, 4) Watch health check retries in action logs, 5) Verify Discord success notification, 6) Test manual rollback using workflow_dispatch with previous image tag, 7) Test failure scenario by temporarily breaking health endpoint or using invalid webhook URL, 8) Confirm failure notification is sent. Document any issues and iterations needed.",
            "status": "pending",
            "testStrategy": "Run complete workflow in production environment, verify Coolify deploys correct container versions, confirm health checks pass within expected timeframe (60s + retries), validate both success and failure notifications appear in Discord, test manual trigger with specific image tags, check GitHub Actions logs for any errors or warnings.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Divide into: 1) Create deploy.yml with workflow_run trigger from 'Build and Push' workflow and manual trigger with image_tag input, 2) Implement Coolify webhook triggers for both backend and ML service with authentication, 3) Add wait period and health check verification with retry logic for backend, 4) Implement Discord/notification integration for success and failure cases, 5) Configure required GitHub secrets (COOLIFY_WEBHOOK_SECRET, COOLIFY_BACKEND_WEBHOOK_URL, COOLIFY_ML_WEBHOOK_URL, PRODUCTION_API_URL, DISCORD_WEBHOOK_URL), 6) Test workflow with actual Coolify webhooks and verify deployment health.",
        "updatedAt": "2025-12-18T08:55:37.663Z"
      },
      {
        "id": 25,
        "title": "Create Database Migration Workflow",
        "description": "Implement a safe database migration process that runs Prisma migrations as part of deployment with backup and rollback capabilities.",
        "details": "**Create `.github/workflows/migrate.yml`:**\n```yaml\nname: Database Migration\n\non:\n  workflow_dispatch:\n    inputs:\n      dry_run:\n        description: 'Dry run (show changes without applying)'\n        required: true\n        default: 'true'\n        type: choice\n        options:\n          - 'true'\n          - 'false'\n\njobs:\n  migrate:\n    name: Run Migrations\n    runs-on: ubuntu-latest\n    environment: production  # Requires approval\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: cd server && npm ci\n\n      - name: Generate Prisma client\n        run: cd server && npx prisma generate\n\n      - name: Show pending migrations (Dry Run)\n        if: inputs.dry_run == 'true'\n        env:\n          DATABASE_URL: ${{ secrets.DATABASE_URL }}\n        run: |\n          cd server\n          npx prisma migrate status\n          echo \"---\"\n          echo \"Pending migrations preview:\"\n          npx prisma migrate diff --from-migrations ./prisma/migrations --to-schema-datamodel ./prisma/schema.prisma\n\n      - name: Run migrations\n        if: inputs.dry_run == 'false'\n        env:\n          DATABASE_URL: ${{ secrets.DATABASE_URL }}\n        run: |\n          cd server\n          echo \"Running migrations...\"\n          npx prisma migrate deploy\n          echo \"Migration complete!\"\n          npx prisma migrate status\n\n      - name: Notify on success\n        if: success() && inputs.dry_run == 'false'\n        run: |\n          curl -X POST \"${{ secrets.DISCORD_WEBHOOK_URL }}\" \\\n            -H \"Content-Type: application/json\" \\\n            -d '{\"content\": \"✅ Database migration completed successfully\"}' || true\n\n      - name: Notify on failure\n        if: failure()\n        run: |\n          curl -X POST \"${{ secrets.DISCORD_WEBHOOK_URL }}\" \\\n            -H \"Content-Type: application/json\" \\\n            -d '{\"content\": \"❌ Database migration failed! Check GitHub Actions logs.\"}' || true\n```\n\n**Create migration helper script `scripts/deploy/migrate.sh`:**\n```bash\n#!/bin/bash\nset -e\n\necho \"=== Nutri Database Migration ===\"\necho \"Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\necho \"\"\n\n# Check if DATABASE_URL is set\nif [ -z \"$DATABASE_URL\" ]; then\n    echo \"Error: DATABASE_URL environment variable is not set\"\n    exit 1\nfi\n\n# Navigate to server directory\ncd \"$(dirname \"$0\")/../../server\"\n\n# Show current status\necho \"Current migration status:\"\nnpx prisma migrate status\necho \"\"\n\n# Parse arguments\nDRY_RUN=true\nif [ \"$1\" = \"--apply\" ]; then\n    DRY_RUN=false\nfi\n\nif [ \"$DRY_RUN\" = true ]; then\n    echo \"DRY RUN MODE - showing changes without applying\"\n    echo \"Run with --apply to execute migrations\"\n    echo \"\"\n    echo \"Pending changes:\"\n    npx prisma migrate diff --from-migrations ./prisma/migrations --to-schema-datamodel ./prisma/schema.prisma || true\nelse\n    echo \"APPLYING MIGRATIONS...\"\n    npx prisma migrate deploy\n    echo \"\"\n    echo \"Migration complete. New status:\"\n    npx prisma migrate status\nfi\n```\n\n**Update deploy workflow to include migration step:**\nAdd before deployment triggers:\n```yaml\n      - name: Run database migrations\n        env:\n          DATABASE_URL: ${{ secrets.DATABASE_URL }}\n        run: |\n          cd server\n          npm ci\n          npx prisma generate\n          npx prisma migrate deploy\n```",
        "testStrategy": "1. Test dry run mode shows pending migrations without applying\n2. Test migrate deploy in staging environment\n3. Verify migration rollback with Prisma migrate down (manual)\n4. Test migration failure handling (create intentionally failing migration)\n5. Verify environment protection requires approval\n6. Test notification webhooks\n7. Run migration with no pending changes (should be no-op)",
        "priority": "high",
        "dependencies": [
          "21"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create GitHub Actions migrate.yml workflow file",
            "description": "Create `.github/workflows/migrate.yml` with workflow_dispatch trigger, dry_run input parameter (choice: true/false), and production environment configuration.",
            "dependencies": [],
            "details": "Set up the workflow structure with:\n- `workflow_dispatch` trigger with `dry_run` input (boolean choice, default: 'true')\n- Job named `migrate` running on `ubuntu-latest`\n- Environment set to `production` for approval requirement\n- Steps for checkout, Node.js 20 setup with npm cache\n- Dependencies installation: `cd server && npm ci`\n- Prisma client generation: `cd server && npx prisma generate`\n\nReference existing workflows in `.github/workflows/` for consistency with project patterns. Ensure DATABASE_URL is read from secrets.",
            "status": "pending",
            "testStrategy": "1. Push workflow file to repository\n2. Navigate to Actions tab and manually trigger workflow\n3. Verify dry_run parameter appears with true/false options\n4. Confirm production environment protection is active (should require approval)\n5. Test with dry_run=true first (safe mode)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement dry run mode in migrate workflow",
            "description": "Add workflow steps that show pending migrations without applying them when dry_run=true using Prisma migrate status and migrate diff commands.",
            "dependencies": [
              1
            ],
            "details": "Add conditional step with `if: inputs.dry_run == 'true'`:\n- Run `npx prisma migrate status` to show current migration state\n- Run `npx prisma migrate diff --from-migrations ./prisma/migrations --to-schema-datamodel ./prisma/schema.prisma` to preview pending changes\n- Include clear output formatting with echo statements\n- Set DATABASE_URL from secrets: `${{ secrets.DATABASE_URL }}`\n\nThis step must execute in the `server` directory and handle cases where no migrations are pending gracefully.",
            "status": "pending",
            "testStrategy": "1. Create a test schema change in server/prisma/schema.prisma\n2. Trigger workflow with dry_run=true\n3. Verify output shows pending migrations without applying\n4. Confirm DATABASE_URL connection works\n5. Check that no actual database changes occurred",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement migration execution step with error handling",
            "description": "Add workflow step that runs actual migrations when dry_run=false using Prisma migrate deploy with proper error handling and status reporting.",
            "dependencies": [
              2
            ],
            "details": "Add conditional step with `if: inputs.dry_run == 'false'`:\n- Run `npx prisma migrate deploy` to apply migrations\n- Include pre-execution echo: \"Running migrations...\"\n- Post-execution confirmation: \"Migration complete!\"\n- Run `npx prisma migrate status` after deployment to verify\n- Set DATABASE_URL from secrets\n- Ensure proper error propagation (set -e behavior)\n\nExecute in `server` directory. The step should fail the workflow if migration fails, triggering failure notifications.",
            "status": "pending",
            "testStrategy": "1. Set up test database with DATABASE_URL secret\n2. Create a valid migration in server/prisma/migrations/\n3. Trigger workflow with dry_run=false\n4. Verify migration applies successfully\n5. Check migration status shows all migrations applied\n6. Test with invalid migration to confirm error handling works",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Discord notification steps to migrate workflow",
            "description": "Implement success and failure notification steps that send messages to Discord webhook for migration results.",
            "dependencies": [
              3
            ],
            "details": "Add two notification steps:\n\n**Success notification** (`if: success() && inputs.dry_run == 'false'`):\n- POST to `${{ secrets.DISCORD_WEBHOOK_URL }}`\n- Message: \"✅ Database migration completed successfully\"\n- Include `|| true` to prevent notification failures from failing workflow\n\n**Failure notification** (`if: failure()`):\n- POST to `${{ secrets.DISCORD_WEBHOOK_URL }}`\n- Message: \"❌ Database migration failed! Check GitHub Actions logs.\"\n- Include workflow run URL if possible\n- Include `|| true` for graceful degradation\n\nUse curl with Content-Type: application/json.",
            "status": "pending",
            "testStrategy": "1. Set DISCORD_WEBHOOK_URL secret in repository\n2. Trigger successful migration (dry_run=false)\n3. Verify success message appears in Discord\n4. Create intentionally failing migration\n5. Trigger workflow and verify failure notification\n6. Test with invalid webhook URL to ensure workflow doesn't fail",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create migration helper script scripts/deploy/migrate.sh",
            "description": "Create bash script for manual migration execution with dry-run mode, status checking, and proper error handling for local and CI use.",
            "dependencies": [],
            "details": "Create `scripts/deploy/migrate.sh`:\n- Shebang: `#!/bin/bash` with `set -e`\n- Header with timestamp: `date -u +%Y-%m-%dT%H:%M:%SZ`\n- Check DATABASE_URL is set (exit 1 if missing)\n- Navigate to server directory: `cd \"$(dirname \"$0\")/../../server\"`\n- Show current status: `npx prisma migrate status`\n- Parse `--apply` argument (default: dry run)\n- Dry run: show pending changes with `prisma migrate diff`\n- Apply mode: run `npx prisma migrate deploy` and show final status\n- Make executable: `chmod +x scripts/deploy/migrate.sh`\n\nFollows pattern from deployment-infrastructure-prd.md example.",
            "status": "pending",
            "testStrategy": "1. Run `./scripts/deploy/migrate.sh` without DATABASE_URL (should error)\n2. Export test DATABASE_URL\n3. Run `./scripts/deploy/migrate.sh` (dry run) - should show status\n4. Create test migration\n5. Run `./scripts/deploy/migrate.sh --apply` (should apply)\n6. Verify migration was applied: `cd server && npx prisma migrate status`",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Integrate migration step into deploy workflow",
            "description": "Add database migration execution to the deployment workflow (.github/workflows/deploy.yml) before application deployment triggers.",
            "dependencies": [
              1,
              3,
              5
            ],
            "details": "Update `.github/workflows/deploy.yml` (created in task 24):\n- Add migration step after checkout/setup, before Coolify webhook\n- Position: after Node.js setup, before deployment trigger\n- Step name: \"Run database migrations\"\n- Set DATABASE_URL from secrets\n- Commands:\n  ```\n  cd server\n  npm ci\n  npx prisma generate\n  npx prisma migrate deploy\n  ```\n- Ensure this step fails the workflow if migrations fail\n- Add comment explaining this runs before deployment\n\nReference task 24 implementation for integration point.",
            "status": "pending",
            "testStrategy": "1. Review task 24's deploy.yml structure\n2. Add migration step in correct position\n3. Create test migration in server/prisma/migrations/\n4. Trigger deploy workflow (manual dispatch)\n5. Verify migration runs before Coolify webhook\n6. Check logs show migration execution\n7. Confirm failed migration prevents deployment",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break down into: 1) Create migrate.yml workflow with workflow_dispatch trigger and dry_run parameter, 2) Configure production environment protection requiring approval, 3) Implement dry run mode that shows pending migrations without applying (prisma migrate status, prisma migrate diff), 4) Implement actual migration execution (prisma migrate deploy) with proper error handling, 5) Create migration helper script (scripts/deploy/migrate.sh) for manual execution, 6) Add Discord notifications and integrate migration step into deploy workflow. Test extensively with test database first.",
        "updatedAt": "2025-12-18T08:56:41.600Z"
      },
      {
        "id": 26,
        "title": "Implement Structured Logging for Backend",
        "description": "Add JSON structured logging to the Express backend with correlation IDs, proper log levels, and sensitive data redaction.",
        "details": "**Install dependencies in server/:**\n```bash\nnpm install pino pino-http @types/pino-http\n```\n\n**Create `server/src/config/logger.ts`:**\n```typescript\nimport pino from 'pino';\nimport { randomUUID } from 'crypto';\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport const logger = pino({\n  level: process.env.LOG_LEVEL || (isProduction ? 'info' : 'debug'),\n  formatters: {\n    level: (label) => ({ level: label }),\n  },\n  timestamp: pino.stdTimeFunctions.isoTime,\n  redact: {\n    paths: [\n      'req.headers.authorization',\n      'req.body.password',\n      'req.body.token',\n      'res.headers[\"set-cookie\"]',\n      '*.password',\n      '*.token',\n      '*.jwt',\n      '*.secret',\n    ],\n    censor: '[REDACTED]',\n  },\n  transport: isProduction ? undefined : {\n    target: 'pino-pretty',\n    options: {\n      colorize: true,\n      translateTime: 'SYS:standard',\n    },\n  },\n});\n\nexport const generateCorrelationId = (): string => randomUUID();\n\nexport type Logger = typeof logger;\n```\n\n**Create `server/src/middleware/requestLogger.ts`:**\n```typescript\nimport pinoHttp from 'pino-http';\nimport { logger, generateCorrelationId } from '../config/logger';\nimport { Request, Response } from 'express';\n\nexport const requestLogger = pinoHttp({\n  logger,\n  genReqId: (req: Request) => {\n    const existingId = req.headers['x-correlation-id'];\n    return (existingId as string) || generateCorrelationId();\n  },\n  customProps: (req: Request) => ({\n    correlationId: req.id,\n    service: 'nutri-backend',\n    environment: process.env.NODE_ENV,\n  }),\n  customLogLevel: (_req: Request, res: Response, err?: Error) => {\n    if (res.statusCode >= 500 || err) return 'error';\n    if (res.statusCode >= 400) return 'warn';\n    return 'info';\n  },\n  customSuccessMessage: (req: Request, res: Response) => {\n    return `${req.method} ${req.url} completed with ${res.statusCode}`;\n  },\n  customErrorMessage: (_req: Request, res: Response, err: Error) => {\n    return `Request failed: ${err.message}`;\n  },\n  serializers: {\n    req: (req) => ({\n      method: req.method,\n      url: req.url,\n      query: req.query,\n      params: req.params,\n      // Don't log body by default - too verbose\n    }),\n    res: (res) => ({\n      statusCode: res.statusCode,\n    }),\n  },\n});\n```\n\n**Update `server/src/index.ts`:**\n```typescript\nimport { requestLogger } from './middleware/requestLogger';\nimport { logger } from './config/logger';\n\n// Add after cors middleware\napp.use(requestLogger);\n\n// Update server start log\nif (process.env.NODE_ENV !== 'test') {\n  app.listen(PORT, () => {\n    logger.info({ port: PORT, env: config.nodeEnv }, 'Server started');\n  });\n}\n```\n\n**Update error handler to use logger:**\n```typescript\nimport { logger } from '../config/logger';\n\n// In errorHandler middleware:\nlogger.error({\n  err,\n  correlationId: req.id,\n  statusCode,\n  path: req.path,\n  method: req.method,\n}, 'Request error');\n```\n\n**Add pino-pretty for dev (devDependency):**\n```bash\nnpm install -D pino-pretty\n```",
        "testStrategy": "1. Start server and verify JSON log output in production mode\n2. Verify correlation ID appears in logs and response headers\n3. Test password/token redaction - should show [REDACTED]\n4. Verify log levels work (DEBUG shows more than INFO)\n5. Test error logging includes stack trace\n6. Verify pino-pretty works in development\n7. Test high-volume requests don't cause log overflow\n8. Verify logs are compatible with common log aggregators (JSON format)",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install pino dependencies and configure logger with redaction",
            "description": "Install pino, pino-http, @types/pino-http, and pino-pretty (dev). Create server/src/config/logger.ts with structured logging configuration including sensitive data redaction, correlation ID generation, and environment-based formatting.",
            "dependencies": [],
            "details": "Run `npm install pino pino-http @types/pino-http` and `npm install -D pino-pretty` in server/ directory. Create server/src/config/logger.ts implementing: pino instance with level based on LOG_LEVEL env var (default 'info' production, 'debug' development), ISO timestamp formatting, redaction paths for sensitive fields (authorization headers, password, token, jwt, secret fields), correlation ID generator using randomUUID from crypto, pino-pretty transport for development (colorized, human-readable), and export logger instance with TypeScript type. Test locally that logger initializes without errors.",
            "status": "pending",
            "testStrategy": "Verify pino packages are in package.json dependencies. Import logger in a test file and verify it doesn't throw errors. Check that redaction paths are correctly configured in the pino config object.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create requestLogger middleware with custom log levels",
            "description": "Implement pino-http middleware in server/src/middleware/requestLogger.ts that integrates structured logging with Express, handles correlation IDs from headers, and applies custom log levels based on HTTP status codes.",
            "dependencies": [
              1
            ],
            "details": "Create server/src/middleware/requestLogger.ts using pinoHttp from pino-http. Configure genReqId to extract x-correlation-id header or generate new UUID, add customProps with correlationId/service/environment metadata, implement customLogLevel function (500+ or error → 'error', 400-499 → 'warn', else 'info'), add customSuccessMessage and customErrorMessage formatters, configure serializers for req (method, url, query, params only) and res (statusCode only) to avoid verbose body logging. Export requestLogger middleware function.",
            "status": "pending",
            "testStrategy": "Unit test the middleware with mock req/res objects. Verify correlation ID is extracted from header or generated. Test that different status codes (200, 400, 500) produce correct log levels. Verify serializers omit sensitive data like request body.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate requestLogger into Express app and replace console.log",
            "description": "Update server/src/index.ts to use the requestLogger middleware and replace all console.log statements with structured logger calls throughout the backend codebase.",
            "dependencies": [
              2
            ],
            "details": "In server/src/index.ts: import requestLogger from './middleware/requestLogger' and logger from './config/logger', add app.use(requestLogger) after CORS middleware but before routes, replace server start console.log with logger.info({ port: PORT, env: config.nodeEnv }, 'Server started'). Search codebase for all console.log/console.error statements in server/src and replace with appropriate logger.info/logger.error/logger.warn/logger.debug calls. Verify NODE_ENV=production produces JSON logs and NODE_ENV=development produces colorized pino-pretty output.",
            "status": "pending",
            "testStrategy": "Start server in development mode and verify human-readable colorized logs. Set NODE_ENV=production and verify JSON structured output. Make test requests and confirm correlation IDs appear in logs. Verify no console.log statements remain in server/src (use grep to check).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update errorHandler middleware to use structured logging",
            "description": "Modify the existing error handling middleware in server/src/middleware/errorHandler.ts to use structured logging with correlation IDs, proper error serialization, and contextual request information.",
            "dependencies": [
              2
            ],
            "details": "In server/src/middleware/errorHandler.ts: import logger from '../config/logger', replace any console.error calls with logger.error(), include error object, correlationId (req.id), statusCode, path (req.path), method (req.method), and error message in log context. Ensure error stack traces are included in development but sanitized in production. Test with various error scenarios (validation errors, auth errors, 500 errors) to verify proper logging with correlation IDs. Verify sensitive data (passwords, tokens) are redacted even in error logs.",
            "status": "pending",
            "testStrategy": "Trigger various error scenarios (invalid input, unauthorized access, server errors) and verify structured error logs appear with correlation IDs. Check that error stack traces are present in development logs. Verify sensitive fields in error contexts are redacted. Test that correlation ID in error log matches the one from request log.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Split into: 1) Install pino, pino-http, and configure logger in server/src/config/logger.ts with proper redaction and correlation ID generation, 2) Create requestLogger middleware that integrates with existing Express app, logs requests/responses with custom log levels, 3) Update server/src/index.ts to use requestLogger and replace console.log with structured logger, 4) Update existing errorHandler middleware to use structured logging. Test that logs are JSON in production and human-readable in development.",
        "updatedAt": "2025-12-18T08:57:56.878Z"
      },
      {
        "id": 27,
        "title": "Implement Structured Logging for ML Service",
        "description": "Add JSON structured logging to the FastAPI ML service with correlation IDs, proper log levels, and sensitive data redaction.",
        "details": "**Update `ml-service/requirements.txt`:**\n```\nstructlog>=24.1.0\npython-json-logger>=2.0.7\n```\n\n**Create `ml-service/app/core/logging.py`:**\n```python\nimport structlog\nimport logging\nimport sys\nimport uuid\nfrom typing import Any\nfrom contextvars import ContextVar\n\n# Correlation ID context\ncorrelation_id_var: ContextVar[str] = ContextVar('correlation_id', default='')\n\ndef get_correlation_id() -> str:\n    return correlation_id_var.get() or str(uuid.uuid4())\n\ndef set_correlation_id(correlation_id: str) -> None:\n    correlation_id_var.set(correlation_id)\n\n# Sensitive data redaction\nSENSITIVE_KEYS = {'password', 'token', 'secret', 'authorization', 'api_key'}\n\ndef redact_sensitive_data(_, __, event_dict: dict) -> dict:\n    def redact(obj: Any) -> Any:\n        if isinstance(obj, dict):\n            return {\n                k: '[REDACTED]' if k.lower() in SENSITIVE_KEYS else redact(v)\n                for k, v in obj.items()\n            }\n        elif isinstance(obj, list):\n            return [redact(item) for item in obj]\n        return obj\n    \n    return redact(event_dict)\n\ndef add_service_context(_, __, event_dict: dict) -> dict:\n    event_dict['service'] = 'nutri-ml-service'\n    event_dict['correlation_id'] = get_correlation_id()\n    return event_dict\n\ndef configure_logging(environment: str = 'development') -> None:\n    processors = [\n        structlog.contextvars.merge_contextvars,\n        structlog.processors.add_log_level,\n        structlog.processors.TimeStamper(fmt='iso'),\n        add_service_context,\n        redact_sensitive_data,\n    ]\n    \n    if environment == 'production':\n        processors.append(structlog.processors.JSONRenderer())\n    else:\n        processors.append(structlog.dev.ConsoleRenderer())\n    \n    structlog.configure(\n        processors=processors,\n        wrapper_class=structlog.make_filtering_bound_logger(logging.INFO),\n        context_class=dict,\n        logger_factory=structlog.PrintLoggerFactory(),\n        cache_logger_on_first_use=True,\n    )\n\ndef get_logger(name: str = __name__) -> structlog.BoundLogger:\n    return structlog.get_logger(name)\n```\n\n**Create `ml-service/app/middleware/logging.py`:**\n```python\nimport time\nimport uuid\nfrom fastapi import Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom app.core.logging import get_logger, set_correlation_id, get_correlation_id\n\nlogger = get_logger(__name__)\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next) -> Response:\n        # Get or generate correlation ID\n        correlation_id = request.headers.get('x-correlation-id', str(uuid.uuid4()))\n        set_correlation_id(correlation_id)\n        \n        start_time = time.time()\n        \n        # Log request\n        logger.info(\n            'request_started',\n            method=request.method,\n            path=request.url.path,\n            query=str(request.query_params),\n        )\n        \n        try:\n            response = await call_next(request)\n            \n            # Add correlation ID to response\n            response.headers['x-correlation-id'] = correlation_id\n            \n            # Log response\n            duration_ms = (time.time() - start_time) * 1000\n            log_level = 'error' if response.status_code >= 500 else 'warn' if response.status_code >= 400 else 'info'\n            getattr(logger, log_level)(\n                'request_completed',\n                method=request.method,\n                path=request.url.path,\n                status_code=response.status_code,\n                duration_ms=round(duration_ms, 2),\n            )\n            \n            return response\n        except Exception as e:\n            logger.exception(\n                'request_failed',\n                method=request.method,\n                path=request.url.path,\n                error=str(e),\n            )\n            raise\n```\n\n**Update `ml-service/app/main.py`:**\n```python\nfrom app.core.logging import configure_logging, get_logger\nfrom app.middleware.logging import LoggingMiddleware\nfrom app.config import settings\n\n# Configure logging on startup\nconfigure_logging(settings.ENVIRONMENT)\nlogger = get_logger(__name__)\n\napp = FastAPI(...)\napp.add_middleware(LoggingMiddleware)\n\n@app.on_event('startup')\nasync def startup():\n    logger.info('ml_service_started', port=8000, environment=settings.ENVIRONMENT)\n```",
        "testStrategy": "1. Start ML service and verify JSON log output in production mode\n2. Verify correlation ID passed from backend appears in ML logs\n3. Test sensitive data redaction in request logs\n4. Verify log levels (debug, info, warn, error)\n5. Test exception logging includes stack trace\n6. Verify correlation ID in response headers\n7. Test dev console renderer in development mode\n8. Verify logs parse correctly with jq",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install dependencies and create core logging module",
            "description": "Add structlog and python-json-logger to requirements.txt, then create app/core/logging.py with structured logging configuration, correlation ID context variables, and sensitive data redaction.",
            "dependencies": [],
            "details": "1. Update ml-service/requirements.txt with structlog>=24.1.0 and python-json-logger>=2.0.7\n2. Create ml-service/app/core/logging.py implementing:\n   - ContextVar for correlation IDs (correlation_id_var)\n   - get_correlation_id() and set_correlation_id() functions\n   - SENSITIVE_KEYS set for redaction (password, token, secret, authorization, api_key)\n   - redact_sensitive_data() processor that recursively redacts dict/list values\n   - add_service_context() processor adding service name and correlation_id\n   - configure_logging() with environment-based processors (JSONRenderer for prod, ConsoleRenderer for dev)\n   - get_logger() factory function\n3. Install dependencies: cd ml-service && pip install -r requirements.txt\n4. Test logging configuration imports without errors",
            "status": "pending",
            "testStrategy": "Run Python REPL: from app.core.logging import configure_logging, get_logger; configure_logging('development'); logger = get_logger(); logger.info('test', password='secret') - verify console output shows '[REDACTED]' for password field",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create logging middleware for FastAPI",
            "description": "Implement FastAPI middleware in app/middleware/logging.py to capture request/response with timing metrics and propagate correlation IDs through headers.",
            "dependencies": [
              1
            ],
            "details": "1. Create ml-service/app/middleware/ directory if not exists\n2. Create ml-service/app/middleware/logging.py implementing LoggingMiddleware(BaseHTTPMiddleware):\n   - Extract or generate correlation ID from x-correlation-id header\n   - Call set_correlation_id() to set context\n   - Log request_started with method, path, query params\n   - Measure request duration using time.time()\n   - Add x-correlation-id to response headers\n   - Log request_completed with status_code and duration_ms\n   - Use dynamic log level based on status code (error >=500, warn >=400, info otherwise)\n   - Log request_failed with exception details on errors\n3. Test middleware with mock Request/Response objects",
            "status": "pending",
            "testStrategy": "Unit test LoggingMiddleware.dispatch() with mock request/call_next, verify: 1) correlation ID extracted from headers, 2) correlation ID added to response, 3) request_started and request_completed logged with correct fields, 4) exception handling logs request_failed",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate logging into FastAPI application",
            "description": "Update ml-service/app/main.py to configure structured logging on startup and register the logging middleware.",
            "dependencies": [
              2
            ],
            "details": "1. Update ml-service/app/main.py imports:\n   - from app.core.logging import configure_logging, get_logger\n   - from app.middleware.logging import LoggingMiddleware\n   - from app.config import settings (verify ENVIRONMENT exists in config)\n2. Add configure_logging(settings.ENVIRONMENT) before app = FastAPI(...)\n3. Create logger = get_logger(__name__) after configuration\n4. Add app.add_middleware(LoggingMiddleware) after app instantiation\n5. Update @app.on_event('startup') to log ml_service_started with port and environment\n6. Start ML service and verify JSON logs in production mode: ENVIRONMENT=production uvicorn app.main:app\n7. Verify console logs in dev mode: ENVIRONMENT=development uvicorn app.main:app",
            "status": "pending",
            "testStrategy": "1. Start service with ENVIRONMENT=production, send test request, verify JSON log output with correlation_id field\n2. Start service with ENVIRONMENT=development, verify colored console output\n3. Send request with x-correlation-id header, verify same ID appears in response header and logs\n4. Test /health endpoint logs at info level",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Replace existing logging calls with structured logger",
            "description": "Audit and replace all existing Python logging.getLogger() calls throughout the ML service codebase with structlog get_logger(), ensuring consistent structured logging.",
            "dependencies": [
              3
            ],
            "details": "1. Find all existing logging usage: grep -r 'logging.getLogger\\|logger.info\\|logger.error\\|logger.debug\\|logger.warning' ml-service/app/ --include='*.py'\n2. Replace logging imports with: from app.core.logging import get_logger\n3. Replace logger = logging.getLogger(__name__) with logger = get_logger(__name__)\n4. Update logging calls to use structured format:\n   - Old: logger.info(f'Processing {metric_type}')\n   - New: logger.info('processing_metric', metric_type=metric_type)\n5. Focus on high-traffic files: app/main.py, app/routers/, app/services/, app/ml_models/\n6. Add context to error logs: logger.error('operation_failed', error=str(e), user_id=user_id)\n7. Test sensitive data redaction in actual service logs (password, token fields)",
            "status": "pending",
            "testStrategy": "1. grep for old logging patterns, verify none remain\n2. Start service and trigger various endpoints (predictions, health metrics)\n3. Verify all logs use JSON format in production mode\n4. Test exception logging includes stack traces: logger.exception('error_name')\n5. Verify sensitive data redaction by logging test payloads with password/token fields\n6. Check correlation IDs persist across service boundaries",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down into: 1) Install structlog and python-json-logger, create app/core/logging.py with configuration, redaction, and correlation ID context vars, 2) Create logging middleware (app/middleware/logging.py) that captures request/response with timing and propagates correlation IDs, 3) Update app/main.py to configure logging on startup and add middleware, 4) Replace existing logging calls throughout ML service with structured logger. Test JSON output in production mode and console rendering in dev.",
        "updatedAt": "2025-12-18T09:00:19.407Z"
      },
      {
        "id": 28,
        "title": "Create Server Setup Script for Hetzner",
        "description": "Create an idempotent setup script that provisions a new Hetzner server with all required software, security configurations, and Coolify installation.",
        "details": "**Create `scripts/deploy/setup-server.sh`:**\n```bash\n#!/bin/bash\nset -e\n\n# =============================================================================\n# Nutri Server Setup Script for Hetzner CX32\n# Run as root on fresh Ubuntu 22.04 LTS\n# =============================================================================\n\necho \"=== Nutri Production Server Setup ===\"\necho \"Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\necho \"\"\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m' # No Color\n\ninfo() { echo -e \"${GREEN}[INFO]${NC} $1\"; }\nwarn() { echo -e \"${YELLOW}[WARN]${NC} $1\"; }\nerror() { echo -e \"${RED}[ERROR]${NC} $1\"; exit 1; }\n\n# =============================================================================\n# System Updates and Basic Security\n# =============================================================================\n\ninfo \"Updating system packages...\"\napt-get update -qq\nDEBIAN_FRONTEND=noninteractive apt-get upgrade -y -qq\n\ninfo \"Installing essential packages...\"\napt-get install -y -qq \\\n    curl \\\n    wget \\\n    git \\\n    ufw \\\n    fail2ban \\\n    unattended-upgrades \\\n    apt-listchanges \\\n    htop \\\n    ncdu\n\n# =============================================================================\n# Security Hardening\n# =============================================================================\n\ninfo \"Configuring firewall (UFW)...\"\nufw --force reset\nufw default deny incoming\nufw default allow outgoing\nufw allow 22/tcp comment 'SSH'\nufw allow 80/tcp comment 'HTTP'\nufw allow 443/tcp comment 'HTTPS'\nufw --force enable\nufw status verbose\n\ninfo \"Configuring fail2ban...\"\ncat > /etc/fail2ban/jail.local << 'EOF'\n[DEFAULT]\nbantime = 3600\nfindtime = 600\nmaxretry = 5\n\n[sshd]\nenabled = true\nport = ssh\nfilter = sshd\nlogpath = /var/log/auth.log\nmaxretry = 3\nbantime = 86400\nEOF\nsystemctl restart fail2ban\nsystemctl enable fail2ban\n\ninfo \"Configuring SSH security...\"\nsed -i 's/#PermitRootLogin yes/PermitRootLogin prohibit-password/' /etc/ssh/sshd_config\nsed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config\nsed -i 's/PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config\nsystemctl restart sshd\n\ninfo \"Enabling automatic security updates...\"\ndpkg-reconfigure -f noninteractive unattended-upgrades\ncat > /etc/apt/apt.conf.d/50unattended-upgrades << 'EOF'\nUnattended-Upgrade::Allowed-Origins {\n    \"${distro_id}:${distro_codename}-security\";\n};\nUnattended-Upgrade::AutoFixInterruptedDpkg \"true\";\nUnattended-Upgrade::Remove-Unused-Dependencies \"true\";\nUnattended-Upgrade::Automatic-Reboot \"false\";\nEOF\n\n# =============================================================================\n# Swap Configuration\n# =============================================================================\n\nif [ ! -f /swapfile ]; then\n    info \"Creating 4GB swap file...\"\n    fallocate -l 4G /swapfile\n    chmod 600 /swapfile\n    mkswap /swapfile\n    swapon /swapfile\n    echo '/swapfile none swap sw 0 0' >> /etc/fstab\n    echo 'vm.swappiness=10' >> /etc/sysctl.conf\n    sysctl -p\nelse\n    info \"Swap file already exists, skipping...\"\nfi\n\n# =============================================================================\n# Docker Installation (if not present)\n# =============================================================================\n\nif ! command -v docker &> /dev/null; then\n    info \"Installing Docker...\"\n    curl -fsSL https://get.docker.com | sh\n    systemctl enable docker\n    systemctl start docker\n    \n    # Docker cleanup cron job\n    cat > /etc/cron.daily/docker-cleanup << 'EOF'\n#!/bin/bash\ndocker system prune -af --volumes --filter \"until=168h\" > /dev/null 2>&1\nEOF\n    chmod +x /etc/cron.daily/docker-cleanup\nelse\n    info \"Docker already installed, skipping...\"\nfi\n\n# =============================================================================\n# Coolify Installation\n# =============================================================================\n\nif [ ! -d /data/coolify ]; then\n    info \"Installing Coolify...\"\n    curl -fsSL https://cdn.coollabs.io/coolify/install.sh | bash\n    info \"Coolify installed! Access at https://your-server-ip:8000\"\nelse\n    info \"Coolify already installed, skipping...\"\nfi\n\n# =============================================================================\n# Summary\n# =============================================================================\n\necho \"\"\necho \"=== Setup Complete ===\"\necho \"\"\ninfo \"Next steps:\"\necho \"1. Access Coolify at https://<server-ip>:8000\"\necho \"2. Create admin account and configure SSL\"\necho \"3. Set up GitHub webhook integration\"\necho \"4. Configure environment variables in Coolify\"\necho \"\"\ninfo \"Security status:\"\nufw status | head -10\necho \"\"\ninfo \"Resource usage:\"\nfree -h\ndf -h /\necho \"\"\ninfo \"Docker version:\"\ndocker --version\n```\n\n**Make executable:**\n```bash\nchmod +x scripts/deploy/setup-server.sh\n```",
        "testStrategy": "1. Test on fresh Ubuntu 22.04 VM (Hetzner or local)\n2. Verify idempotency - run script twice, second run should skip completed steps\n3. Check UFW rules: `ufw status verbose`\n4. Verify fail2ban: `fail2ban-client status sshd`\n5. Test SSH still works after config changes\n6. Verify swap: `free -h` shows 4GB swap\n7. Verify Docker: `docker run hello-world`\n8. Check Coolify accessible at :8000\n9. Verify auto-updates: `apt-config dump | grep -i unattended`",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create setup-server.sh with system updates and package installation",
            "description": "Create the initial setup script structure with shebang, error handling, color output functions, and implement system update and essential package installation section",
            "dependencies": [],
            "details": "Create scripts/deploy/setup-server.sh with executable permissions. Implement: 1) Script header with set -e for error handling, 2) Color output functions (info, warn, error), 3) System updates section using apt-get update and upgrade with quiet flags, 4) Essential packages installation (curl, wget, git, ufw, fail2ban, unattended-upgrades, apt-listchanges, htop, ncdu) using DEBIAN_FRONTEND=noninteractive for non-interactive installation. Ensure all output is properly formatted with timestamps and color-coded status messages.",
            "status": "pending",
            "testStrategy": "Run script on fresh Ubuntu 22.04 VM. Verify: 1) Script executes without errors, 2) All packages are installed: dpkg -l | grep -E '(curl|wget|git|ufw|fail2ban)', 3) System is updated to latest versions, 4) Color output displays correctly, 5) Error handling works by introducing intentional failure",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement security hardening (UFW, fail2ban, SSH)",
            "description": "Add comprehensive security configuration including firewall rules, intrusion prevention, and SSH hardening to protect the server from unauthorized access",
            "dependencies": [
              1
            ],
            "details": "Implement security hardening section: 1) UFW firewall configuration - reset existing rules, set default deny incoming/allow outgoing, allow ports 22 (SSH), 80 (HTTP), 443 (HTTPS) with comments, force enable UFW, 2) fail2ban configuration - create /etc/fail2ban/jail.local with sshd jail enabled (maxretry=3, bantime=86400, findtime=600), restart and enable fail2ban service, 3) SSH hardening - modify /etc/ssh/sshd_config to set PermitRootLogin=prohibit-password and PasswordAuthentication=no using sed, restart sshd service, 4) Automatic security updates - configure unattended-upgrades with security-only updates, auto-fix interrupted dpkg, remove unused dependencies, disable automatic reboot.",
            "status": "pending",
            "testStrategy": "After running script: 1) Verify UFW status: ufw status verbose (should show rules for ports 22, 80, 443), 2) Check fail2ban: fail2ban-client status sshd (should show jail is active), 3) Verify SSH config: grep -E '(PermitRootLogin|PasswordAuthentication)' /etc/ssh/sshd_config, 4) Test SSH connection still works with key-based auth, 5) Verify unattended-upgrades config: cat /etc/apt/apt.conf.d/50unattended-upgrades",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add swap configuration with idempotency checks",
            "description": "Implement swap file creation with proper size, permissions, and swappiness settings, ensuring the script can safely run multiple times without recreating swap",
            "dependencies": [
              2
            ],
            "details": "Implement swap configuration section with idempotency: 1) Check if /swapfile already exists using conditional [ ! -f /swapfile ], 2) If not exists: create 4GB swap file using fallocate -l 4G, set permissions to 600, run mkswap and swapon, add entry to /etc/fstab for persistence, 3) Configure vm.swappiness=10 in /etc/sysctl.conf for optimal performance (prefer RAM over swap), apply with sysctl -p, 4) If swap exists: skip creation and output info message. Ensure script outputs appropriate messages for both scenarios.",
            "status": "pending",
            "testStrategy": "Test idempotency: 1) Run script first time, verify swap created: free -h (should show 4G swap), 2) Check swappiness: cat /proc/sys/vm/swappiness (should be 10), 3) Verify fstab entry: grep swapfile /etc/fstab, 4) Run script second time, verify it skips swap creation (should see 'already exists' message), 5) Reboot VM and verify swap is still active after boot",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Docker installation with cleanup automation",
            "description": "Add Docker installation using official script with idempotency checks, configure automatic cleanup cron job to prevent disk space issues from old images and containers",
            "dependencies": [
              3
            ],
            "details": "Implement Docker installation section: 1) Check if Docker is already installed using command -v docker, 2) If not installed: download and run official Docker installation script (curl -fsSL https://get.docker.com | sh), enable and start Docker service using systemctl, 3) Create /etc/cron.daily/docker-cleanup script that runs 'docker system prune -af --volumes --filter until=168h' (removes unused resources older than 7 days), make cleanup script executable (chmod +x), 4) If Docker exists: skip installation and output info message. Ensure Docker daemon is running after installation.",
            "status": "pending",
            "testStrategy": "Test Docker setup: 1) Run script on system without Docker, verify installation: docker --version, 2) Check Docker service: systemctl status docker (should be active and enabled), 3) Verify cleanup cron exists: cat /etc/cron.daily/docker-cleanup, 4) Test cron script manually: /etc/cron.daily/docker-cleanup, 5) Run setup script again, verify it skips Docker installation, 6) Test Docker works: docker run hello-world",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Coolify installation and comprehensive summary output",
            "description": "Implement Coolify installation with idempotency and create detailed summary section showing security status, resource usage, and next steps for administrator",
            "dependencies": [
              4
            ],
            "details": "Implement final sections: 1) Coolify installation - check if /data/coolify directory exists, if not: download and execute Coolify install script (curl -fsSL https://cdn.coollabs.io/coolify/install.sh | bash), output access URL, if exists: skip and inform, 2) Create comprehensive summary output section with: header banner, next steps list (access Coolify at https://<server-ip>:8000, create admin account, configure SSL, set up GitHub webhooks, configure environment variables), security status (UFW rules via 'ufw status | head -10'), resource usage (RAM via 'free -h', disk via 'df -h /'), Docker version. Use color-coded info messages throughout summary.",
            "status": "pending",
            "testStrategy": "Complete integration test: 1) Run full script on fresh Ubuntu 22.04 VM, 2) Verify all sections complete successfully, 3) Check summary output contains all required information, 4) Access Coolify at https://<server-ip>:8000 (should show login page), 5) Run script second time (idempotency test) - all sections should skip appropriately with 'already exists' messages, 6) Verify final state: UFW active, fail2ban running, swap enabled, Docker installed, Coolify accessible, 7) Check script execution time (should complete in <10 minutes on CX32)",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Divide into: 1) Create scripts/deploy/setup-server.sh with system updates and essential package installation, 2) Implement security hardening section (UFW firewall rules, fail2ban configuration, SSH hardening), 3) Add swap configuration with proper swappiness settings, 4) Implement Docker installation with cleanup cron job, 5) Add Coolify installation and create comprehensive summary output. Test script on fresh Ubuntu 22.04 VM and verify idempotency.",
        "updatedAt": "2025-12-18T09:03:05.861Z"
      },
      {
        "id": 29,
        "title": "Create Deployment Documentation",
        "description": "Create comprehensive deployment documentation including architecture diagrams, setup guides, troubleshooting, and runbooks for daily operations.",
        "details": "**Create `docs/deployment/README.md`:**\n```markdown\n# Nutri Deployment Documentation\n\n## Architecture Overview\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                        GitHub Repository                         │\n│  (push to main) ──────────────────────────────────────────────► │\n└─────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                       GitHub Actions CI/CD                       │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │\n│  │ Lint & Test  │──│ Build Images │──│ Push to GHCR │          │\n│  └──────────────┘  └──────────────┘  └──────────────┘          │\n└─────────────────────────────────────────────────────────────────┘\n                                    │ (webhook)\n                                    ▼\n┌─────────────────────────────────────────────────────────────────┐\n│              Hetzner CX32 (4 vCPU, 8GB RAM)                     │\n│  ┌─────────────────────────────────────────────────────────┐   │\n│  │                    Coolify (PaaS Layer)                  │   │\n│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │   │\n│  │  │   Traefik   │  │  Backend    │  │ ML Service  │      │   │\n│  │  │ (SSL/Proxy) │  │  (Express)  │  │  (FastAPI)  │      │   │\n│  │  └─────────────┘  └─────────────┘  └─────────────┘      │   │\n│  └─────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n         │                      │\n         ▼                      ▼\n┌────────────────────┐  ┌────────────────────┐\n│   Supabase         │  │   Upstash Redis    │\n│   (PostgreSQL)     │  │   (Cache)          │\n└────────────────────┘  └────────────────────┘\n```\n\n## Cost Breakdown\n\n| Service | Provider | Cost/Month |\n|---------|----------|------------|\n| VPS (CX32) | Hetzner | €5.49 |\n| Backups | Hetzner | €1.20 |\n| Database | Supabase Free | $0 |\n| Redis | Upstash Free | $0 |\n| **Total** | | **~$8/mo** |\n\n## Quick Links\n\n- [Initial Setup Guide](./SETUP.md)\n- [Troubleshooting Guide](./TROUBLESHOOTING.md)\n- [Operations Runbook](./RUNBOOK.md)\n- [Environment Variables](./ENVIRONMENT.md)\n```\n\n**Create `docs/deployment/SETUP.md`:**\n```markdown\n# Initial Setup Guide\n\n## Prerequisites\n\n- Hetzner Cloud account\n- Supabase account\n- Upstash account\n- GitHub repository with admin access\n- Domain name (optional but recommended)\n\n## Step 1: Provision Hetzner Server\n\n1. Log into [Hetzner Cloud Console](https://console.hetzner.cloud/)\n2. Create new project \"nutri-production\"\n3. Add SSH key to project\n4. Create server:\n   - Location: Nearest to users (e.g., Helsinki, Frankfurt)\n   - Image: Ubuntu 22.04\n   - Type: CX32 (4 vCPU, 8GB RAM)\n   - Networking: Public IPv4\n   - SSH Key: Select your key\n   - Backups: Enable ($1.20/mo)\n\n## Step 2: Run Server Setup Script\n\n```bash\nssh root@<server-ip>\ncurl -fsSL https://raw.githubusercontent.com/your-repo/nutri/master/scripts/deploy/setup-server.sh | bash\n```\n\n## Step 3: Configure Coolify\n\n1. Access Coolify at `http://<server-ip>:8000`\n2. Create admin account\n3. Settings > General:\n   - Set custom domain for Coolify dashboard\n   - Enable SSL via Let's Encrypt\n4. Add new source: GitHub (OAuth or Deploy Key)\n\n[Continue with detailed steps...]\n```\n\n**Create `docs/deployment/TROUBLESHOOTING.md`:**\n```markdown\n# Troubleshooting Guide\n\n## Common Issues\n\n### Container won't start\n\n**Symptoms:** Container status shows \"Exited\" or \"Restarting\"\n\n**Solutions:**\n1. Check logs: `docker logs <container-name>`\n2. Verify environment variables in Coolify\n3. Check health endpoint: `curl http://localhost:3000/health`\n4. Verify database connection\n\n### Database connection failed\n\n**Symptoms:** \"Connection refused\" or timeout errors\n\n**Solutions:**\n1. Verify DATABASE_URL format\n2. Check Supabase dashboard for connection limits\n3. Ensure IP whitelist includes server IP\n...\n```\n\n**Create `docs/deployment/RUNBOOK.md`:**\n```markdown\n# Operations Runbook\n\n## Daily Operations\n\n### Check System Health\n```bash\ncurl https://api.nutri.app/health\n```\n\n### View Logs\n```bash\n# In Coolify dashboard, or:\ndocker logs -f nutri-backend --tail 100\n```\n\n## Emergency Procedures\n\n### Rollback Deployment\n\n1. Go to GitHub Actions\n2. Find last successful deploy workflow\n3. Click \"Re-run jobs\"\n\nOr manually:\n```bash\n# SSH to server\ndocker pull ghcr.io/repo/backend:<previous-sha>\n# Update image in Coolify\n```\n...\n```\n\n**Create `docs/deployment/ENVIRONMENT.md`:**\nDocument all environment variables with descriptions and examples.",
        "testStrategy": "1. Have team member follow SETUP.md on fresh account\n2. Verify all links work\n3. Test troubleshooting steps actually resolve issues\n4. Review runbook procedures with ops team\n5. Ensure architecture diagram matches actual deployment\n6. Verify cost breakdown is accurate",
        "priority": "medium",
        "dependencies": [
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create docs/deployment/README.md with architecture diagram and navigation",
            "description": "Create the main deployment documentation landing page with ASCII architecture diagram showing GitHub → CI/CD → Hetzner/Coolify → Supabase/Upstash flow, cost breakdown table, and quick links to other documentation files.",
            "dependencies": [],
            "details": "Create `docs/deployment/README.md` containing:\n1. ASCII architecture diagram showing complete deployment pipeline (GitHub → GitHub Actions → Hetzner CX32 → Coolify → Services)\n2. Cost breakdown table with Hetzner VPS (€5.49), Backups (€1.20), Supabase (free), Upstash (free), totaling ~$8/mo\n3. Quick links section referencing SETUP.md, TROUBLESHOOTING.md, RUNBOOK.md, and ENVIRONMENT.md\n4. Brief overview of the tech stack and deployment approach\n5. Use clear markdown formatting with proper headers and code blocks",
            "status": "pending",
            "testStrategy": "1. Verify ASCII diagram renders correctly in GitHub and VS Code\n2. Confirm all cost figures match infrastructure-costs.md\n3. Test that all quick links point to correct files (they don't need to exist yet)\n4. Review with team for accuracy and clarity",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Write docs/deployment/SETUP.md with complete setup instructions",
            "description": "Create comprehensive step-by-step setup guide covering Hetzner server provisioning, Coolify installation, service configuration, domain setup, SSL configuration, and GitHub integration.",
            "dependencies": [
              1
            ],
            "details": "Create `docs/deployment/SETUP.md` with:\n1. Prerequisites section (accounts needed, access requirements, domain name)\n2. Step 1: Hetzner server provisioning (location selection, CX32 specs, SSH key setup, backup enabling)\n3. Step 2: Server setup script execution (SSH connection, running setup-server.sh)\n4. Step 3: Coolify configuration (initial access, admin account, domain setup, SSL/Let's Encrypt)\n5. Step 4: GitHub source integration (OAuth or Deploy Key setup)\n6. Step 5: Supabase database setup (project creation, connection string, IP whitelist)\n7. Step 6: Upstash Redis setup (database creation, connection URL)\n8. Step 7: Service deployment in Coolify (environment variables, health checks, webhooks)\n9. Step 8: DNS configuration and SSL verification\n10. Include screenshots placeholders and troubleshooting tips inline",
            "status": "pending",
            "testStrategy": "1. Have team member follow guide on fresh Hetzner/Supabase/Upstash accounts\n2. Document any missing steps or unclear instructions\n3. Verify all commands execute successfully\n4. Confirm final deployment is accessible and healthy\n5. Time the setup process to estimate onboarding duration",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create docs/deployment/TROUBLESHOOTING.md with common issues and solutions",
            "description": "Document common deployment issues, their symptoms, root causes, and step-by-step solutions including container failures, database connection problems, health check failures, SSL certificate issues, and memory/resource problems.",
            "dependencies": [
              1
            ],
            "details": "Create `docs/deployment/TROUBLESHOOTING.md` with:\n1. Container won't start (symptoms: Exited/Restarting status; solutions: check logs, verify env vars, test health endpoint, verify DB connection)\n2. Database connection failed (symptoms: connection refused/timeout; solutions: verify DATABASE_URL format, check Supabase limits, IP whitelist, connection pooling)\n3. Health check failures (symptoms: container marked unhealthy; solutions: verify /health endpoint, check dependencies, review logs)\n4. SSL certificate issues (symptoms: HTTPS not working; solutions: Let's Encrypt rate limits, DNS propagation, Traefik config)\n5. Out of memory errors (symptoms: container OOMKilled; solutions: check memory limits, optimize queries, review ML model sizes)\n6. Coolify webhook not triggering (symptoms: no deployment after push; solutions: verify webhook URL, check GitHub Actions logs, test webhook manually)\n7. Each issue includes: symptoms, possible causes, diagnostic commands, step-by-step solutions, prevention tips",
            "status": "pending",
            "testStrategy": "1. Intentionally create each issue in staging environment\n2. Follow documented solutions to verify they work\n3. Measure time to resolution for each issue\n4. Get feedback from team on clarity and completeness\n5. Add any additional issues discovered during testing",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write docs/deployment/RUNBOOK.md with operations procedures",
            "description": "Create operations runbook with daily health checks, log viewing, monitoring procedures, emergency rollback steps, scaling procedures, backup verification, and incident response workflows.",
            "dependencies": [
              1
            ],
            "details": "Create `docs/deployment/RUNBOOK.md` with:\n1. Daily Operations: health check commands (curl health endpoints), log viewing (Coolify dashboard + docker logs), monitoring metrics to track\n2. Emergency Procedures: rollback deployment (GitHub Actions re-run + manual docker image swap), service restart (Coolify UI + docker commands), database failover (Supabase dashboard)\n3. Scaling Procedures: vertical scaling (Hetzner server resize), horizontal scaling (Coolify multi-container), database connection pool adjustments\n4. Backup Verification: test backup restoration, verify automated backups running, document RTO/RPO\n5. Incident Response: severity classification, notification procedures, escalation paths, post-mortem template\n6. Maintenance Windows: planned downtime procedures, communication templates, zero-downtime deployment steps\n7. Include actual commands with placeholders for environment-specific values",
            "status": "pending",
            "testStrategy": "1. Review with ops team for completeness\n2. Execute each daily operation command to verify syntax\n3. Test emergency rollback procedure in staging\n4. Verify all Coolify dashboard references are accurate\n5. Conduct tabletop exercise simulating incident response",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Document all environment variables in docs/deployment/ENVIRONMENT.md",
            "description": "Create comprehensive environment variable reference documenting all required and optional variables for backend, ML service, and infrastructure with descriptions, examples, security notes, and validation rules.",
            "dependencies": [
              1
            ],
            "details": "Create `docs/deployment/ENVIRONMENT.md` with:\n1. Backend API variables: NODE_ENV, DATABASE_URL, JWT_SECRET, JWT_EXPIRES_IN, PORT, REDIS_URL, ML_SERVICE_URL, CORS_ORIGIN\n2. ML Service variables: DATABASE_URL, REDIS_URL, ML_MODEL_PATH, TORCH_DEVICE, PREDICTION_CACHE_TTL\n3. Coolify/Infrastructure variables: COOLIFY_WEBHOOK_URL, GITHUB_TOKEN, DISCORD_WEBHOOK_URL\n4. For each variable include: name, description, required/optional, example value (sanitized), default value, validation rules, security considerations\n5. Security section: which variables are sensitive, how to rotate secrets, where secrets are stored (GitHub Secrets, Coolify env vars)\n6. Environment-specific overrides: development vs staging vs production differences\n7. Validation checklist: required variables by service, format validation commands\n8. Reference existing .env.example and server/.env.example for accuracy",
            "status": "pending",
            "testStrategy": "1. Cross-reference with .env.example files in repo\n2. Verify all variables in docker-compose.prod.yml are documented\n3. Check all variables in GitHub Actions workflows are covered\n4. Test example values actually work (with placeholders replaced)\n5. Ensure no actual secrets are included in documentation\n6. Validate against actual Coolify environment variable configuration",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Create docs/deployment/README.md with architecture diagram, cost breakdown, and navigation links, 2) Write docs/deployment/SETUP.md with step-by-step setup instructions from Hetzner provisioning to Coolify configuration, 3) Create docs/deployment/TROUBLESHOOTING.md covering common issues like container failures, database connection problems, and health check failures, 4) Write docs/deployment/RUNBOOK.md with daily operations procedures and emergency rollback steps, 5) Document all environment variables in docs/deployment/ENVIRONMENT.md. Have team member follow SETUP.md to validate.",
        "updatedAt": "2025-12-18T09:07:38.856Z"
      },
      {
        "id": 30,
        "title": "Set Up Uptime Monitoring",
        "description": "Configure external uptime monitoring for production endpoints using a free monitoring service with alerting capabilities.",
        "details": "**Option 1: UptimeRobot (Recommended - Free tier)**\n\n1. Create account at https://uptimerobot.com\n2. Add monitors:\n\n**Monitor 1 - Backend Health:**\n- Monitor Type: HTTP(s)\n- Friendly Name: Nutri Backend\n- URL: https://api.nutri.app/health\n- Monitoring Interval: 5 minutes\n- Alert contacts: Your email/Discord\n\n**Monitor 2 - ML Service (via Backend):**\n- Monitor Type: HTTP(s)\n- Friendly Name: Nutri ML Health\n- URL: https://api.nutri.app/api/food/health\n- Monitoring Interval: 5 minutes\n\n**Configure Alerts:**\n1. Alert Contacts > Add Contact\n2. Add Discord webhook:\n   - Type: Webhook\n   - URL: Your Discord webhook URL\n   - POST value:\n   ```json\n   {\"content\": \"*alertTypeFriendlyName* - *monitorFriendlyName* is *alertDetails*\"}\n   ```\n\n**Create Status Page (Optional):**\n1. UptimeRobot > My Settings > Status Pages\n2. Create page with both monitors\n3. Custom domain: status.nutri.app\n\n**Option 2: Better Stack (Alternative)**\n\n```bash\n# Create heartbeat endpoint\ncurl -X POST \"https://uptime.betterstack.com/api/v2/heartbeats\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Nutri Backend\",\n    \"period\": 300,\n    \"grace\": 60,\n    \"call\": true,\n    \"email\": true\n  }'\n```\n\n**Create `scripts/deploy/setup-monitoring.sh`:**\n```bash\n#!/bin/bash\n# Documentation script for monitoring setup\n\necho \"=== Nutri Monitoring Setup ===\"\necho \"\"\necho \"1. Go to https://uptimerobot.com and create account\"\necho \"2. Add the following monitors:\"\necho \"\"\necho \"   Backend Health Check:\"\necho \"   - URL: https://api.nutri.app/health\"\necho \"   - Interval: 5 minutes\"\necho \"   - Expected status: 200\"\necho \"\"\necho \"3. Configure Discord notifications:\"\necho \"   - Create webhook in Discord server\"\necho \"   - Add webhook URL to UptimeRobot alert contacts\"\necho \"\"\necho \"4. (Optional) Create public status page\"\necho \"\"\n```\n\n**Add monitoring endpoint docs to `docs/deployment/MONITORING.md`:**\n```markdown\n# Monitoring Setup\n\n## Endpoints to Monitor\n\n| Endpoint | Expected Status | Interval |\n|----------|-----------------|----------|\n| /health | 200 | 5 min |\n| /health/live | 200 | 1 min |\n\n## Alert Escalation\n\n1. Discord notification (immediate)\n2. Email notification (after 5 min down)\n3. SMS (optional, after 15 min down)\n\n## Response Procedures\n\nSee [Runbook](./RUNBOOK.md) for response procedures.\n```",
        "testStrategy": "1. Configure monitors in UptimeRobot\n2. Intentionally break health endpoint, verify alert fires\n3. Verify alert reaches Discord within 5 minutes\n4. Test alert recovery notification\n5. Check response time graphs show expected latency\n6. Verify status page (if created) shows correct status",
        "priority": "medium",
        "dependencies": [
          "21"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure UptimeRobot monitors for Backend and ML Service health endpoints",
            "description": "Set up UptimeRobot account and create HTTP monitors for both the Backend API (/health and /health/live) and ML Service health endpoints with appropriate check intervals.",
            "dependencies": [],
            "details": "1. Create free account at https://uptimerobot.com\n2. Add Backend API monitors:\n   - Monitor 1: 'Nutri Backend Health' pointing to https://api.nutri.app/health (5-min interval) - this comprehensive endpoint checks database and ML service connectivity\n   - Monitor 2: 'Nutri Backend Live' pointing to https://api.nutri.app/health/live (1-min interval) - lightweight liveness probe\n3. Add ML Service monitors:\n   - Monitor 3: 'Nutri ML Health' pointing to https://ml.nutri.app/health (5-min interval) - checks database, Redis, and overall ML service health\n   - Monitor 4: 'Nutri ML Queue Status' pointing to https://ml.nutri.app/queue/status (5-min interval) - monitors inference queue health and circuit breaker state\n4. Configure expected HTTP status codes: 200 for healthy responses, alert on 503 (unhealthy) or timeouts\n5. Set timeout threshold to 30 seconds (health endpoints should respond within 5 seconds normally)\n6. Enable SSL certificate monitoring for HTTPS endpoints",
            "status": "pending",
            "testStrategy": "1. Verify all monitors appear in UptimeRobot dashboard with correct URLs\n2. Manually test each endpoint responds with expected status\n3. Intentionally stop backend container and verify alert triggers within monitoring interval\n4. Confirm monitors show green status when services are healthy",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Set up Discord webhook alerts for monitoring notifications",
            "description": "Configure Discord webhook integration to receive real-time notifications when monitors detect downtime or recovery, following the notification pattern in the existing RUNBOOK.md.",
            "dependencies": [
              1
            ],
            "details": "1. Create Discord webhook in the designated alerts channel:\n   - Server Settings > Integrations > Webhooks > New Webhook\n   - Name it 'Nutri Uptime Monitor'\n   - Copy webhook URL\n2. Add webhook to UptimeRobot:\n   - Go to My Settings > Alert Contacts > Add Alert Contact\n   - Type: Webhook (as per task details JSON format)\n   - Webhook URL: [Discord webhook URL]\n   - POST value (JSON): {\"content\": \"**Alert**: *alertTypeFriendlyName* - *monitorFriendlyName* is *alertDetails*. Response time: *alertDuration*ms\"}\n   - Enable for Down, Up, and SSL expiry alerts\n3. Add email backup alert:\n   - Add Alert Contact > Email\n   - Configure to receive alerts after 5 minutes of downtime (avoid alert fatigue)\n4. Link alert contacts to all monitors created in subtask 1\n5. Configure alert notification delays: Immediate for Discord, 5-min delay for email to reduce noise",
            "status": "pending",
            "testStrategy": "1. Test Discord webhook by sending test notification from UptimeRobot\n2. Temporarily pause a monitor and verify Discord receives down notification\n3. Resume monitor and verify recovery notification arrives\n4. Confirm email backup receives delayed alert\n5. Verify alert messages include useful context (monitor name, duration, status)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create public status page for service availability transparency",
            "description": "Configure UptimeRobot status page to provide public visibility into service availability, response times, and historical uptime data.",
            "dependencies": [
              1
            ],
            "details": "1. Create status page in UptimeRobot:\n   - Go to My Settings > Status Pages > Add Status Page\n   - Name: 'Nutri Service Status'\n   - Select monitors to include: Backend Health, Backend Live, ML Health\n   - Enable 'Show response time' and 'Show uptime ratio'\n2. Customize status page appearance:\n   - Add Nutri branding/logo if available\n   - Set appropriate colors (green/yellow/red states)\n   - Configure incident history display (last 30 days)\n3. (Optional) Configure custom domain:\n   - Add CNAME record: status.nutri.app -> stats.uptimerobot.com\n   - Enable SSL in UptimeRobot dashboard\n4. Add status page link to application footer/help section\n5. Enable RSS feed for automated status updates\n6. Configure announcement feature for planned maintenance windows",
            "status": "pending",
            "testStrategy": "1. Verify status page is accessible at configured URL\n2. Confirm all monitors display correctly with proper naming\n3. Check response time graphs populate after 24 hours\n4. Test custom domain resolves correctly (if configured)\n5. Verify historical uptime data displays accurately\n6. Test RSS feed subscription works",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Document monitoring setup and response procedures in deployment docs",
            "description": "Create comprehensive MONITORING.md documentation covering endpoint monitoring configuration, alert escalation procedures, and response runbook integration.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. Create docs/deployment/MONITORING.md with sections:\n   - Overview of monitoring architecture\n   - Endpoints monitored (table with URL, expected status, interval as shown in task details)\n   - UptimeRobot configuration reference (how to add/modify monitors)\n   - Alert escalation matrix (Discord immediate, email 5-min, SMS optional 15-min)\n   - Integration with existing RUNBOOK.md emergency procedures\n2. Create scripts/deploy/setup-monitoring.sh documentation script:\n   - Echo step-by-step UptimeRobot setup instructions\n   - Include webhook configuration template\n   - Reference production URLs for all health endpoints\n3. Update docs/deployment/RUNBOOK.md:\n   - Add reference to MONITORING.md in incident detection section\n   - Link to UptimeRobot dashboard in emergency procedures\n   - Document how to acknowledge alerts and update status page during incidents\n4. Add monitoring section to scripts/deploy/setup-server.sh output (already mentions UptimeRobot at line 463)\n5. Include troubleshooting section for common monitoring issues (false positives, SSL cert warnings)",
            "status": "pending",
            "testStrategy": "1. Verify MONITORING.md renders correctly with proper markdown formatting\n2. Run setup-monitoring.sh and confirm instructions are clear and accurate\n3. Cross-reference endpoints in docs match actual health endpoints in codebase (server/src/index.ts lines 41-125, ml-service/app/main.py lines 226-364)\n4. Have team member follow documentation to verify clarity\n5. Ensure links between MONITORING.md and RUNBOOK.md work correctly",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 31,
        "title": "Integrate Error Tracking with Sentry",
        "description": "Set up Sentry error tracking for both backend and ML service to capture, group, and alert on production errors with source maps.",
        "details": "**Backend Integration (Express.js):**\n\n1. Install Sentry:\n```bash\ncd server && npm install @sentry/node @sentry/profiling-node\n```\n\n2. Create `server/src/config/sentry.ts`:\n```typescript\nimport * as Sentry from '@sentry/node';\nimport { ProfilingIntegration } from '@sentry/profiling-node';\nimport { Express } from 'express';\n\nexport function initSentry(app: Express): void {\n  if (!process.env.SENTRY_DSN) {\n    console.log('Sentry DSN not configured, skipping initialization');\n    return;\n  }\n\n  Sentry.init({\n    dsn: process.env.SENTRY_DSN,\n    environment: process.env.NODE_ENV || 'development',\n    release: process.env.npm_package_version,\n    integrations: [\n      new Sentry.Integrations.Http({ tracing: true }),\n      new Sentry.Integrations.Express({ app }),\n      new ProfilingIntegration(),\n    ],\n    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,\n    profilesSampleRate: 0.1,\n    beforeSend(event) {\n      // Scrub sensitive data\n      if (event.request?.headers) {\n        delete event.request.headers.authorization;\n        delete event.request.headers.cookie;\n      }\n      return event;\n    },\n  });\n}\n\nexport { Sentry };\n```\n\n3. Update `server/src/index.ts`:\n```typescript\nimport { initSentry, Sentry } from './config/sentry';\n\nconst app = express();\n\n// Initialize Sentry FIRST\ninitSentry(app);\n\n// Sentry request handler (must be first middleware)\nif (process.env.SENTRY_DSN) {\n  app.use(Sentry.Handlers.requestHandler());\n  app.use(Sentry.Handlers.tracingHandler());\n}\n\n// ... other middleware and routes ...\n\n// Sentry error handler (before your error handler)\nif (process.env.SENTRY_DSN) {\n  app.use(Sentry.Handlers.errorHandler());\n}\n\napp.use(errorHandler);\n```\n\n**ML Service Integration (Python):**\n\n1. Add to `ml-service/requirements.txt`:\n```\nsentry-sdk[fastapi]>=1.40.0\n```\n\n2. Create `ml-service/app/core/sentry.py`:\n```python\nimport sentry_sdk\nfrom sentry_sdk.integrations.fastapi import FastApiIntegration\nfrom sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration\nfrom app.config import settings\n\ndef init_sentry():\n    if not settings.SENTRY_DSN:\n        return\n    \n    sentry_sdk.init(\n        dsn=settings.SENTRY_DSN,\n        environment=settings.ENVIRONMENT,\n        release=settings.VERSION,\n        integrations=[\n            FastApiIntegration(),\n            SqlalchemyIntegration(),\n        ],\n        traces_sample_rate=0.1 if settings.ENVIRONMENT == 'production' else 1.0,\n        profiles_sample_rate=0.1,\n        send_default_pii=False,  # Don't send personally identifiable info\n        before_send=scrub_sensitive_data,\n    )\n\ndef scrub_sensitive_data(event, hint):\n    if 'request' in event and 'headers' in event['request']:\n        headers = event['request']['headers']\n        if 'authorization' in headers:\n            headers['authorization'] = '[REDACTED]'\n    return event\n```\n\n3. Update `ml-service/app/main.py`:\n```python\nfrom app.core.sentry import init_sentry\n\n# Initialize Sentry on startup\ninit_sentry()\n```\n\n**GitHub Actions - Upload Source Maps:**\nAdd to `.github/workflows/build.yml`:\n```yaml\n      - name: Upload source maps to Sentry\n        if: env.SENTRY_AUTH_TOKEN != ''\n        env:\n          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}\n        run: |\n          npm install -g @sentry/cli\n          cd server && npm run build\n          sentry-cli releases new ${{ github.sha }}\n          sentry-cli releases files ${{ github.sha }} upload-sourcemaps ./dist\n          sentry-cli releases finalize ${{ github.sha }}\n```\n\n**Environment Variables to Add:**\n```\nSENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx\nSENTRY_AUTH_TOKEN=xxx (for source map upload)\n```",
        "testStrategy": "1. Create Sentry project and get DSN\n2. Trigger test error: `throw new Error('Test Sentry integration')`\n3. Verify error appears in Sentry dashboard\n4. Check source maps resolve correctly\n5. Verify sensitive data is scrubbed (no auth tokens)\n6. Test alert notification for new errors\n7. Verify performance monitoring shows traces\n8. Test ML service integration separately",
        "priority": "medium",
        "dependencies": [
          "26",
          "27"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate Sentry SDK with Express.js Backend API",
            "description": "Install and configure @sentry/node and @sentry/profiling-node for the Express.js backend to capture errors, performance traces, and profiling data with proper initialization order.",
            "dependencies": [],
            "details": "1. Install Sentry packages: `cd server && npm install @sentry/node @sentry/profiling-node`\n\n2. Create `server/src/config/sentry.ts` with:\n   - Sentry.init() with DSN from env, environment detection, release version from package.json\n   - HTTP integration for request tracing\n   - Express integration for route instrumentation\n   - ProfilingIntegration for performance profiling\n   - tracesSampleRate: 0.1 production, 1.0 development\n   - profilesSampleRate: 0.1\n   - beforeSend hook for data scrubbing (implemented in subtask 3)\n\n3. Update `server/src/index.ts`:\n   - Import and call initSentry(app) BEFORE any middleware registration (after line 14)\n   - Add Sentry.Handlers.requestHandler() as FIRST middleware (after cors())\n   - Add Sentry.Handlers.tracingHandler() after requestHandler\n   - Add Sentry.Handlers.errorHandler() BEFORE the custom errorHandler middleware (line 137)\n   - All Sentry handlers wrapped in conditional: `if (process.env.SENTRY_DSN)`\n\n4. Update `server/src/config/env.ts`:\n   - Add SENTRY_DSN to config object (optional, no validation needed)\n   - Export sentryDsn config value\n\n5. Update `server/src/middleware/errorHandler.ts`:\n   - Import Sentry from config/sentry\n   - Call Sentry.captureException(err) before logging for unhandled errors",
            "status": "pending",
            "testStrategy": "1. Unit test: Mock Sentry.init and verify correct options passed\n2. Integration test: Verify Sentry handlers are added in correct order when DSN is set\n3. Test error capture: Throw test error and verify Sentry.captureException called\n4. Test graceful degradation: Verify server starts without SENTRY_DSN configured\n5. Build verification: Run `npm run build` to ensure no TypeScript errors",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate Sentry SDK with FastAPI ML Service",
            "description": "Install and configure sentry-sdk[fastapi] for the Python ML service with FastAPI and SQLAlchemy integrations to capture errors and performance traces.",
            "dependencies": [],
            "details": "1. Add to `ml-service/requirements.txt` (after line 78, in Monitoring section):\n   ```\n   sentry-sdk[fastapi]==1.40.0\n   ```\n\n2. Create `ml-service/app/core/sentry.py`:\n   - Import sentry_sdk, FastApiIntegration, SqlalchemyIntegration\n   - Create init_sentry() function checking settings.sentry_dsn\n   - Configure: dsn, environment, release (app_version), traces_sample_rate (0.1 prod, 1.0 dev)\n   - Add FastApiIntegration() and SqlalchemyIntegration()\n   - Set send_default_pii=False\n   - Add before_send callback for scrubbing (implemented in subtask 3)\n\n3. Update `ml-service/app/config.py`:\n   - Add `sentry_dsn: Optional[str] = None` to Settings class (after line 77)\n   - Add `sentry_traces_sample_rate: float = 0.1` for configurability\n\n4. Update `ml-service/app/main.py`:\n   - Import init_sentry from app.core.sentry (after line 20)\n   - Call init_sentry() at the TOP of lifespan function (line 104, before any other initialization)\n\n5. Update exception handler at line 402:\n   - Import sentry_sdk\n   - Call sentry_sdk.capture_exception(exc) before logging the error",
            "status": "pending",
            "testStrategy": "1. Unit test: Mock sentry_sdk.init and verify correct options passed\n2. Test FastAPI integration: Verify exceptions are captured with request context\n3. Test SQLAlchemy integration: Verify database errors include query context\n4. Test graceful degradation: Verify service starts without SENTRY_DSN configured\n5. Type check: Run `make typecheck` to verify no mypy errors",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Sensitive Data Scrubbing for Both Services",
            "description": "Create beforeSend hooks for both backend and ML service to scrub sensitive data including authorization tokens, cookies, passwords, and API keys from error reports.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Update `server/src/config/sentry.ts` beforeSend hook:\n   ```typescript\n   beforeSend(event, hint) {\n     // Scrub request headers\n     if (event.request?.headers) {\n       delete event.request.headers.authorization;\n       delete event.request.headers.cookie;\n       delete event.request.headers['x-api-key'];\n     }\n     // Scrub request body for sensitive fields\n     if (event.request?.data) {\n       const sensitiveFields = ['password', 'token', 'secret', 'apiKey', 'creditCard'];\n       for (const field of sensitiveFields) {\n         if (event.request.data[field]) {\n           event.request.data[field] = '[REDACTED]';\n         }\n       }\n     }\n     // Scrub user data\n     if (event.user?.email) {\n       // Keep partial email for debugging: 'j***@example.com'\n       const [local, domain] = event.user.email.split('@');\n       event.user.email = `${local[0]}***@${domain}`;\n     }\n     return event;\n   }\n   ```\n\n2. Update `ml-service/app/core/sentry.py` scrub_sensitive_data function:\n   ```python\n   def scrub_sensitive_data(event, hint):\n       # Scrub request headers\n       if 'request' in event and 'headers' in event['request']:\n           headers = event['request']['headers']\n           for header in ['authorization', 'cookie', 'x-api-key']:\n               if header in headers:\n                   headers[header] = '[REDACTED]'\n       \n       # Scrub request body\n       if 'request' in event and 'data' in event['request']:\n           sensitive_fields = ['password', 'token', 'secret', 'api_key', 'credit_card']\n           for field in sensitive_fields:\n               if field in event['request']['data']:\n                   event['request']['data'][field] = '[REDACTED]'\n       \n       # Scrub user email (partial)\n       if 'user' in event and 'email' in event.get('user', {}):\n           email = event['user']['email']\n           if '@' in email:\n               local, domain = email.split('@')\n               event['user']['email'] = f\"{local[0]}***@{domain}\"\n       \n       return event\n   ```\n\n3. Add denyUrls and ignoreErrors config to filter out expected errors:\n   - Ignore 401/403 authentication errors (expected behavior)\n   - Ignore rate limiting responses\n   - Ignore known third-party script errors",
            "status": "pending",
            "testStrategy": "1. Unit test: Send mock error with authorization header, verify it's redacted in event\n2. Unit test: Send mock error with password in body, verify it's [REDACTED]\n3. Unit test: Verify partial email masking works correctly\n4. Integration test: Trigger real error with sensitive data, verify Sentry dashboard shows redacted values\n5. Negative test: Verify non-sensitive fields are NOT redacted",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configure GitHub Actions for Source Map Upload",
            "description": "Add Sentry CLI source map upload step to build.yml workflow for both backend TypeScript and any bundled assets to enable proper stack trace deobfuscation in production.",
            "dependencies": [
              1
            ],
            "details": "1. Update `.github/workflows/build.yml` - Add to build-backend job (after line 64):\n   ```yaml\n   - name: Build TypeScript with source maps\n     run: |\n       cd server\n       npm run build\n     \n   - name: Create Sentry release and upload source maps\n     if: env.SENTRY_AUTH_TOKEN != ''\n     env:\n       SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}\n       SENTRY_ORG: ${{ secrets.SENTRY_ORG }}\n       SENTRY_PROJECT: nutri-backend\n     run: |\n       npm install -g @sentry/cli\n       cd server\n       sentry-cli releases new ${{ github.sha }}\n       sentry-cli releases files ${{ github.sha }} upload-sourcemaps ./dist --ext ts --ext js --ext map\n       sentry-cli releases set-commits ${{ github.sha }} --auto\n       sentry-cli releases finalize ${{ github.sha }}\n       sentry-cli releases deploys ${{ github.sha }} new -e production\n   ```\n\n2. Update `server/tsconfig.json` to generate source maps:\n   - Ensure `\"sourceMap\": true` is set in compilerOptions\n   - Add `\"inlineSources\": true` for better stack traces\n\n3. Add documentation for required GitHub secrets:\n   - SENTRY_AUTH_TOKEN: Generated from Sentry Settings > API Keys\n   - SENTRY_ORG: Organization slug from Sentry\n   - SENTRY_PROJECT: Project slug (nutri-backend, nutri-ml-service)\n\n4. Update Sentry config in both services to include release tag:\n   - Backend: `release: process.env.GITHUB_SHA || process.env.npm_package_version`\n   - ML: `release: os.environ.get('GITHUB_SHA', settings.app_version)`",
            "status": "pending",
            "testStrategy": "1. Local test: Run build and verify .map files generated in dist/\n2. CI test: Trigger workflow with SENTRY_AUTH_TOKEN set, verify source maps uploaded\n3. Verify in Sentry: Check release artifacts show source maps\n4. Integration test: Trigger error in production, verify stack trace shows original TypeScript line numbers\n5. Negative test: Verify build succeeds when SENTRY_AUTH_TOKEN is not set (graceful skip)",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configure Sentry Alerts and Verify End-to-End Integration",
            "description": "Set up Sentry alert rules for error rate thresholds and new issues, add test endpoints for verification, and create documentation for the team.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "1. Create test error endpoints for verification:\n   \n   Backend - Add to a new route or existing test route:\n   ```typescript\n   // GET /api/debug/sentry-test (only in non-production)\n   if (process.env.NODE_ENV !== 'production') {\n     app.get('/api/debug/sentry-test', (req, res) => {\n       throw new Error('Test Sentry integration - Backend');\n     });\n   }\n   ```\n   \n   ML Service - Add test endpoint:\n   ```python\n   @app.get('/debug/sentry-test', tags=['Debug'])\n   async def test_sentry():\n       if settings.environment == 'production':\n           raise HTTPException(status_code=404)\n       raise ValueError('Test Sentry integration - ML Service')\n   ```\n\n2. Document Sentry project setup in `docs/sentry-setup.md`:\n   - Create two Sentry projects: nutri-backend, nutri-ml-service\n   - Configure alert rules via Sentry dashboard:\n     * New Issue Alert: Notify on first occurrence of new errors\n     * Error Rate Alert: >10 errors in 5 minutes\n     * Performance Alert: P95 response time >2s\n   - Configure integrations: Slack/Email for alerts\n   - Team member notification preferences\n\n3. Update `.env.example` and `.env.prod.example` files:\n   - Add SENTRY_DSN placeholder with comment\n   - Add SENTRY_AUTH_TOKEN for CI/CD\n   - Add SENTRY_ORG and SENTRY_PROJECT vars\n\n4. Add environment variables documentation:\n   - Update CLAUDE.md environment variables section\n   - Document required vs optional Sentry config\n\n5. Create verification checklist:\n   - [ ] Trigger test error in dev\n   - [ ] Verify error appears in Sentry with correct stack trace\n   - [ ] Verify source maps resolve to original code\n   - [ ] Verify sensitive data is scrubbed\n   - [ ] Verify alerts fire on test errors\n   - [ ] Test performance monitoring captures traces",
            "status": "pending",
            "testStrategy": "1. Manual test: Hit /debug/sentry-test endpoint, verify error in Sentry dashboard\n2. Verify stack traces: Confirm line numbers match source TypeScript/Python\n3. Verify scrubbing: Add auth header to test request, confirm it's not in Sentry\n4. Alert test: Trigger multiple errors rapidly, verify alert notification received\n5. Performance test: Make slow request, verify trace appears in Performance tab\n6. Documentation review: Have team member follow setup guide successfully",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 32,
        "title": "Create Database Backup Script",
        "description": "Create a backup script for database exports with support for S3-compatible storage, retention policies, and restore procedures for the Supabase free tier.",
        "details": "**Note:** Supabase Pro tier includes automatic backups. This script is for free tier users.\n\n**Create `scripts/deploy/backup-database.sh`:**\n```bash\n#!/bin/bash\nset -e\n\n# =============================================================================\n# Nutri Database Backup Script\n# For use with Supabase free tier (no automatic backups)\n# =============================================================================\n\necho \"=== Nutri Database Backup ===\"\necho \"Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n\n# Configuration\nBACKUP_DIR=\"${BACKUP_DIR:-/backups}\"\nRETENTION_DAYS=\"${RETENTION_DAYS:-7}\"\nS3_BUCKET=\"${S3_BUCKET:-}\"\nS3_ENDPOINT=\"${S3_ENDPOINT:-}\"\n\n# Validate required environment variables\nif [ -z \"$DATABASE_URL\" ]; then\n    echo \"Error: DATABASE_URL is required\"\n    exit 1\nfi\n\n# Create backup directory\nmkdir -p \"$BACKUP_DIR\"\n\n# Generate backup filename\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nBACKUP_FILE=\"nutri_backup_${TIMESTAMP}.sql.gz\"\nBACKUP_PATH=\"$BACKUP_DIR/$BACKUP_FILE\"\n\n# Extract connection details from DATABASE_URL\n# Format: postgresql://user:password@host:port/database\nproto=\"$(echo $DATABASE_URL | grep :// | sed -e's,^\\(.*://\\).*,\\1,g')\"\nurl=\"$(echo ${DATABASE_URL/$proto/})\"\nuser=\"$(echo $url | grep @ | cut -d@ -f1 | cut -d: -f1)\"\npassword=\"$(echo $url | grep @ | cut -d@ -f1 | cut -d: -f2)\"\nhostport=\"$(echo ${url/$user:$password@/} | cut -d/ -f1)\"\nhost=\"$(echo $hostport | cut -d: -f1)\"\nport=\"$(echo $hostport | cut -d: -f2)\"\ndatabase=\"$(echo $url | grep / | cut -d/ -f2-)\"\n\necho \"Backing up database: $database on $host\"\n\n# Create backup with pg_dump\nexport PGPASSWORD=\"$password\"\npg_dump -h \"$host\" -p \"$port\" -U \"$user\" -d \"$database\" \\\n    --format=custom \\\n    --no-owner \\\n    --no-acl \\\n    --verbose 2>&1 | gzip > \"$BACKUP_PATH\"\n\nBACKUP_SIZE=$(ls -lh \"$BACKUP_PATH\" | awk '{print $5}')\necho \"Backup created: $BACKUP_PATH ($BACKUP_SIZE)\"\n\n# Upload to S3 if configured\nif [ -n \"$S3_BUCKET\" ]; then\n    echo \"Uploading to S3: $S3_BUCKET\"\n    \n    S3_PATH=\"s3://$S3_BUCKET/nutri/backups/$BACKUP_FILE\"\n    \n    if [ -n \"$S3_ENDPOINT\" ]; then\n        # For S3-compatible storage (Backblaze B2, MinIO, etc.)\n        aws s3 cp \"$BACKUP_PATH\" \"$S3_PATH\" --endpoint-url \"$S3_ENDPOINT\"\n    else\n        aws s3 cp \"$BACKUP_PATH\" \"$S3_PATH\"\n    fi\n    \n    echo \"Uploaded to: $S3_PATH\"\n    \n    # Remove local file after S3 upload\n    rm \"$BACKUP_PATH\"\n    echo \"Local backup removed (stored in S3)\"\nfi\n\n# Clean up old backups\necho \"Cleaning up backups older than $RETENTION_DAYS days...\"\nfind \"$BACKUP_DIR\" -name \"nutri_backup_*.sql.gz\" -mtime +$RETENTION_DAYS -delete 2>/dev/null || true\n\n# S3 lifecycle should handle S3 cleanup, but we can list what's there\nif [ -n \"$S3_BUCKET\" ]; then\n    echo \"Current S3 backups:\"\n    aws s3 ls \"s3://$S3_BUCKET/nutri/backups/\" ${S3_ENDPOINT:+--endpoint-url $S3_ENDPOINT} | tail -5\nfi\n\necho \"\"\necho \"=== Backup Complete ===\"\n```\n\n**Create `scripts/deploy/restore-database.sh`:**\n```bash\n#!/bin/bash\nset -e\n\n# =============================================================================\n# Nutri Database Restore Script\n# =============================================================================\n\necho \"=== Nutri Database Restore ===\"\necho \"WARNING: This will overwrite the target database!\"\nread -p \"Are you sure? (yes/no): \" confirm\n\nif [ \"$confirm\" != \"yes\" ]; then\n    echo \"Restore cancelled.\"\n    exit 1\nfi\n\nBACKUP_FILE=\"$1\"\n\nif [ -z \"$BACKUP_FILE\" ]; then\n    echo \"Usage: $0 <backup-file.sql.gz>\"\n    echo \"\"\n    echo \"Available backups:\"\n    ls -lh /backups/nutri_backup_*.sql.gz 2>/dev/null || echo \"No local backups found\"\n    exit 1\nfi\n\nif [ -z \"$DATABASE_URL\" ]; then\n    echo \"Error: DATABASE_URL is required\"\n    exit 1\nfi\n\n# Parse DATABASE_URL (same as backup script)\n# ... [parsing code] ...\n\necho \"Restoring from: $BACKUP_FILE\"\necho \"Target database: $database on $host\"\n\nexport PGPASSWORD=\"$password\"\n\n# Restore\ngunzip -c \"$BACKUP_FILE\" | pg_restore \\\n    -h \"$host\" -p \"$port\" -U \"$user\" -d \"$database\" \\\n    --no-owner \\\n    --no-acl \\\n    --clean \\\n    --if-exists \\\n    --verbose\n\necho \"=== Restore Complete ===\"\n```\n\n**Create cron job for automated backups:**\n```bash\n# Add to server crontab\n0 3 * * * /opt/nutri/scripts/backup-database.sh >> /var/log/nutri-backup.log 2>&1\n```\n\n**Document in `docs/deployment/BACKUPS.md`:**\n```markdown\n# Backup and Recovery\n\n## Automatic Backups\n\n- **Supabase Pro:** Automatic daily backups included\n- **Supabase Free:** Use `scripts/deploy/backup-database.sh` with cron\n\n## Manual Backup\n\n```bash\nexport DATABASE_URL=\"postgresql://...\"\n./scripts/deploy/backup-database.sh\n```\n\n## Restore Procedure\n\n1. Download backup file\n2. Run restore script:\n   ```bash\n   ./scripts/deploy/restore-database.sh /path/to/backup.sql.gz\n   ```\n3. Verify data integrity\n4. Run migrations if needed: `npx prisma migrate deploy`\n```",
        "testStrategy": "1. Run backup script against dev database\n2. Verify backup file created and valid: `gunzip -t backup.sql.gz`\n3. Test restore to empty test database\n4. Verify data integrity after restore\n5. Test S3 upload with Backblaze B2 or MinIO\n6. Verify retention policy deletes old files\n7. Test cron job execution\n8. Document recovery time (RTO target: <30 min)",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create backup-database.sh script with pg_dump and compression",
            "description": "Create the main database backup script at scripts/deploy/backup-database.sh with pg_dump, gzip compression, and configurable retention policy",
            "dependencies": [],
            "details": "Create scripts/deploy/backup-database.sh implementing:\n\n1. Environment variable parsing:\n   - DATABASE_URL (required) - PostgreSQL connection string\n   - BACKUP_DIR (default: /backups) - Local backup storage\n   - RETENTION_DAYS (default: 7) - Days to keep backups\n\n2. Database URL parsing to extract host, port, user, password, database from postgresql://user:password@host:port/database format\n\n3. Core backup functionality:\n   - Use pg_dump with --format=custom for efficient restore\n   - Add --no-owner and --no-acl flags (Supabase uses pooler roles)\n   - Pipe through gzip for compression\n   - Generate timestamped filename: nutri_backup_YYYYMMDD_HHMMSS.sql.gz\n\n4. Local retention cleanup:\n   - Use find -mtime +$RETENTION_DAYS to delete old backups\n   - Display backup size after creation\n\n5. Error handling:\n   - Exit on error (set -e)\n   - Validate required DATABASE_URL\n   - Show helpful error messages\n\n6. Follow existing script patterns from scripts/deploy/migrate.sh:\n   - Color-coded output (RED/GREEN/YELLOW/BLUE)\n   - Timestamp header\n   - Clear section organization",
            "status": "pending",
            "testStrategy": "1. Run with DATABASE_URL pointing to local dev database\n2. Verify backup file created in BACKUP_DIR with correct naming\n3. Validate gzip integrity: gunzip -t backup.sql.gz\n4. Test restore to empty database with pg_restore\n5. Test retention cleanup by creating old test files\n6. Test error handling with missing/invalid DATABASE_URL",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add S3/B2 cloud storage upload support to backup script",
            "description": "Extend backup-database.sh to support uploading backups to S3-compatible storage providers (AWS S3, Backblaze B2, MinIO)",
            "dependencies": [
              1
            ],
            "details": "Extend scripts/deploy/backup-database.sh with cloud upload:\n\n1. Add environment variables:\n   - S3_BUCKET - Bucket name (enables upload when set)\n   - S3_ENDPOINT - Custom endpoint for B2/MinIO (optional)\n   - AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY - Standard AWS env vars\n\n2. Implement upload logic:\n   - Upload to s3://$S3_BUCKET/nutri/backups/$BACKUP_FILE\n   - Use --endpoint-url flag for S3-compatible providers\n   - Remove local file after successful S3 upload\n   - List recent S3 backups (tail -5) after upload\n\n3. Provider-specific notes:\n   - AWS S3: Use default endpoint\n   - Backblaze B2: Set S3_ENDPOINT=https://s3.us-west-000.backblazeb2.com\n   - MinIO: Set S3_ENDPOINT to MinIO server URL\n\n4. S3 lifecycle policy recommendation:\n   - Document that S3 lifecycle rules should handle cloud retention\n   - Suggest 30-day retention policy in S3 bucket settings\n\n5. Error handling:\n   - Verify aws CLI is available before upload\n   - Keep local backup if S3 upload fails\n   - Clear error messages for S3 configuration issues",
            "status": "pending",
            "testStrategy": "1. Test with MinIO container locally: docker run -p 9000:9000 minio/minio server /data\n2. Test with Backblaze B2 free tier (10GB free)\n3. Verify upload to S3-compatible endpoint\n4. Test fallback when S3 upload fails\n5. Verify local cleanup after successful upload\n6. Test bucket listing functionality",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement restore-database.sh script with safety checks",
            "description": "Create the database restore script at scripts/deploy/restore-database.sh with interactive confirmation, validation, and clear restore process",
            "dependencies": [
              1
            ],
            "details": "Create scripts/deploy/restore-database.sh implementing:\n\n1. Safety features:\n   - Interactive confirmation prompt (yes/no)\n   - Clear warning about data overwrite\n   - Display target database name before restore\n   - Option to download from S3 if backup file path starts with s3://\n\n2. Command-line interface:\n   - Usage: ./restore-database.sh <backup-file.sql.gz>\n   - Show available local backups when no argument provided\n   - Support both .sql.gz (compressed) and .sql (uncompressed) files\n\n3. Restore implementation:\n   - Parse DATABASE_URL same as backup script\n   - Use pg_restore for --format=custom backups\n   - Add --clean --if-exists for safe overwrite\n   - Add --no-owner --no-acl for Supabase compatibility\n   - Use --verbose for progress output\n\n4. S3 restore support:\n   - Detect s3:// paths and download first\n   - Use aws s3 cp with --endpoint-url if S3_ENDPOINT set\n   - Clean up downloaded file after restore\n\n5. Post-restore guidance:\n   - Remind to verify data integrity\n   - Suggest running migrations: npx prisma migrate deploy\n   - Show basic verification queries",
            "status": "pending",
            "testStrategy": "1. Create test database and backup it\n2. Restore to separate test database\n3. Verify data integrity with COUNT queries\n4. Test confirmation prompt cancellation\n5. Test error handling with corrupted backup\n6. Test S3 download path detection\n7. Verify Prisma migrations work after restore",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Document backup procedures and set up cron job configuration",
            "description": "Create comprehensive backup documentation at docs/deployment/BACKUPS.md and provide cron job examples for automated backups",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create docs/deployment/BACKUPS.md with:\n\n1. Overview section:\n   - Explain Supabase Pro vs Free tier backup differences\n   - Link to Supabase backup documentation\n   - When to use this script (free tier, custom requirements)\n\n2. Prerequisites:\n   - Required tools: pg_dump, gzip, aws CLI (for S3)\n   - Environment variables reference\n   - S3 bucket setup for different providers\n\n3. Manual backup guide:\n   - Step-by-step commands\n   - Example with local storage\n   - Example with S3/B2 upload\n\n4. Automated backup setup:\n   - Cron job example: 0 3 * * * /opt/nutri/scripts/deploy/backup-database.sh >> /var/log/nutri-backup.log 2>&1\n   - Systemd timer alternative (more modern)\n   - Log rotation configuration\n\n5. Restore procedures:\n   - Emergency restore checklist\n   - Restore from local backup\n   - Restore from S3\n   - Post-restore verification steps\n   - Migration after restore\n\n6. Update existing docs:\n   - Add link from docs/deployment/RUNBOOK.md Backup & Recovery section\n   - Update docs/deployment/README.md quick links\n\n7. Backup verification:\n   - Monthly backup test procedure\n   - Data integrity verification queries",
            "status": "pending",
            "testStrategy": "1. Follow documentation to set up backup on fresh system\n2. Verify all commands in documentation work\n3. Test cron job configuration syntax\n4. Have team member review documentation clarity\n5. Verify links to related docs work\n6. Test restore procedure following docs only",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 33,
        "title": "Configure Hetzner Server Snapshots",
        "description": "Enable and configure Hetzner automatic server snapshots for disaster recovery with documentation for restore procedures.",
        "details": "**Enable Hetzner Backups via Console:**\n\n1. Log into [Hetzner Cloud Console](https://console.hetzner.cloud/)\n2. Select your server\n3. Go to \"Backups\" tab\n4. Click \"Enable Backups\"\n   - Cost: ~20% of server price (€1.10/mo for CX32)\n   - Schedule: Daily automatic backups\n   - Retention: Last 7 daily + 4 weekly backups\n\n**Or via Hetzner CLI/API:**\n```bash\n# Install hcloud CLI\nbrew install hcloud\n\n# Configure\nhcloud context create nutri\n# Enter API token from Hetzner Console > Security > API Tokens\n\n# Enable backups on server\nhcloud server enable-backup <server-name>\n```\n\n**Create Manual Snapshot Script `scripts/deploy/create-snapshot.sh`:**\n```bash\n#!/bin/bash\nset -e\n\n# =============================================================================\n# Create Hetzner Server Snapshot\n# Use before major deployments or configuration changes\n# =============================================================================\n\nSERVER_NAME=\"${SERVER_NAME:-nutri-production}\"\nSNAPSHOT_DESC=\"${1:-Manual snapshot $(date +%Y-%m-%d_%H%M)}\"\n\necho \"=== Creating Hetzner Snapshot ===\"\necho \"Server: $SERVER_NAME\"\necho \"Description: $SNAPSHOT_DESC\"\necho \"\"\n\n# Check if hcloud is installed\nif ! command -v hcloud &> /dev/null; then\n    echo \"Error: hcloud CLI not installed\"\n    echo \"Install with: brew install hcloud\"\n    exit 1\nfi\n\n# Create snapshot\necho \"Creating snapshot (this may take a few minutes)...\"\nhcloud server create-image --type snapshot --description \"$SNAPSHOT_DESC\" \"$SERVER_NAME\"\n\necho \"\"\necho \"=== Snapshot Created ===\"\necho \"\"\necho \"Available snapshots:\"\nhcloud image list --type snapshot\n```\n\n**Document Restore Procedure in `docs/deployment/DISASTER-RECOVERY.md`:**\n```markdown\n# Disaster Recovery\n\n## Server Snapshot Recovery\n\n### When to Use\n- Server is unrecoverable\n- Corrupted system files\n- Major misconfiguration\n\n### Restore Steps\n\n1. **Via Hetzner Console:**\n   - Go to Images > Snapshots\n   - Select snapshot to restore\n   - Click \"Create Server from Image\"\n   - Configure same specs as original server\n   - Update DNS to point to new server IP\n\n2. **Via CLI:**\n   ```bash\n   # List available snapshots\n   hcloud image list --type snapshot\n   \n   # Create new server from snapshot\n   hcloud server create \\\n     --name nutri-production-restored \\\n     --type cx32 \\\n     --image <snapshot-id> \\\n     --location nbg1\n   \n   # Update DNS\n   # ... update A record to new IP\n   ```\n\n3. **Post-Restore Checklist:**\n   - [ ] Verify server accessible via SSH\n   - [ ] Check Coolify dashboard\n   - [ ] Verify all containers running\n   - [ ] Test health endpoints\n   - [ ] Update DNS if IP changed\n   - [ ] Update GitHub secrets with new webhook URLs\n\n### Recovery Time Estimate\n\n| Step | Duration |\n|------|----------|\n| Create server from snapshot | 5-10 min |\n| DNS propagation | 5-30 min |\n| Verify services | 5 min |\n| **Total** | **15-45 min** |\n\n## Monthly Recovery Test\n\nSchedule monthly recovery drill:\n1. Create snapshot of production\n2. Spin up test server from snapshot\n3. Verify services work\n4. Document any issues\n5. Delete test server\n```",
        "testStrategy": "1. Enable backups in Hetzner Console\n2. Create manual snapshot using script\n3. Verify snapshot appears in console\n4. Test restore by creating new server from snapshot\n5. Verify restored server has correct configuration\n6. Document actual recovery time\n7. Delete test server after verification\n8. Set up monthly recovery test reminder",
        "priority": "medium",
        "dependencies": [
          "28"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Configure Server Security Hardening",
        "description": "Implement additional security hardening measures including SSH hardening, intrusion detection setup, and kernel security parameters.",
        "details": "**Create `scripts/deploy/harden-server.sh`:**\n```bash\n#!/bin/bash\nset -e\n\n# =============================================================================\n# Nutri Server Security Hardening\n# Run after initial setup script\n# =============================================================================\n\necho \"=== Security Hardening ===\"\n\n# =============================================================================\n# SSH Hardening\n# =============================================================================\n\necho \"Hardening SSH configuration...\"\ncat >> /etc/ssh/sshd_config << 'EOF'\n\n# Nutri Security Hardening\nProtocol 2\nMaxAuthTries 3\nMaxSessions 5\nLoginGraceTime 30\nClientAliveInterval 300\nClientAliveCountMax 2\nPermitEmptyPasswords no\nX11Forwarding no\nAllowTcpForwarding no\nAllowAgentForwarding no\nPermitUserEnvironment no\nEOF\n\n# Restart SSH\nsystemctl restart sshd\necho \"SSH hardened\"\n\n# =============================================================================\n# Kernel Security Parameters\n# =============================================================================\n\necho \"Configuring kernel security parameters...\"\ncat >> /etc/sysctl.conf << 'EOF'\n\n# Nutri Security Hardening\n\n# Network security\nnet.ipv4.tcp_syncookies = 1\nnet.ipv4.tcp_max_syn_backlog = 2048\nnet.ipv4.tcp_synack_retries = 2\nnet.ipv4.conf.all.rp_filter = 1\nnet.ipv4.conf.default.rp_filter = 1\nnet.ipv4.conf.all.accept_source_route = 0\nnet.ipv4.conf.default.accept_source_route = 0\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv4.conf.default.accept_redirects = 0\nnet.ipv4.conf.all.send_redirects = 0\nnet.ipv4.conf.default.send_redirects = 0\nnet.ipv4.icmp_echo_ignore_broadcasts = 1\nnet.ipv4.icmp_ignore_bogus_error_responses = 1\n\n# Disable IPv6 if not needed\nnet.ipv6.conf.all.disable_ipv6 = 1\nnet.ipv6.conf.default.disable_ipv6 = 1\n\n# Memory protection\nkernel.randomize_va_space = 2\nkernel.dmesg_restrict = 1\nkernel.kptr_restrict = 2\nEOF\n\nsysctl -p\necho \"Kernel parameters configured\"\n\n# =============================================================================\n# Advanced Fail2Ban Configuration\n# =============================================================================\n\necho \"Configuring advanced fail2ban rules...\"\ncat > /etc/fail2ban/jail.d/nutri.conf << 'EOF'\n[nutri-api]\nenabled = true\nport = http,https\nfilter = nutri-api\nlogpath = /var/log/docker-nutri-backend.log\nmaxretry = 10\nfindtime = 60\nbantime = 3600\nEOF\n\ncat > /etc/fail2ban/filter.d/nutri-api.conf << 'EOF'\n[Definition]\nfailregex = ^.*\"statusCode\":401.*\"ip\":\"<HOST>\".*$\n            ^.*\"statusCode\":403.*\"ip\":\"<HOST>\".*$\nignoreregex =\nEOF\n\nsystemctl restart fail2ban\necho \"Fail2ban configured for API protection\"\n\n# =============================================================================\n# Docker Security\n# =============================================================================\n\necho \"Configuring Docker security...\"\ncat > /etc/docker/daemon.json << 'EOF'\n{\n  \"icc\": false,\n  \"userns-remap\": \"default\",\n  \"no-new-privileges\": true,\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  },\n  \"live-restore\": true\n}\nEOF\n\nsystemctl restart docker\necho \"Docker security configured\"\n\n# =============================================================================\n# File Permissions\n# =============================================================================\n\necho \"Securing file permissions...\"\nchmod 700 /root\nchmod 600 /etc/ssh/sshd_config\nchmod 644 /etc/passwd\nchmod 000 /etc/shadow  # Only root can read\nchmod 644 /etc/group\n\n# =============================================================================\n# Login Banner\n# =============================================================================\n\ncat > /etc/issue.net << 'EOF'\n***************************************************************************\n                      AUTHORIZED ACCESS ONLY\n***************************************************************************\nThis system is for authorized use only. All activities may be monitored\nand recorded. Unauthorized access will be prosecuted.\n***************************************************************************\nEOF\n\necho \"Banner /etc/issue.net\" >> /etc/ssh/sshd_config\nsystemctl restart sshd\n\necho \"\"\necho \"=== Security Hardening Complete ===\"\necho \"\"\necho \"Verify changes:\"\necho \"- SSH: ssh to server, should still work\"\necho \"- Fail2ban: fail2ban-client status\"\necho \"- Sysctl: sysctl -a | grep net.ipv4.tcp_syncookies\"\n```\n\n**Security Checklist `docs/deployment/SECURITY-CHECKLIST.md`:**\n```markdown\n# Security Checklist\n\n## Pre-Deployment\n\n- [ ] SSH keys configured, password auth disabled\n- [ ] UFW firewall enabled (22, 80, 443 only)\n- [ ] Fail2ban active and configured\n- [ ] Automatic security updates enabled\n- [ ] Kernel security parameters applied\n- [ ] Docker security settings configured\n\n## Application Security\n\n- [ ] All secrets stored in environment variables\n- [ ] No secrets in source code or logs\n- [ ] HTTPS enforced (redirect HTTP)\n- [ ] Security headers configured (HSTS, CSP)\n- [ ] Rate limiting enabled\n- [ ] CORS properly configured\n\n## Monitoring\n\n- [ ] Failed SSH attempts monitored\n- [ ] API abuse patterns monitored\n- [ ] Error tracking enabled (Sentry)\n- [ ] Uptime monitoring configured\n\n## Backup & Recovery\n\n- [ ] Database backups automated\n- [ ] Server snapshots enabled\n- [ ] Recovery procedure tested\n```",
        "testStrategy": "1. Run hardening script on test server\n2. Verify SSH still works with key auth\n3. Verify password auth fails\n4. Test fail2ban bans IP after failed attempts\n5. Verify kernel parameters with sysctl -a\n6. Test Docker containers still run\n7. Run security scanner (lynis) and compare scores\n8. Document any issues for production",
        "priority": "medium",
        "dependencies": [
          "28"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Configure Application Security Headers",
        "description": "Implement security headers (HSTS, CSP, X-Frame-Options, etc.) in the backend API and configure HTTPS-only access with proper CORS settings.",
        "details": "**Install helmet for Express:**\n```bash\ncd server && npm install helmet\n```\n\n**Create `server/src/middleware/security.ts`:**\n```typescript\nimport helmet from 'helmet';\nimport { Express, Request, Response, NextFunction } from 'express';\n\nexport function configureSecurityHeaders(app: Express): void {\n  // Basic helmet protection\n  app.use(helmet());\n\n  // Strict Transport Security (HTTPS only)\n  app.use(\n    helmet.hsts({\n      maxAge: 31536000, // 1 year in seconds\n      includeSubDomains: true,\n      preload: true,\n    })\n  );\n\n  // Content Security Policy\n  app.use(\n    helmet.contentSecurityPolicy({\n      directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"], // React may need inline styles\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        connectSrc: [\"'self'\", 'https://api.nutri.app'],\n        fontSrc: [\"'self'\"],\n        objectSrc: [\"'none'\"],\n        mediaSrc: [\"'self'\"],\n        frameSrc: [\"'none'\"],\n      },\n    })\n  );\n\n  // Prevent clickjacking\n  app.use(helmet.frameguard({ action: 'deny' }));\n\n  // Prevent MIME type sniffing\n  app.use(helmet.noSniff());\n\n  // XSS protection (legacy browsers)\n  app.use(helmet.xssFilter());\n\n  // Referrer policy\n  app.use(helmet.referrerPolicy({ policy: 'strict-origin-when-cross-origin' }));\n\n  // Remove X-Powered-By header\n  app.disable('x-powered-by');\n\n  // Custom security headers\n  app.use((_req: Request, res: Response, next: NextFunction) => {\n    // Permissions Policy (replaces Feature-Policy)\n    res.setHeader(\n      'Permissions-Policy',\n      'accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()'\n    );\n    \n    // Cross-Origin policies\n    res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');\n    res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');\n    res.setHeader('Cross-Origin-Resource-Policy', 'same-origin');\n    \n    next();\n  });\n}\n```\n\n**Update CORS configuration in `server/src/index.ts`:**\n```typescript\nimport cors from 'cors';\nimport { configureSecurityHeaders } from './middleware/security';\n\nconst app = express();\n\n// Configure CORS with specific origins\nconst allowedOrigins = [\n  'http://localhost:3000',\n  'http://localhost:8081', // Expo dev\n  'https://nutri.app',\n  'https://www.nutri.app',\n  process.env.CORS_ORIGIN, // Allow override via env\n].filter(Boolean);\n\napp.use(\n  cors({\n    origin: (origin, callback) => {\n      // Allow requests with no origin (mobile apps, curl, etc.)\n      if (!origin) return callback(null, true);\n      \n      if (allowedOrigins.includes(origin)) {\n        callback(null, true);\n      } else {\n        callback(new Error('Not allowed by CORS'));\n      }\n    },\n    credentials: true,\n    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n    allowedHeaders: ['Content-Type', 'Authorization', 'X-Correlation-ID'],\n    exposedHeaders: ['X-Correlation-ID'],\n    maxAge: 86400, // 24 hours\n  })\n);\n\n// Configure security headers\nconfigureSecurityHeaders(app);\n```\n\n**Add HTTPS redirect middleware (for when behind Traefik/reverse proxy):**\n```typescript\n// Trust proxy (Traefik)\napp.set('trust proxy', 1);\n\n// Redirect HTTP to HTTPS in production\nif (process.env.NODE_ENV === 'production') {\n  app.use((req, res, next) => {\n    if (req.header('x-forwarded-proto') !== 'https') {\n      res.redirect(301, `https://${req.header('host')}${req.url}`);\n    } else {\n      next();\n    }\n  });\n}\n```\n\n**Test headers with curl:**\n```bash\ncurl -I https://api.nutri.app/health\n```\n\nExpected headers:\n```\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\nX-Content-Type-Options: nosniff\nX-Frame-Options: DENY\nContent-Security-Policy: default-src 'self'; ...\nReferrer-Policy: strict-origin-when-cross-origin\n```",
        "testStrategy": "1. Add security middleware and verify app still works\n2. Test all API endpoints work with new CORS config\n3. Use securityheaders.com to scan API and verify A+ rating\n4. Test mobile app still connects with CORS\n5. Verify X-Powered-By header is removed\n6. Test HTTPS redirect works in production mode\n7. Verify CSP doesn't break legitimate requests\n8. Test preflight OPTIONS requests work correctly",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Configure Dependabot for Security Updates",
        "description": "Enable GitHub Dependabot for automated dependency vulnerability scanning and pull request creation for security updates.",
        "details": "**Create `.github/dependabot.yml`:**\n```yaml\nversion: 2\nupdates:\n  # JavaScript/TypeScript dependencies (root - mobile app)\n  - package-ecosystem: \"npm\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n      day: \"monday\"\n      time: \"09:00\"\n      timezone: \"UTC\"\n    open-pull-requests-limit: 10\n    labels:\n      - \"dependencies\"\n      - \"mobile\"\n    reviewers:\n      - \"onurtemizkan\"\n    commit-message:\n      prefix: \"deps(mobile):\"\n    ignore:\n      # Ignore major version updates for React Native (can be breaking)\n      - dependency-name: \"react-native\"\n        update-types: [\"version-update:semver-major\"]\n      - dependency-name: \"expo\"\n        update-types: [\"version-update:semver-major\"]\n\n  # Backend dependencies\n  - package-ecosystem: \"npm\"\n    directory: \"/server\"\n    schedule:\n      interval: \"weekly\"\n      day: \"monday\"\n      time: \"09:00\"\n      timezone: \"UTC\"\n    open-pull-requests-limit: 10\n    labels:\n      - \"dependencies\"\n      - \"backend\"\n    reviewers:\n      - \"onurtemizkan\"\n    commit-message:\n      prefix: \"deps(server):\"\n    groups:\n      # Group minor and patch updates together\n      production-dependencies:\n        patterns:\n          - \"*\"\n        exclude-patterns:\n          - \"@types/*\"\n          - \"typescript\"\n        update-types:\n          - \"minor\"\n          - \"patch\"\n\n  # Python ML Service dependencies\n  - package-ecosystem: \"pip\"\n    directory: \"/ml-service\"\n    schedule:\n      interval: \"weekly\"\n      day: \"tuesday\"\n      time: \"09:00\"\n      timezone: \"UTC\"\n    open-pull-requests-limit: 5\n    labels:\n      - \"dependencies\"\n      - \"ml-service\"\n    reviewers:\n      - \"onurtemizkan\"\n    commit-message:\n      prefix: \"deps(ml):\"\n    ignore:\n      # ML libraries can have breaking changes\n      - dependency-name: \"torch\"\n        update-types: [\"version-update:semver-major\"]\n      - dependency-name: \"scikit-learn\"\n        update-types: [\"version-update:semver-major\"]\n\n  # GitHub Actions\n  - package-ecosystem: \"github-actions\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n      day: \"wednesday\"\n      time: \"09:00\"\n      timezone: \"UTC\"\n    labels:\n      - \"dependencies\"\n      - \"ci\"\n    commit-message:\n      prefix: \"ci:\"\n\n  # Docker base images\n  - package-ecosystem: \"docker\"\n    directory: \"/server\"\n    schedule:\n      interval: \"weekly\"\n      day: \"thursday\"\n    labels:\n      - \"dependencies\"\n      - \"docker\"\n    commit-message:\n      prefix: \"docker(server):\"\n\n  - package-ecosystem: \"docker\"\n    directory: \"/ml-service\"\n    schedule:\n      interval: \"weekly\"\n      day: \"thursday\"\n    labels:\n      - \"dependencies\"\n      - \"docker\"\n    commit-message:\n      prefix: \"docker(ml):\"\n```\n\n**Enable GitHub Security Features:**\n\n1. Go to repository Settings > Security > Code security and analysis\n2. Enable:\n   - Dependency graph\n   - Dependabot alerts\n   - Dependabot security updates\n   - Secret scanning\n   - Push protection\n\n**Create security policy `.github/SECURITY.md`:**\n```markdown\n# Security Policy\n\n## Supported Versions\n\n| Version | Supported          |\n| ------- | ------------------ |\n| latest  | :white_check_mark: |\n\n## Reporting a Vulnerability\n\nPlease report security vulnerabilities by emailing security@nutri.app.\n\nDo NOT create public GitHub issues for security vulnerabilities.\n\n### Response Timeline\n\n- Initial response: 24 hours\n- Triage: 48 hours\n- Fix timeline: Depends on severity\n  - Critical: 24-48 hours\n  - High: 7 days\n  - Medium: 30 days\n  - Low: Next release\n\n## Security Measures\n\n- All dependencies automatically scanned\n- Security updates applied weekly\n- Docker images scanned for vulnerabilities\n- Secrets scanning enabled\n```\n\n**Document in `docs/deployment/SECURITY-UPDATES.md`:**\n```markdown\n# Dependency Security Updates\n\n## Automated Updates\n\nDependabot creates PRs for:\n- npm packages (mobile, server)\n- pip packages (ml-service)\n- GitHub Actions versions\n- Docker base images\n\n## Weekly Schedule\n\n| Day | Package Ecosystem |\n|-----|-------------------|\n| Monday | npm (mobile, server) |\n| Tuesday | pip (ml-service) |\n| Wednesday | GitHub Actions |\n| Thursday | Docker images |\n\n## Handling PRs\n\n1. Review changes and changelogs\n2. Run CI checks\n3. Merge if tests pass\n4. For breaking changes, test manually first\n```",
        "testStrategy": "1. Commit dependabot.yml and verify it appears in Insights > Dependency graph > Dependabot\n2. Manually trigger dependency check: Settings > Security > Code security\n3. Wait for first PRs to appear (within a week)\n4. Verify PR labels and commit message format\n5. Check grouping works for minor/patch updates\n6. Verify ignore rules work (no major React Native PRs)\n7. Test that CI runs on Dependabot PRs\n8. Enable secret scanning and verify no alerts",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Create Rollback Script and Procedures",
        "description": "Create a rollback script that can quickly revert to a previous deployment version with both manual and automated options.",
        "details": "**Create `scripts/deploy/rollback.sh`:**\n```bash\n#!/bin/bash\nset -e\n\n# =============================================================================\n# Nutri Rollback Script\n# Rolls back to a previous deployment version\n# =============================================================================\n\necho \"=== Nutri Rollback ===\"\necho \"Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\necho \"\"\n\n# Configuration\nREGISTRY=\"ghcr.io\"\nREPO=\"${GITHUB_REPOSITORY:-your-org/nutri}\"\nBACKEND_IMAGE=\"$REGISTRY/$REPO/backend\"\nML_IMAGE=\"$REGISTRY/$REPO/ml-service\"\n\n# Parse arguments\nTARGET_TAG=\"$1\"\nSERVICE=\"${2:-all}\"  # backend, ml, or all\n\nif [ -z \"$TARGET_TAG\" ]; then\n    echo \"Usage: $0 <image-tag> [service]\"\n    echo \"\"\n    echo \"Arguments:\"\n    echo \"  image-tag   Git SHA or tag to rollback to\"\n    echo \"  service     'backend', 'ml', or 'all' (default: all)\"\n    echo \"\"\n    echo \"Examples:\"\n    echo \"  $0 abc1234              # Rollback all services to abc1234\"\n    echo \"  $0 abc1234 backend      # Rollback only backend\"\n    echo \"\"\n    echo \"Recent tags:\"\n    echo \"--- Backend ---\"\n    curl -s -H \"Authorization: Bearer $GITHUB_TOKEN\" \\\n        \"https://api.github.com/orgs/$(dirname $REPO)/packages/container/$(basename $REPO)%2Fbackend/versions\" \\\n        2>/dev/null | jq -r '.[0:5] | .[].metadata.container.tags[]' 2>/dev/null || echo \"Unable to fetch tags\"\n    exit 1\nfi\n\n# Confirm rollback\necho \"Rolling back to: $TARGET_TAG\"\necho \"Services: $SERVICE\"\necho \"\"\nread -p \"Continue? (yes/no): \" confirm\nif [ \"$confirm\" != \"yes\" ]; then\n    echo \"Rollback cancelled.\"\n    exit 0\nfi\n\n# Function to trigger Coolify deployment\ntrigger_coolify_deploy() {\n    local webhook_url=\"$1\"\n    local service_name=\"$2\"\n    \n    echo \"Triggering $service_name deployment...\"\n    response=$(curl -s -w \"\\n%{http_code}\" -X POST \\\n        -H \"Authorization: Bearer $COOLIFY_WEBHOOK_SECRET\" \\\n        \"$webhook_url\")\n    \n    http_code=$(echo \"$response\" | tail -n1)\n    if [ \"$http_code\" = \"200\" ] || [ \"$http_code\" = \"201\" ]; then\n        echo \"✓ $service_name deployment triggered\"\n    else\n        echo \"✗ $service_name deployment failed (HTTP $http_code)\"\n        return 1\n    fi\n}\n\n# Function to wait for health check\nwait_for_health() {\n    local url=\"$1\"\n    local max_attempts=\"${2:-30}\"\n    \n    echo \"Waiting for $url to be healthy...\"\n    for i in $(seq 1 $max_attempts); do\n        if curl -sf \"$url\" > /dev/null 2>&1; then\n            echo \"✓ Service healthy after $i attempts\"\n            return 0\n        fi\n        sleep 5\n    done\n    echo \"✗ Service not healthy after $max_attempts attempts\"\n    return 1\n}\n\n# Perform rollback\nif [ \"$SERVICE\" = \"all\" ] || [ \"$SERVICE\" = \"backend\" ]; then\n    echo \"\"\n    echo \"=== Rolling back Backend ===\"\n    \n    # Pull the target image\n    docker pull \"$BACKEND_IMAGE:$TARGET_TAG\" || {\n        echo \"Error: Could not pull $BACKEND_IMAGE:$TARGET_TAG\"\n        exit 1\n    }\n    \n    # Tag as latest for Coolify\n    docker tag \"$BACKEND_IMAGE:$TARGET_TAG\" \"$BACKEND_IMAGE:latest\"\n    \n    # Trigger Coolify deployment\n    if [ -n \"$COOLIFY_BACKEND_WEBHOOK_URL\" ]; then\n        trigger_coolify_deploy \"$COOLIFY_BACKEND_WEBHOOK_URL\" \"Backend\"\n    else\n        echo \"Warning: COOLIFY_BACKEND_WEBHOOK_URL not set\"\n        echo \"Manually restart the container in Coolify\"\n    fi\n    \n    # Wait for health\n    sleep 10\n    wait_for_health \"${PRODUCTION_API_URL:-http://localhost:3000}/health\"\nfi\n\nif [ \"$SERVICE\" = \"all\" ] || [ \"$SERVICE\" = \"ml\" ]; then\n    echo \"\"\n    echo \"=== Rolling back ML Service ===\"\n    \n    docker pull \"$ML_IMAGE:$TARGET_TAG\" || {\n        echo \"Error: Could not pull $ML_IMAGE:$TARGET_TAG\"\n        exit 1\n    }\n    \n    docker tag \"$ML_IMAGE:$TARGET_TAG\" \"$ML_IMAGE:latest\"\n    \n    if [ -n \"$COOLIFY_ML_WEBHOOK_URL\" ]; then\n        trigger_coolify_deploy \"$COOLIFY_ML_WEBHOOK_URL\" \"ML Service\"\n    else\n        echo \"Warning: COOLIFY_ML_WEBHOOK_URL not set\"\n    fi\nfi\n\necho \"\"\necho \"=== Rollback Complete ===\"\necho \"Rolled back to: $TARGET_TAG\"\necho \"\"\necho \"Verify deployment:\"\necho \"  curl ${PRODUCTION_API_URL:-http://localhost:3000}/health\"\n```\n\n**Add to deploy workflow (`.github/workflows/deploy.yml`):**\nAlready included workflow_dispatch with image_tag input for manual rollback.\n\n**Document in `docs/deployment/ROLLBACK.md`:**\n```markdown\n# Rollback Procedures\n\n## Quick Rollback via GitHub Actions\n\n1. Go to Actions > Deploy workflow\n2. Click \"Run workflow\"\n3. Enter the image tag/SHA to rollback to\n4. Click \"Run workflow\"\n\n## Manual Rollback via Script\n\n```bash\n# Set required environment variables\nexport COOLIFY_WEBHOOK_SECRET=\"...\"\nexport COOLIFY_BACKEND_WEBHOOK_URL=\"...\"\nexport PRODUCTION_API_URL=\"https://api.nutri.app\"\n\n# Rollback all services to specific commit\n./scripts/deploy/rollback.sh abc1234\n\n# Rollback only backend\n./scripts/deploy/rollback.sh abc1234 backend\n```\n\n## Finding Previous Tags\n\n```bash\n# Via GitHub API\ncurl -H \"Authorization: Bearer $GITHUB_TOKEN\" \\\n  \"https://api.github.com/orgs/your-org/packages/container/nutri%2Fbackend/versions\" \\\n  | jq '.[].metadata.container.tags'\n\n# Via Docker\ndocker pull ghcr.io/your-org/nutri/backend:latest\ndocker history ghcr.io/your-org/nutri/backend:latest\n```\n\n## Rollback Time Target\n\n- Time to initiate: < 2 minutes\n- Deployment time: < 5 minutes\n- **Total rollback time: < 7 minutes**\n```",
        "testStrategy": "1. Deploy a new version to staging\n2. Run rollback script with previous tag\n3. Verify correct image is running: `docker inspect <container> | grep Image`\n4. Test health endpoint responds correctly\n5. Test rollback with invalid tag (should fail gracefully)\n6. Test GitHub Actions manual rollback trigger\n7. Time the entire rollback process (target <5 min)\n8. Test rollback of individual services",
        "priority": "medium",
        "dependencies": [
          "24"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Implement In-App Purchases with Subscription Management",
        "description": "Implement a complete in-app purchase system for selling subscription plans (monthly/yearly) using StoreKit 2, including trial periods, promotional offers, discount codes, purchase restoration, server-side receipt validation, and proper entitlement management.",
        "details": "## Overview\nImplement a production-ready in-app purchase (IAP) system for the Nutri app using Apple's StoreKit 2 framework. The system will support auto-renewable subscriptions with multiple tiers, trial periods, promotional offers, and proper server-side validation.\n\n## Subscription Tiers (Suggested)\n1. **Nutri Free** - Basic tracking, limited history\n2. **Nutri Pro (Monthly)** - Full features, ML insights, unlimited history\n3. **Nutri Pro (Yearly)** - Same as monthly with discount (~2 months free)\n\n## Technical Requirements\n\n### 1. StoreKit 2 Implementation (React Native / Expo)\n- Use `expo-in-app-purchases` or `react-native-iap` (prefer react-native-iap v12+ for StoreKit 2 support)\n- Implement async/await patterns for all StoreKit operations\n- Handle Transaction.updates listener for real-time purchase updates\n- Implement proper transaction finishing to prevent duplicate charges\n- Support for App Store sandbox testing environment\n\n### 2. Product Configuration\n- Configure products in App Store Connect:\n  - `com.nutri.pro.monthly` - Monthly subscription\n  - `com.nutri.pro.yearly` - Yearly subscription\n- Set up subscription groups for upgrade/downgrade paths\n- Configure introductory offers (free trial, pay-up-front, pay-as-you-go)\n- Set up promotional offers for win-back campaigns\n- Configure offer codes for marketing campaigns\n\n### 3. Trial Periods & Offers\n- Free trial: 7-day trial for new subscribers\n- Introductory pricing: First month at 50% discount\n- Promotional offers: Configurable discounts for lapsed subscribers\n- Offer code redemption: Support App Store offer codes\n- Family Sharing: Proper handling if enabled\n\n### 4. Purchase Flow\n- Display subscription options with localized pricing (use Product.displayPrice)\n- Show trial eligibility status (Product.subscription.isEligibleForIntroOffer)\n- Handle purchase confirmation with biometric/password authentication\n- Process successful purchases and grant entitlements immediately\n- Handle purchase failures gracefully with user-friendly messages\n- Support deferred purchases (Ask to Buy for Family Sharing)\n\n### 5. Restore Purchases\n- Implement \"Restore Purchases\" button in settings/paywall\n- Use Transaction.currentEntitlements for efficient restoration\n- Handle cases where no purchases exist to restore\n- Sync restored purchases with backend\n- Required by App Store Review Guidelines\n\n### 6. Server-Side Validation (Backend)\n- Implement App Store Server API integration (not deprecated verifyReceipt)\n- Use App Store Server Notifications V2 for real-time status updates:\n  - SUBSCRIBED, DID_RENEW, DID_CHANGE_RENEWAL_STATUS\n  - DID_FAIL_TO_RENEW, EXPIRED, REFUND, REVOKE\n  - OFFER_REDEEMED, GRACE_PERIOD_EXPIRED\n- Store subscription status in database with proper schema\n- Handle billing retry state and grace periods\n- Implement JWT-based authentication for App Store Server API\n\n### 7. Entitlement Management\n- Create EntitlementService for checking subscription status\n- Cache entitlements locally with secure storage\n- Sync entitlements on app launch and purchase events\n- Handle offline entitlement checking gracefully\n- Implement feature flags based on subscription tier\n\n### 8. Database Schema (Prisma)\n```prisma\nmodel Subscription {\n  id                    String   @id @default(cuid())\n  userId                String   @unique\n  user                  User     @relation(fields: [userId], references: [id])\n  productId             String   // e.g., \"com.nutri.pro.monthly\"\n  originalTransactionId String   @unique\n  status                SubscriptionStatus\n  expiresAt             DateTime\n  isTrialPeriod         Boolean  @default(false)\n  isIntroOfferPeriod    Boolean  @default(false)\n  autoRenewEnabled      Boolean  @default(true)\n  gracePeriodExpiresAt  DateTime?\n  billingRetryPeriod    Boolean  @default(false)\n  priceLocale           String?\n  priceCurrency         String?\n  priceAmount           Decimal?\n  environment           String   // \"sandbox\" or \"production\"\n  createdAt             DateTime @default(now())\n  updatedAt             DateTime @updatedAt\n  \n  @@index([userId])\n  @@index([originalTransactionId])\n  @@index([status, expiresAt])\n}\n\nenum SubscriptionStatus {\n  ACTIVE\n  EXPIRED\n  IN_GRACE_PERIOD\n  IN_BILLING_RETRY\n  REVOKED\n  REFUNDED\n}\n\nmodel SubscriptionEvent {\n  id                    String   @id @default(cuid())\n  subscriptionId        String\n  subscription          Subscription @relation(fields: [subscriptionId], references: [id])\n  notificationType      String   // App Store notification type\n  subtype               String?\n  transactionId         String\n  originalTransactionId String\n  eventData             Json\n  processedAt           DateTime @default(now())\n  \n  @@index([subscriptionId])\n  @@index([originalTransactionId])\n}\n```\n\n### 9. UI Components\n- **PaywallScreen**: Full-screen subscription offering\n  - Feature comparison between tiers\n  - Localized pricing with trial info\n  - Terms of Service and Privacy Policy links (required)\n  - Restore Purchases button\n- **SubscriptionBadge**: Show Pro status in UI\n- **UpgradePrompt**: Contextual upgrade nudges\n- **ManageSubscriptionScreen**: View current plan, link to App Store management\n\n### 10. Security Considerations\n- Never trust client-side purchase verification alone\n- Always validate with App Store Server API\n- Use App Store Server Notifications for authoritative status\n- Protect webhook endpoint with signature verification\n- Store sensitive data (transaction IDs) securely\n- Implement proper error handling to prevent purchase fraud\n\n### 11. Testing Strategy\n- Use StoreKit Testing in Xcode for local testing\n- Test in App Store Sandbox environment\n- Test all subscription states:\n  - New subscription, renewal, expiration\n  - Trial to paid conversion\n  - Upgrade/downgrade between tiers\n  - Cancellation and re-subscription\n  - Billing issues and grace period\n  - Refunds and revocation\n- Test Family Sharing scenarios if enabled\n- Test Ask to Buy (deferred transactions)\n- Test restore purchases flow\n\n### 12. Analytics & Monitoring\n- Track subscription events for analytics\n- Monitor conversion rates (trial to paid)\n- Track churn and retention metrics\n- Alert on unusual refund patterns\n- Log all webhook processing for debugging\n\n### 13. App Store Review Compliance\n- Include \"Restore Purchases\" functionality\n- Display subscription terms clearly\n- Link to Terms of Service and Privacy Policy\n- Handle all edge cases gracefully\n- Proper error messages for users\n\n## Dependencies\n- Requires App Store Connect configuration\n- Requires Apple Developer Program membership\n- Backend webhook endpoint for notifications\n- Expo development build (not Expo Go) for IAP testing\n\n## Files to Create/Modify\n\n### Mobile (React Native/Expo)\n- `lib/services/purchases/` - Purchase service directory\n  - `index.ts` - Main purchase service\n  - `types.ts` - TypeScript interfaces\n  - `products.ts` - Product ID constants\n  - `entitlements.ts` - Entitlement checking\n- `lib/context/SubscriptionContext.tsx` - React context for subscription state\n- `lib/hooks/useSubscription.ts` - Hook for subscription status\n- `lib/hooks/usePurchases.ts` - Hook for purchase operations\n- `app/paywall.tsx` - Paywall screen\n- `app/subscription.tsx` - Manage subscription screen\n- `lib/components/PaywallCard.tsx` - Subscription option card\n- `lib/components/SubscriptionBadge.tsx` - Pro badge component\n- `lib/components/UpgradePrompt.tsx` - Upgrade nudge component\n- `lib/api/subscriptions.ts` - API client for subscription endpoints\n\n### Backend (Express/Node.js)\n- `server/src/services/subscriptionService.ts` - Subscription business logic\n- `server/src/services/appStoreService.ts` - App Store Server API integration\n- `server/src/controllers/subscriptionController.ts` - Subscription endpoints\n- `server/src/controllers/webhookController.ts` - App Store webhook handler\n- `server/src/routes/subscription.ts` - Subscription routes\n- `server/src/routes/webhook.ts` - Webhook routes\n- `server/src/validation/subscriptionSchemas.ts` - Zod schemas\n- `server/src/middleware/webhookAuth.ts` - Webhook signature verification\n- `server/prisma/schema.prisma` - Add Subscription models\n\n### Configuration\n- `app.json` - Add In-App Purchase capability\n- App Store Connect - Configure products and subscriptions\n\n## Acceptance Criteria\n1. Users can view and purchase subscription plans\n2. Trial periods work correctly with proper eligibility checking\n3. Subscriptions renew automatically and status syncs to backend\n4. Users can restore purchases on new devices\n5. Server validates all purchases before granting access\n6. Webhook processes all App Store notifications correctly\n7. Entitlements are checked efficiently with proper caching\n8. All edge cases (expiration, billing issues, refunds) handled\n9. Analytics track key subscription metrics\n10. Passes App Store review guidelines",
        "testStrategy": "## Testing Strategy\n\n### Unit Tests\n1. **Purchase Service Tests**\n   - Product fetching and caching\n   - Purchase flow state management\n   - Entitlement calculation logic\n   - Error handling for various failure modes\n\n2. **Backend Service Tests**\n   - App Store Server API mock responses\n   - Subscription status transitions\n   - Webhook payload parsing and validation\n   - JWT token generation and validation\n\n3. **Entitlement Logic Tests**\n   - Active subscription detection\n   - Grace period handling\n   - Trial eligibility checking\n   - Feature flag resolution\n\n### Integration Tests\n1. **StoreKit Sandbox Testing**\n   - Full purchase flow with sandbox accounts\n   - Subscription renewal simulation\n   - Trial to paid conversion\n   - Restore purchases flow\n\n2. **Backend Webhook Tests**\n   - Webhook signature verification\n   - Event processing for all notification types\n   - Database state updates\n   - Error recovery scenarios\n\n3. **End-to-End Tests**\n   - Complete purchase journey\n   - Entitlement sync after purchase\n   - Cross-device restore\n   - Subscription management\n\n### Manual Testing Checklist\n- [ ] Purchase monthly subscription\n- [ ] Purchase yearly subscription\n- [ ] Start free trial\n- [ ] Trial expires and converts to paid\n- [ ] Cancel subscription\n- [ ] Re-subscribe after cancellation\n- [ ] Restore purchases on new device\n- [ ] Upgrade from monthly to yearly\n- [ ] Downgrade from yearly to monthly\n- [ ] Handle billing issue/grace period\n- [ ] Refund processing\n- [ ] Family Sharing (if enabled)\n- [ ] Ask to Buy deferred purchase\n- [ ] Offer code redemption\n- [ ] Promotional offer application",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up react-native-iap library and StoreKit 2 integration",
            "description": "Install react-native-iap v12+ with StoreKit 2 support, configure Expo development build for IAP capabilities, implement transaction listener with async/await patterns, and set up proper transaction finishing to prevent duplicate charges.",
            "dependencies": [],
            "details": "Install react-native-iap (v12+) which supports StoreKit 2. Configure app.json with In-App Purchase capability and create Expo development build (IAP doesn't work in Expo Go). Create lib/services/purchases/index.ts with purchase service initialization, implement Transaction.updates listener for real-time updates, set up proper transaction finishing logic, configure sandbox vs production environment detection, and implement error handling for common StoreKit errors (user canceled, network issues, etc.).",
            "status": "pending",
            "testStrategy": "Unit test purchase service initialization, test transaction listener with mock transactions, verify transaction finishing prevents duplicates, test environment detection (sandbox vs production), test error handling for all StoreKit error codes.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure App Store Connect products and subscription groups",
            "description": "Set up subscription products in App Store Connect (com.nutri.pro.monthly, com.nutri.pro.yearly), configure subscription groups for upgrade/downgrade paths, and set up introductory offers and promotional offers.",
            "dependencies": [
              1
            ],
            "details": "In App Store Connect, create subscription group 'Nutri Pro Subscriptions'. Add two products: com.nutri.pro.monthly ($9.99/month) and com.nutri.pro.yearly ($99.99/year, ~17% discount). Configure subscription group settings to allow upgrades/downgrades. Set up introductory offer: 7-day free trial for both tiers. Create promotional offers for win-back campaigns (e.g., 50% off for 3 months). Generate offer codes for marketing. Document all product IDs in lib/services/purchases/products.ts as constants.",
            "status": "pending",
            "testStrategy": "Manual verification in App Store Connect dashboard, test product fetching via StoreKit in sandbox environment, verify subscription group hierarchy allows proper upgrade/downgrade, test introductory offer eligibility detection.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement trial period and promotional offer eligibility checking",
            "description": "Implement logic to check user eligibility for free trials and promotional offers using StoreKit 2's Product.subscription.isEligibleForIntroOffer API, and display trial information in UI.",
            "dependencies": [
              2
            ],
            "details": "Create lib/services/purchases/entitlements.ts with functions to check trial eligibility using Product.subscription.isEligibleForIntroOffer (StoreKit 2 API). Implement promotional offer eligibility checking based on subscription history. Create TrialEligibilityChecker class that caches eligibility status to avoid repeated API calls. Add logic to display trial information ('7-day free trial, then $9.99/month') when eligible, or regular pricing when not eligible. Handle edge cases: never subscribed (eligible), currently subscribed (not eligible), lapsed subscriber (promotional offer eligible).",
            "status": "pending",
            "testStrategy": "Unit test eligibility checking logic with various user states (new, active, lapsed), test caching mechanism, integration test with sandbox accounts (new account should be trial eligible, account with previous subscription should not be), verify correct messaging displayed in UI.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build PaywallScreen with subscription options and purchase flow",
            "description": "Create full-screen paywall UI (app/paywall.tsx) displaying subscription tiers with localized pricing, trial eligibility, feature comparison, and purchase buttons with biometric authentication.",
            "dependencies": [
              3
            ],
            "details": "Create app/paywall.tsx as modal screen with: (1) Feature comparison table (Free vs Pro), (2) Subscription option cards showing Product.displayPrice (localized), trial information if eligible, and prominent CTA button, (3) Legal footer with Terms of Service and Privacy Policy links (required by App Store), (4) Restore Purchases button, (5) Loading states during purchase, (6) Success/error handling with user-friendly messages. Implement purchase flow: user taps Subscribe → StoreKit shows confirmation with biometric/password → process transaction → grant entitlements → dismiss paywall. Handle deferred transactions (Ask to Buy). Create lib/components/PaywallCard.tsx for reusable subscription option cards.",
            "status": "pending",
            "testStrategy": "Component test for PaywallScreen rendering, test purchase flow with sandbox account, test biometric authentication prompt, test deferred transaction handling, test error states (user canceled, network error), verify Terms/Privacy links work, test Restore Purchases button.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build ManageSubscriptionScreen and SubscriptionBadge component",
            "description": "Create subscription management screen (app/subscription.tsx) showing current plan details and App Store management link, plus a Pro badge component for displaying subscription status throughout the app.",
            "dependencies": [
              4
            ],
            "details": "Create app/subscription.tsx displaying: current subscription tier, renewal date, pricing, trial/intro offer status, auto-renew toggle status (read-only, managed via App Store), 'Manage Subscription' button linking to App Store subscription management (using Linking.openURL with App Store subscription URL), and Restore Purchases button. Create lib/components/SubscriptionBadge.tsx showing 'Pro' badge with styling when user has active subscription. Create lib/components/UpgradePrompt.tsx for contextual upgrade nudges when free users try premium features. Add subscription status to profile screen.",
            "status": "pending",
            "testStrategy": "Component test for ManageSubscriptionScreen, verify App Store link opens correctly, test SubscriptionBadge displays only for Pro users, test UpgradePrompt triggers on premium feature access, integration test with various subscription states.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement Restore Purchases functionality",
            "description": "Implement restore purchases flow using Transaction.currentEntitlements to sync past purchases and validate them with backend, required by App Store Review Guidelines.",
            "dependencies": [
              5
            ],
            "details": "In lib/services/purchases/index.ts, implement restorePurchases() function using Transaction.currentEntitlements (StoreKit 2 efficient API, not deprecated restoreCompletedTransactions). Flow: (1) User taps 'Restore Purchases', (2) Show loading indicator, (3) Fetch currentEntitlements from StoreKit, (4) For each entitlement, extract originalTransactionId and send to backend for validation, (5) Backend validates with App Store Server API, (6) Sync subscription status to local state, (7) Show success message ('Subscription restored') or info message ('No purchases to restore'). Handle errors gracefully. Add 'Restore Purchases' button to both PaywallScreen and ManageSubscriptionScreen.",
            "status": "pending",
            "testStrategy": "Unit test restore logic with mock transactions, integration test with sandbox account (purchase on device A, restore on device B), test no purchases case, test error handling (network failure), verify backend validation called for each transaction.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement backend App Store Server API integration for receipt validation",
            "description": "Create backend service to validate purchases using the modern App Store Server API (NOT deprecated verifyReceipt), implement JWT-based authentication, and query transaction/subscription status.",
            "dependencies": [
              6
            ],
            "details": "Create server/src/services/appStoreService.ts implementing: (1) App Store Server API client using JWT authentication (generate JWT with private key from App Store Connect), (2) getTransactionInfo(transactionId) endpoint to fetch transaction details, (3) getSubscriptionStatus(originalTransactionId) endpoint to check current subscription state, (4) validateTransaction() function that checks signature and decodes JWSTransaction, (5) Environment detection (sandbox vs production, use different API endpoints). Store App Store Connect API credentials in environment variables (KEY_ID, ISSUER_ID, PRIVATE_KEY). Never use deprecated verifyReceipt endpoint. Create server/src/validation/subscriptionSchemas.ts with Zod schemas for validation.",
            "status": "pending",
            "testStrategy": "Unit test JWT generation, test API client with sandbox environment, test transaction validation with test transaction data, test getSubscriptionStatus with various states (active, expired, grace period), verify proper error handling for invalid transactions.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement App Store Server Notifications V2 webhook with signature verification",
            "description": "Create webhook endpoint to receive real-time subscription status updates from Apple (renewals, cancellations, refunds), implement cryptographic signature verification, and process all notification types.",
            "dependencies": [
              7
            ],
            "details": "Create server/src/controllers/webhookController.ts with POST /api/webhooks/app-store endpoint. Implement signature verification using Apple's public key (fetch from Apple's JWKS endpoint, verify JWS signature). Parse notification payload (signedPayload is JWS, decode and verify). Handle all App Store Server Notifications V2 types: SUBSCRIBED, DID_RENEW, DID_CHANGE_RENEWAL_STATUS, DID_FAIL_TO_RENEW, EXPIRED, REFUND, REVOKE, OFFER_REDEEMED, GRACE_PERIOD_EXPIRED. For each notification, update Subscription record in database and create SubscriptionEvent audit log. Implement idempotency using notification UUID. Create server/src/middleware/webhookAuth.ts for signature verification middleware. Configure webhook URL in App Store Connect.",
            "status": "pending",
            "testStrategy": "Unit test signature verification with test JWS tokens, test notification parsing for all types, test idempotency (duplicate notifications), integration test with App Store Connect sandbox (trigger renewals/cancellations), verify SubscriptionEvent audit trail created, test error handling for invalid signatures.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Create Prisma database schema for Subscription and SubscriptionEvent models",
            "description": "Add Subscription and SubscriptionEvent models to Prisma schema with all required fields for subscription lifecycle tracking, run migrations, and generate Prisma client.",
            "dependencies": [
              8
            ],
            "details": "Add to server/prisma/schema.prisma: (1) Subscription model with fields: id, userId (unique), productId, originalTransactionId (unique), status (enum: ACTIVE, EXPIRED, IN_GRACE_PERIOD, IN_BILLING_RETRY, REVOKED, REFUNDED), expiresAt, isTrialPeriod, isIntroOfferPeriod, autoRenewEnabled, gracePeriodExpiresAt, billingRetryPeriod, priceLocale, priceCurrency, priceAmount (Decimal), environment (sandbox/production), timestamps. (2) SubscriptionEvent model with fields: id, subscriptionId, notificationType, subtype, transactionId, originalTransactionId, eventData (Json), processedAt. Add indexes for efficient queries: userId, originalTransactionId, status+expiresAt composite. Add relation to User model (user.subscription). Run 'npm run db:generate' and 'npm run db:migrate' to apply schema changes.",
            "status": "pending",
            "testStrategy": "Verify Prisma schema compiles without errors, test migration runs successfully, verify indexes created in PostgreSQL, unit test Subscription model CRUD operations, test foreign key constraints (userId references User).",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Implement entitlement service with secure caching and offline support",
            "description": "Create EntitlementService to check subscription status efficiently with secure local caching, sync entitlements on app launch and purchase events, handle offline scenarios, and implement feature flags based on subscription tier.",
            "dependencies": [
              9
            ],
            "details": "Create lib/services/purchases/entitlements.ts with EntitlementService class: (1) checkEntitlement(feature) returns boolean based on subscription status, (2) syncEntitlements() fetches current status from backend and caches in Expo SecureStore, (3) getCachedEntitlements() reads from SecureStore for offline support (with staleness check), (4) Feature flags: UNLIMITED_HISTORY, ML_INSIGHTS, ADVANCED_ANALYTICS mapped to subscription tiers. Create lib/context/SubscriptionContext.tsx providing subscription status to entire app. Create lib/hooks/useSubscription.ts hook returning { isPro, isTrial, expiresAt, syncEntitlements }. Call syncEntitlements() on app launch, after successful purchase, and on restore. Implement cache expiration (refresh every 24 hours). Handle offline mode: use cached entitlements if < 7 days old.",
            "status": "pending",
            "testStrategy": "Unit test entitlement checking logic for each feature flag, test caching mechanism (save/load from SecureStore), test staleness check, test offline behavior with old/recent cache, integration test: purchase → syncEntitlements → verify Pro features unlocked, test subscription expiration handling.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Set up StoreKit Testing configuration and Sandbox testing flows",
            "description": "Configure StoreKit Testing in Xcode for local testing without App Store, create Sandbox test accounts, and test all subscription lifecycle scenarios (new subscription, renewal, trial conversion, upgrade/downgrade, cancellation, billing issues, refunds).",
            "dependencies": [
              10
            ],
            "details": "Configure StoreKit Configuration file (.storekit) in Xcode with test products matching App Store Connect (com.nutri.pro.monthly, com.nutri.pro.yearly). Set up subscription durations (monthly = 5 minutes, yearly = 1 hour for faster testing). Create Sandbox test accounts in App Store Connect with different regions (US, UK, EU for currency testing). Test scenarios: (1) New subscription with trial → conversion to paid, (2) Successful renewal, (3) Expiration after cancellation, (4) Upgrade from monthly to yearly, (5) Downgrade from yearly to monthly, (6) Billing failure → grace period → billing retry, (7) Refund processing, (8) Family Sharing if enabled, (9) Ask to Buy (deferred transactions), (10) Restore purchases on new device. Document testing checklist in ml-service or server README.",
            "status": "pending",
            "testStrategy": "Manual testing checklist for all scenarios, verify StoreKit Testing transactions appear in Transaction Manager, test with multiple sandbox accounts, test currency localization, verify webhook notifications received for each state change, test grace period and billing retry states.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Integrate subscription analytics and ensure App Store Review compliance",
            "description": "Add analytics tracking for subscription events (impressions, conversions, churn), implement monitoring for refund patterns, and ensure full compliance with App Store Review Guidelines (restore purchases, terms display, error handling).",
            "dependencies": [
              11
            ],
            "details": "Analytics integration: Track events (paywall_viewed, subscription_started, trial_started, trial_converted, subscription_renewed, subscription_canceled, subscription_expired, purchase_restored, upgrade_completed, downgrade_completed) using existing analytics service or add new one (e.g., Mixpanel, Amplitude). Create server/src/services/subscriptionAnalyticsService.ts to calculate metrics: conversion rate (trial → paid), churn rate, MRR (Monthly Recurring Revenue), LTV (Lifetime Value). Set up alerts for unusual refund patterns (>5% refund rate). App Store compliance checklist: (1) Restore Purchases button visible and functional, (2) Terms of Service and Privacy Policy links on paywall, (3) Clear subscription terms display (price, duration, auto-renewal), (4) Graceful error handling with user-friendly messages, (5) No misleading marketing claims. Add subscription_tier field to User model for feature flag checks.",
            "status": "pending",
            "testStrategy": "Verify analytics events fire correctly for each user action, test metrics calculation with test data, verify refund alert triggers at threshold, compliance checklist review with screenshots, test all required UI elements present (Restore button, legal links, pricing display), verify error messages are user-friendly.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 39,
        "title": "Build Admin Panel for User and Subscription Management",
        "description": "Build a secure, internal admin panel for managing users, subscriptions, webhook events, and analytics. Essential for customer support, subscription troubleshooting, GDPR compliance, and business analytics. Phased approach starting with MVP features critical for subscription launch.",
        "details": "## Overview\nBuild a production-ready admin panel for the Nutri app to handle customer support, subscription management, compliance requirements, and business analytics. The admin panel is essential for operating a subscription-based app - while Apple handles billing, customer experience and support require internal tooling.\n\n## Why This Is Needed (Not Optional)\n\n1. **Customer Support**: Users will report \"I paid but don't have access\" - need instant lookup\n2. **Subscription Troubleshooting**: Debug webhook failures, verify transaction status\n3. **GDPR Compliance**: Legal requirement for data export/deletion tooling\n4. **Business Analytics**: MRR, churn, conversion - not available at this granularity in App Store Connect\n5. **Operational Efficiency**: Feature flags, food database management, ML monitoring\n\n## Technology Stack (2025 Best Practices)\n\n### Recommended: Next.js 14+ Admin App\n- **Framework**: Next.js 14+ with App Router (React Server Components)\n- **UI Library**: shadcn/ui + Tailwind CSS (consistent with React Native web styling)\n- **Charts/Dashboards**: Tremor (built on shadcn/ui) or Recharts\n- **Tables**: TanStack Table v8 with server-side pagination\n- **Forms**: React Hook Form + Zod (same as backend validation)\n- **Authentication**: NextAuth.js v5 with separate admin user table\n- **Deployment**: Vercel (or same infrastructure as backend)\n\n### Alternative Options Considered:\n- **Retool/Appsmith**: Faster to build but vendor lock-in, less customizable\n- **React Admin**: Mature but opinionated, less modern DX\n- **Refine**: Good option, similar to our recommendation\n\n### Why Next.js:\n- Same React skills as mobile app\n- Server Components for secure data fetching\n- API routes can proxy to main backend\n- Excellent DX with hot reload\n- Easy deployment\n\n## Architecture\n\n```\nadmin-panel/                    # Separate Next.js app\n├── app/\n│   ├── (auth)/\n│   │   ├── login/page.tsx     # Admin login\n│   │   └── layout.tsx\n│   ├── (dashboard)/\n│   │   ├── layout.tsx         # Dashboard layout with sidebar\n│   │   ├── page.tsx           # Overview dashboard\n│   │   ├── users/\n│   │   │   ├── page.tsx       # User list with search/filter\n│   │   │   └── [id]/page.tsx  # User detail view\n│   │   ├── subscriptions/\n│   │   │   ├── page.tsx       # Subscription list\n│   │   │   └── [id]/page.tsx  # Subscription detail\n│   │   ├── webhooks/\n│   │   │   └── page.tsx       # Webhook event logs\n│   │   ├── analytics/\n│   │   │   └── page.tsx       # Subscription analytics\n│   │   └── settings/\n│   │       ├── feature-flags/page.tsx\n│   │       └── team/page.tsx  # Admin user management\n│   └── api/                   # Proxy to main backend\n├── components/\n│   ├── ui/                    # shadcn/ui components\n│   ├── dashboard/             # Dashboard-specific components\n│   └── data-table/            # Reusable table components\n├── lib/\n│   ├── api.ts                 # Backend API client\n│   ├── auth.ts                # NextAuth configuration\n│   └── utils.ts\n└── middleware.ts              # Auth middleware\n```\n\n## Phase 1: MVP (Launch Critical) - 2-3 weeks\n\n### 1.1 Admin Authentication & Security\n- Separate AdminUser table in database (NOT shared with app users)\n- Email/password with mandatory MFA (TOTP)\n- Role-based access: SUPER_ADMIN, SUPPORT, VIEWER\n- Session-based auth with secure cookies\n- Audit logging for ALL admin actions\n- IP allowlisting option for production\n- Rate limiting on login endpoint\n\n### 1.2 User Management\n- **User Search**: By email, ID, name (instant search with debounce)\n- **User List**: Paginated, sortable, filterable table\n- **User Detail View**:\n  - Profile information (email, name, created date)\n  - Subscription status (tier, expires, trial info)\n  - Recent activity (meals logged, health metrics)\n  - Account actions: Reset password link, disable account\n- **GDPR Actions**:\n  - Export user data (JSON download)\n  - Delete user account (with confirmation, cascades to all data)\n\n### 1.3 Subscription Management\n- **Subscription List**: All subscriptions with status filter\n- **Subscription Detail**:\n  - Current status, product, expiration\n  - Transaction history (all originalTransactionIds)\n  - Webhook events related to this subscription\n  - Auto-renew status\n- **Manual Actions** (SUPER_ADMIN only):\n  - Grant Pro access (specify duration, reason logged)\n  - Extend subscription (specify days, reason logged)\n  - Revoke access (with reason)\n- **Subscription Lookup**: By originalTransactionId for support tickets\n\n### 1.4 Webhook Event Viewer\n- **Event List**: All App Store webhook events, newest first\n- **Filters**: By notification type, date range, subscription ID\n- **Event Detail**: Full JSON payload, processing status, errors\n- **Retry Failed**: Button to reprocess failed webhooks\n- **Search**: By originalTransactionId for debugging\n\n### 1.5 Basic Analytics Dashboard\n- **Subscription Metrics** (real-time):\n  - Total active subscribers (by tier)\n  - MRR (Monthly Recurring Revenue)\n  - New subscriptions today/this week/this month\n  - Cancellations/churn today/this week/this month\n- **Trial Metrics**:\n  - Active trials\n  - Trial conversion rate (7-day, 30-day)\n- **Charts**:\n  - Subscribers over time (line chart)\n  - Revenue over time (line chart)\n  - Subscription status distribution (pie chart)\n\n## Phase 2: Growth Features - 2-3 weeks\n\n### 2.1 Advanced Analytics\n- Cohort retention analysis\n- LTV (Lifetime Value) calculation\n- Churn prediction indicators\n- Geographic distribution\n- Revenue by product (monthly vs yearly)\n- Refund rate monitoring with alerts\n\n### 2.2 Feature Flags Management\n- Create/edit/delete feature flags\n- Target by: user ID, subscription tier, percentage rollout\n- Flag types: boolean, string, number, JSON\n- Instant propagation to app (webhook or polling)\n- Audit log of flag changes\n\n### 2.3 Food Database Management\n- View/search food database entries\n- Edit nutritional information\n- Add new foods\n- Flag/review user-submitted entries\n- Bulk import from CSV\n\n### 2.4 Push Notification Management\n- Send push notifications to segments\n- Segments: all users, Pro users, trial users, inactive users\n- Schedule notifications\n- View delivery stats\n\n## Phase 3: Scale Features - 2+ weeks\n\n### 3.1 Team Management\n- Invite admin users\n- Role assignment (SUPER_ADMIN, SUPPORT, VIEWER, ANALYST)\n- Permission matrix by role\n- Activity log per admin user\n- Disable/remove admin users\n\n### 3.2 A/B Testing Dashboard\n- View active experiments\n- Create new experiments (paywall variants, onboarding flows)\n- View results with statistical significance\n- Declare winners and roll out\n\n### 3.3 ML Model Monitoring\n- Model performance metrics over time\n- Inference latency tracking\n- Error rate monitoring\n- Model version management\n- A/B test model versions\n\n### 3.4 Advanced Security\n- Login anomaly detection\n- Suspicious activity alerts\n- API key management for integrations\n- Webhook secret rotation\n\n## Database Schema Additions\n\n```prisma\n// Add to server/prisma/schema.prisma\n\nmodel AdminUser {\n  id            String   @id @default(cuid())\n  email         String   @unique\n  passwordHash  String\n  name          String\n  role          AdminRole @default(SUPPORT)\n  mfaSecret     String?  // TOTP secret\n  mfaEnabled    Boolean  @default(false)\n  isActive      Boolean  @default(true)\n  lastLoginAt   DateTime?\n  lastLoginIp   String?\n  createdAt     DateTime @default(now())\n  updatedAt     DateTime @updatedAt\n  \n  auditLogs     AdminAuditLog[]\n  \n  @@index([email])\n}\n\nenum AdminRole {\n  SUPER_ADMIN  // Full access, can manage other admins\n  SUPPORT      // User/subscription management, no settings\n  ANALYST      // Read-only analytics access\n  VIEWER       // Read-only all access\n}\n\nmodel AdminAuditLog {\n  id          String   @id @default(cuid())\n  adminUserId String\n  adminUser   AdminUser @relation(fields: [adminUserId], references: [id])\n  action      String   // e.g., \"USER_LOOKUP\", \"SUBSCRIPTION_GRANT\", \"USER_DELETE\"\n  targetType  String?  // e.g., \"User\", \"Subscription\"\n  targetId    String?  // ID of affected record\n  details     Json?    // Additional context\n  ipAddress   String\n  userAgent   String?\n  createdAt   DateTime @default(now())\n  \n  @@index([adminUserId])\n  @@index([action])\n  @@index([targetType, targetId])\n  @@index([createdAt])\n}\n\nmodel FeatureFlag {\n  id          String   @id @default(cuid())\n  key         String   @unique  // e.g., \"new_paywall_design\"\n  name        String\n  description String?\n  type        FeatureFlagType @default(BOOLEAN)\n  value       Json     // Default value\n  isEnabled   Boolean  @default(false)\n  targeting   Json?    // Rules for user targeting\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  \n  @@index([key])\n}\n\nenum FeatureFlagType {\n  BOOLEAN\n  STRING\n  NUMBER\n  JSON\n}\n```\n\n## Backend API Additions\n\nCreate admin-specific endpoints in server/src/routes/admin/:\n\n```typescript\n// Admin authentication\nPOST   /api/admin/auth/login\nPOST   /api/admin/auth/logout\nPOST   /api/admin/auth/mfa/setup\nPOST   /api/admin/auth/mfa/verify\nGET    /api/admin/auth/me\n\n// User management\nGET    /api/admin/users              // List with pagination, search, filters\nGET    /api/admin/users/:id          // User detail with subscription\nPOST   /api/admin/users/:id/export   // GDPR data export\nDELETE /api/admin/users/:id          // GDPR deletion\nPOST   /api/admin/users/:id/disable  // Disable account\n\n// Subscription management\nGET    /api/admin/subscriptions      // List with filters\nGET    /api/admin/subscriptions/:id  // Detail with events\nPOST   /api/admin/subscriptions/:id/grant   // Manual grant\nPOST   /api/admin/subscriptions/:id/extend  // Extend duration\nPOST   /api/admin/subscriptions/:id/revoke  // Revoke access\nGET    /api/admin/subscriptions/lookup?txn=XXX  // By transaction ID\n\n// Webhook events\nGET    /api/admin/webhooks           // List with filters\nGET    /api/admin/webhooks/:id       // Event detail\nPOST   /api/admin/webhooks/:id/retry // Retry processing\n\n// Analytics\nGET    /api/admin/analytics/subscriptions  // Subscription metrics\nGET    /api/admin/analytics/revenue        // Revenue metrics\nGET    /api/admin/analytics/trials         // Trial metrics\n\n// Feature flags\nGET    /api/admin/feature-flags\nPOST   /api/admin/feature-flags\nPUT    /api/admin/feature-flags/:id\nDELETE /api/admin/feature-flags/:id\n\n// Audit logs\nGET    /api/admin/audit-logs         // List with filters\n```\n\n## Security Requirements (Non-Negotiable)\n\n1. **Authentication**\n   - Separate admin user table (NEVER share with app users)\n   - Mandatory MFA for all admin accounts\n   - Session expiration: 8 hours inactive, 24 hours max\n   - Secure cookie flags: HttpOnly, Secure, SameSite=Strict\n\n2. **Authorization**\n   - RBAC enforced on every endpoint\n   - Principle of least privilege\n   - SUPER_ADMIN required for: user deletion, subscription grants, admin management\n\n3. **Audit Logging**\n   - Log ALL admin actions with: who, what, when, IP, user agent\n   - Immutable audit trail (no deletes/updates)\n   - Retention: 2 years minimum\n\n4. **Network Security**\n   - Separate subdomain: admin.nutri.app\n   - HTTPS only (HSTS enabled)\n   - Consider IP allowlisting for production\n   - Rate limiting on all endpoints\n\n5. **Data Protection**\n   - PII access logged\n   - Data exports encrypted\n   - No PII in URL parameters\n   - Mask sensitive data in logs\n\n## Files to Create\n\n### Admin Panel (New Next.js App)\n```\nadmin-panel/\n├── package.json\n├── next.config.js\n├── tailwind.config.js\n├── tsconfig.json\n├── .env.local\n├── middleware.ts\n├── app/\n│   ├── layout.tsx\n│   ├── (auth)/login/page.tsx\n│   ├── (dashboard)/\n│   │   ├── layout.tsx\n│   │   ├── page.tsx                 # Dashboard overview\n│   │   ├── users/page.tsx\n│   │   ├── users/[id]/page.tsx\n│   │   ├── subscriptions/page.tsx\n│   │   ├── subscriptions/[id]/page.tsx\n│   │   ├── webhooks/page.tsx\n│   │   └── analytics/page.tsx\n├── components/\n│   ├── ui/                          # shadcn/ui\n│   ├── layout/sidebar.tsx\n│   ├── layout/header.tsx\n│   ├── users/user-table.tsx\n│   ├── users/user-detail.tsx\n│   ├── subscriptions/subscription-table.tsx\n│   ├── subscriptions/grant-modal.tsx\n│   ├── webhooks/event-table.tsx\n│   ├── analytics/metrics-cards.tsx\n│   └── analytics/charts.tsx\n└── lib/\n    ├── api.ts\n    ├── auth.ts\n    └── utils.ts\n```\n\n### Backend Additions\n```\nserver/src/\n├── controllers/adminController.ts\n├── services/adminService.ts\n├── services/adminAuthService.ts\n├── services/adminAnalyticsService.ts\n├── routes/admin.ts\n├── middleware/adminAuth.ts\n├── middleware/adminAudit.ts\n└── validation/adminSchemas.ts\n```\n\n## Acceptance Criteria\n\n### Phase 1 (MVP)\n1. Admin can log in with MFA\n2. Admin can search and view user details\n3. Admin can view subscription status for any user\n4. Admin can manually grant/extend/revoke subscriptions\n5. Admin can view webhook event history\n6. Admin can export user data (GDPR)\n7. Admin can delete user account (GDPR)\n8. All actions are audit logged\n9. Role-based access control enforced\n10. Dashboard shows key subscription metrics\n\n### Phase 2\n11. Feature flags can be managed via UI\n12. Advanced analytics dashboards functional\n13. Food database can be edited\n14. Push notifications can be sent\n\n### Phase 3\n15. Multiple admin users with role management\n16. A/B testing dashboard functional\n17. ML model monitoring integrated",
        "testStrategy": "## Testing Strategy\n\n### Unit Tests\n1. **Admin Authentication**\n   - Password hashing and verification\n   - MFA token generation and validation\n   - Session management\n   - Role-based permission checks\n\n2. **Admin Services**\n   - User search and filtering logic\n   - Subscription grant/extend/revoke logic\n   - Analytics calculations (MRR, churn rate)\n   - Data export generation\n\n3. **Audit Logging**\n   - All actions create audit log entries\n   - Correct data captured (IP, user agent, details)\n\n### Integration Tests\n1. **Admin API Endpoints**\n   - Authentication flow with MFA\n   - CRUD operations for all resources\n   - Permission enforcement by role\n   - Pagination and filtering\n\n2. **Subscription Management**\n   - Manual grant creates correct database records\n   - Extension updates expiration correctly\n   - Revocation removes entitlements\n\n3. **Webhook Retry**\n   - Failed webhooks can be reprocessed\n   - Correct handling of retry results\n\n### E2E Tests\n1. **Admin Login Flow**\n   - Login with valid credentials + MFA\n   - Session persistence\n   - Logout clears session\n\n2. **User Management Flow**\n   - Search for user by email\n   - View user details\n   - Export user data\n   - Delete user (with cascading)\n\n3. **Subscription Flow**\n   - Find user with subscription issue\n   - View webhook history\n   - Grant extended access\n   - Verify audit log created\n\n### Security Tests\n1. **Authentication**\n   - Brute force protection (rate limiting)\n   - Invalid MFA rejected\n   - Session fixation prevention\n\n2. **Authorization**\n   - VIEWER cannot perform write operations\n   - SUPPORT cannot access admin management\n   - Only SUPER_ADMIN can delete users\n\n3. **Audit Trail**\n   - Cannot delete or modify audit logs\n   - All sensitive actions logged\n\n### Manual Testing Checklist\n- [ ] Admin login with MFA\n- [ ] User search by email\n- [ ] User detail view shows subscription\n- [ ] Grant Pro access to free user\n- [ ] Extend subscription by 30 days\n- [ ] View webhook event history\n- [ ] Retry failed webhook\n- [ ] Export user data\n- [ ] Delete user account\n- [ ] Verify audit log entries\n- [ ] Test role-based restrictions\n- [ ] Dashboard metrics accurate\n- [ ] Charts render correctly",
        "status": "done",
        "dependencies": [
          "38"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Next.js 14+ admin app with App Router and shadcn/ui",
            "description": "Create a new Next.js 14+ application in admin-panel/ directory with TypeScript, Tailwind CSS, App Router, and shadcn/ui component library. Configure project structure following the architecture specified in task details.",
            "dependencies": [],
            "details": "1. Run `npx create-next-app@latest admin-panel` with TypeScript, Tailwind, App Router\n2. Install shadcn/ui: `npx shadcn-ui@latest init`\n3. Install dependencies: `npm install @tanstack/react-table tremor recharts react-hook-form zod axios next-auth@beta`\n4. Create folder structure: app/(auth), app/(dashboard), components/ui, components/layout, lib/\n5. Configure tailwind.config.js to match React Native web styling tokens from lib/theme/colors.ts\n6. Create .env.local with NEXTAUTH_SECRET, NEXTAUTH_URL, API_URL (pointing to http://localhost:3000)\n7. Set up tsconfig.json with strict mode (zero 'any' types policy)\n8. Create lib/api.ts with axios client configured to proxy to backend API\n9. Add middleware.ts placeholder for auth protection\n10. Verify build: `npm run build` succeeds",
            "status": "done",
            "testStrategy": "Run `npm run dev` and verify Next.js app loads at localhost:3001. Verify TypeScript compilation with `npx tsc --noEmit`. Test that shadcn/ui components can be imported. Verify Tailwind CSS classes render correctly.",
            "updatedAt": "2025-12-23T12:41:13.804Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Extend Prisma schema with AdminUser and AdminAuditLog models",
            "description": "Add AdminUser, AdminAuditLog, and FeatureFlag models to server/prisma/schema.prisma with proper indexes, relations, and enum types. Follow existing schema conventions.",
            "dependencies": [],
            "details": "1. Add AdminRole enum (SUPER_ADMIN, SUPPORT, ANALYST, VIEWER)\n2. Add FeatureFlagType enum (BOOLEAN, STRING, NUMBER, JSON)\n3. Create AdminUser model with fields: id (cuid), email (unique), passwordHash, name, role, mfaSecret, mfaEnabled, isActive, lastLoginAt, lastLoginIp, createdAt, updatedAt\n4. Add indexes: @@index([email]) on AdminUser\n5. Create AdminAuditLog model with fields: id (cuid), adminUserId, action, targetType, targetId, details (Json), ipAddress, userAgent, createdAt\n6. Add relation: AdminUser.auditLogs (one-to-many)\n7. Add indexes on AdminAuditLog: @@index([adminUserId]), @@index([action]), @@index([targetType, targetId]), @@index([createdAt])\n8. Create FeatureFlag model with fields: id (cuid), key (unique), name, description, type, value (Json), isEnabled, targeting (Json), createdAt, updatedAt\n9. Add @@index([key]) on FeatureFlag\n10. Run `npm run db:generate` to generate Prisma client\n11. Run `npm run db:push` (dev) or create migration with `npm run db:migrate`",
            "status": "done",
            "testStrategy": "Verify Prisma client generates without errors. Run `npx prisma studio` and confirm new models appear. Create a test AdminUser record via Prisma Studio and verify all fields save correctly. Check indexes are created in PostgreSQL.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T12:42:20.293Z"
          },
          {
            "id": 3,
            "title": "Implement admin authentication backend with MFA (TOTP) support",
            "description": "Create admin authentication service with bcrypt password hashing, JWT session tokens, and TOTP-based MFA. Build endpoints for login, logout, MFA setup, and MFA verification.",
            "dependencies": [
              2
            ],
            "details": "1. Install dependencies in server/: `npm install speakeasy qrcode @types/speakeasy @types/qrcode`\n2. Create server/src/services/adminAuthService.ts with functions: loginAdmin(email, password), verifyMFA(adminUserId, token), setupMFA(adminUserId), generateSessionToken(adminUser)\n3. Use bcryptjs (already in deps) for password verification\n4. Use speakeasy.generateSecret() for MFA setup, return QR code data URL using qrcode library\n5. Session tokens: JWT with payload { adminUserId, role, sessionId } signed with JWT_SECRET, 8-hour expiration\n6. Create server/src/controllers/adminAuthController.ts with handlers: login (POST), logout (POST), setupMFA (POST), verifyMFA (POST), getMe (GET)\n7. Create server/src/validation/adminSchemas.ts with Zod schemas: adminLoginSchema, adminMFASetupSchema, adminMFAVerifySchema\n8. Add constants to server/src/config/constants.ts: ADMIN_SESSION_EXPIRY = '8h', ADMIN_SESSION_MAX = '24h'\n9. Store session metadata (sessionId, expiresAt) in AdminUser or separate AdminSession table\n10. Return { token, requiresMFA, qrCode? } from login endpoint",
            "status": "done",
            "testStrategy": "Unit tests in server/src/__tests__/adminAuth.test.ts: test password verification, MFA secret generation, token verification, session expiration. Integration test: POST /api/admin/auth/login with correct/incorrect credentials. Test MFA flow end-to-end with speakeasy.totp.verify().",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T12:46:57.191Z"
          },
          {
            "id": 4,
            "title": "Configure NextAuth.js v5 with credentials provider for admin authentication",
            "description": "Set up NextAuth.js v5 in admin panel with custom credentials provider that calls backend admin auth API, handles MFA flow, and manages admin sessions with proper security.",
            "dependencies": [
              1,
              3
            ],
            "details": "1. Create admin-panel/lib/auth.ts with NextAuth configuration\n2. Configure credentials provider to call backend POST /api/admin/auth/login\n3. Handle MFA flow: if requiresMFA=true in response, store pendingMfaToken in session and redirect to MFA page\n4. On MFA verification, call POST /api/admin/auth/mfa/verify and complete sign-in\n5. Store admin JWT token in session callbacks (jwt, session)\n6. Configure session strategy: 'jwt', maxAge: 8 hours\n7. Set cookies: { secure: true, httpOnly: true, sameSite: 'strict' }\n8. Create admin-panel/middleware.ts to protect /dashboard routes with NextAuth middleware\n9. Implement role-based access control in middleware (check session.user.role)\n10. Create admin-panel/app/api/auth/[...nextauth]/route.ts with NextAuth handler\n11. Add NEXTAUTH_SECRET to .env.local (generate with `openssl rand -base64 32`)\n12. Create types in admin-panel/lib/types.ts for AdminUser (id, email, name, role)",
            "status": "done",
            "testStrategy": "Test login flow: navigate to /login, submit credentials, verify session cookie is set. Test protected routes redirect to /login when unauthenticated. Test MFA flow if enabled. Verify session expires after 8 hours. Test role-based access (VIEWER cannot access SUPER_ADMIN routes).",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T12:54:21.372Z"
          },
          {
            "id": 5,
            "title": "Build admin login UI with MFA flow and session management",
            "description": "Create login page with email/password form, MFA verification page, and session management UI using shadcn/ui components and react-hook-form with Zod validation.",
            "dependencies": [
              4
            ],
            "details": "1. Create admin-panel/app/(auth)/login/page.tsx with email/password form\n2. Use shadcn/ui components: Card, Input, Button, Label from `components/ui/`\n3. Install react-hook-form and integrate with Zod: `@hookform/resolvers/zod`\n4. Create login form schema matching backend adminLoginSchema\n5. On submit, call signIn('credentials', { email, password })\n6. Handle MFA required response: redirect to /auth/mfa page\n7. Create admin-panel/app/(auth)/mfa/page.tsx for MFA token input (6-digit code)\n8. Display QR code if setupMFA=true (first-time setup)\n9. Use speakeasy-compatible TOTP input (6 digits, numeric only)\n10. Show error states with shadcn/ui Alert component (invalid credentials, MFA failed)\n11. Create admin-panel/app/(auth)/layout.tsx with centered auth card design\n12. Add loading states with shadcn/ui Spinner during API calls\n13. Redirect to /dashboard on successful authentication",
            "status": "done",
            "testStrategy": "Manual testing: test login with valid/invalid credentials, verify error messages display. Test MFA setup flow with QR code scan using Google Authenticator app. Test MFA verification with correct/incorrect codes. Verify redirect to /dashboard on success. Test form validation (email format, required fields).",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T12:57:19.371Z"
          },
          {
            "id": 6,
            "title": "Create RBAC middleware and audit logging middleware for admin API",
            "description": "Implement role-based access control middleware and comprehensive audit logging middleware for all admin endpoints. Every admin action must be logged with who, what, when, IP, and user agent.",
            "dependencies": [
              3
            ],
            "details": "1. Create server/src/middleware/adminAuth.ts with requireAdmin(roles?: AdminRole[]) middleware\n2. Verify JWT token from Authorization header, decode and validate\n3. Load AdminUser from database, check isActive=true\n4. If roles specified, verify adminUser.role is in allowed roles\n5. Attach req.adminUser to request object (extend Express Request type)\n6. Return 401 if token invalid/expired, 403 if role not allowed\n7. Create server/src/middleware/adminAudit.ts with auditLog(action: string) middleware factory\n8. Capture: adminUserId, action, targetType (from route), targetId (from req.params), details (from req.body), ipAddress (req.ip), userAgent (req.headers['user-agent'])\n9. Insert AdminAuditLog record asynchronously (don't block response)\n10. Use res.on('finish') to log after response sent\n11. Create server/src/types/express.d.ts to extend Express Request with adminUser property\n12. Add audit logging to ALL admin endpoints (chain auditLog middleware after requireAdmin)",
            "status": "done",
            "testStrategy": "Unit tests: verify requireAdmin allows valid JWT, rejects expired token, enforces role restrictions. Test auditLog creates database records with correct fields. Integration test: call admin endpoint, verify AdminAuditLog entry created. Test IP/user-agent capture. Test async logging doesn't delay response.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T12:51:22.338Z"
          },
          {
            "id": 7,
            "title": "Build user search and list backend API with pagination and filters",
            "description": "Create GET /api/admin/users endpoint with search (email, name), pagination, sorting, and filtering (subscription status, account status). Return user list with subscription info.",
            "dependencies": [
              6
            ],
            "details": "1. Create server/src/controllers/adminUserController.ts with listUsers handler\n2. Create server/src/services/adminUserService.ts with getUserList(params) function\n3. Query parameters: search (string), page (number), limit (number, max 100, default 20), sortBy (createdAt, email, name), sortOrder (asc, desc), status (active, disabled), subscriptionStatus (active, trial, expired, none)\n4. Use Prisma where clause with OR for search: { OR: [{ email: { contains: search, mode: 'insensitive' } }, { name: { contains: search } }] }\n5. Include subscription data with include: { subscriptions: { where: { status: 'ACTIVE' }, take: 1 } }\n6. Calculate total count for pagination metadata\n7. Return { users: [], pagination: { page, limit, total, totalPages } }\n8. Create Zod schema in server/src/validation/adminSchemas.ts: listUsersQuerySchema\n9. Apply RBAC: requireAdmin() (all roles can list users)\n10. Apply audit logging: auditLog('USER_LIST')\n11. Add route in server/src/routes/admin.ts: GET /api/admin/users",
            "status": "done",
            "testStrategy": "Unit test adminUserService.getUserList with mocked Prisma client. Test search filters (email, name), pagination (page 1, page 2, limit). Integration test GET /api/admin/users with query params. Verify audit log created. Test performance with 10,000 users (should return < 500ms).",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T13:02:10.383Z"
          },
          {
            "id": 8,
            "title": "Build user detail API with GDPR export and delete endpoints",
            "description": "Create GET /api/admin/users/:id for detailed user view, POST /api/admin/users/:id/export for GDPR data export (JSON), and DELETE /api/admin/users/:id for GDPR-compliant account deletion with cascades.",
            "dependencies": [
              6
            ],
            "details": "1. Create getUserDetail(userId) in adminUserService: return user with all relations (subscriptions, meals, healthMetrics, activities count)\n2. GET /api/admin/users/:id handler in adminUserController, verify user exists (404 if not)\n3. Create exportUserData(userId) in adminUserService: fetch ALL user data (profile, meals, health metrics, activities, subscriptions, webhook events)\n4. Return as downloadable JSON with structure: { user: {}, meals: [], healthMetrics: [], activities: [], subscriptions: [] }\n5. POST /api/admin/users/:id/export handler: set Content-Type: application/json, Content-Disposition: attachment; filename=user-{userId}-export.json\n6. Create deleteUserAccount(userId, adminUserId, reason) in adminUserService\n7. Validation: require SUPER_ADMIN role for deletion (403 for other roles)\n8. Use Prisma transaction to delete in order: AppStoreWebhookEvent, Subscription, Activity, HealthMetric, Meal, User (cascade)\n9. Log deletion in AdminAuditLog with reason in details field\n10. DELETE /api/admin/users/:id handler: require { reason } in request body (Zod schema)\n11. Add routes: GET /users/:id, POST /users/:id/export, DELETE /users/:id\n12. Apply RBAC: requireAdmin(['SUPER_ADMIN']) for DELETE, requireAdmin() for GET/export",
            "status": "done",
            "testStrategy": "Test GET /users/:id returns full user detail with counts. Test POST /users/:id/export downloads valid JSON with all user data. Test DELETE requires SUPER_ADMIN role (403 for SUPPORT). Test deletion cascades all related records. Verify audit log includes deletion reason. Test 404 for non-existent userId.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T13:02:10.426Z"
          },
          {
            "id": 9,
            "title": "Build user management UI with search, list, and detail views",
            "description": "Create admin panel pages for user search, paginated user list with TanStack Table, and detailed user view. Implement instant search with debouncing and client-side filtering.",
            "dependencies": [
              1,
              7
            ],
            "details": "1. Create admin-panel/app/(dashboard)/users/page.tsx for user list\n2. Implement search input with debounced onChange (300ms delay using useDebouncedValue hook)\n3. Use TanStack Table v8 with server-side pagination, sorting\n4. Define columns: email, name, subscription status (badge), created date, actions (View button)\n5. Fetch data from GET /api/admin/users with useQuery (use @tanstack/react-query)\n6. Add filters dropdown: subscription status (active, trial, expired, none), account status (active, disabled)\n7. Create admin-panel/components/users/user-table.tsx reusable component\n8. Implement pagination controls (Previous, Next, page numbers) using shadcn/ui Pagination\n9. Create admin-panel/app/(dashboard)/users/[id]/page.tsx for user detail view\n10. Display user profile card: email, name, created date, current weight, goal weight\n11. Show subscription status card: tier, expiration, trial info, auto-renew status\n12. Show recent activity stats: meals logged (last 7 days), health metrics synced (last 7 days)\n13. Add action buttons: Export Data, Delete Account (with role check)\n14. Use shadcn/ui Card, Badge, Tabs components for layout",
            "status": "done",
            "testStrategy": "Manual testing: verify search updates results after 300ms debounce. Test pagination (next/previous, jump to page). Test sorting by clicking column headers. Verify user detail page loads with correct data. Test filters apply correctly. Verify action buttons appear only for authorized roles.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T16:38:03.984Z"
          },
          {
            "id": 10,
            "title": "Implement GDPR export and delete UI with confirmation modals",
            "description": "Create UI components for GDPR data export (download JSON) and account deletion with multi-step confirmation flow, reason input, and role-based access control.",
            "dependencies": [
              8,
              9
            ],
            "details": "1. Create admin-panel/components/users/export-data-button.tsx\n2. On click, call POST /api/admin/users/:id/export, trigger browser download of JSON file\n3. Show loading spinner during export (can take 5-10 seconds for large datasets)\n4. Display success toast notification using shadcn/ui Toast\n5. Create admin-panel/components/users/delete-user-modal.tsx with shadcn/ui AlertDialog\n6. Require SUPER_ADMIN role to show Delete Account button (check session.user.role)\n7. First confirmation: \"Are you sure you want to delete this account? This cannot be undone.\"\n8. Second step: require typing user's email to confirm (text input must match exactly)\n9. Third step: require deletion reason (textarea, minimum 10 characters)\n10. On confirm, call DELETE /api/admin/users/:id with { reason } body\n11. Show loading state during deletion\n12. On success, redirect to user list with success toast\n13. On error, display error message in modal (e.g., 403 Forbidden if not SUPER_ADMIN)",
            "status": "done",
            "testStrategy": "Test export downloads JSON file with correct filename. Test delete modal shows only for SUPER_ADMIN role. Test multi-step confirmation flow (cannot proceed without typing email). Test reason validation (minimum 10 chars). Test deletion success redirects to user list. Test error handling for 403/500 responses.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T13:17:23.207Z"
          },
          {
            "id": 11,
            "title": "Build subscription management backend API with manual operations",
            "description": "Create backend APIs for subscription list, detail view, and manual operations (grant Pro access, extend subscription, revoke access). All operations require SUPER_ADMIN role and are audit logged.",
            "dependencies": [
              6
            ],
            "details": "1. Create server/src/controllers/adminSubscriptionController.ts and server/src/services/adminSubscriptionService.ts\n2. GET /api/admin/subscriptions: list all subscriptions with filters (status, productId, userId), pagination, include user info\n3. GET /api/admin/subscriptions/:id: return subscription with full transaction history, related webhook events\n4. GET /api/admin/subscriptions/lookup?txn={originalTransactionId}: lookup by Apple transaction ID for support tickets\n5. POST /api/admin/subscriptions/:id/grant: manually grant Pro access (require { duration, reason } in body)\n6. Implementation: create or update Subscription record with status=ACTIVE, expiresAt=now + duration, source=MANUAL_GRANT\n7. POST /api/admin/subscriptions/:id/extend: extend expiration (require { days, reason })\n8. Implementation: update expiresAt = expiresAt + days, log in metadata\n9. POST /api/admin/subscriptions/:id/revoke: revoke access (require { reason })\n10. Implementation: set status=CANCELLED, expiresAt=now\n11. All operations require requireAdmin(['SUPER_ADMIN']) middleware\n12. All operations use auditLog with action (SUBSCRIPTION_GRANT, SUBSCRIPTION_EXTEND, SUBSCRIPTION_REVOKE)\n13. Create Zod schemas: grantSubscriptionSchema, extendSubscriptionSchema, revokeSubscriptionSchema\n14. Add routes in server/src/routes/admin.ts",
            "status": "done",
            "testStrategy": "Unit test subscription service functions with mocked Prisma. Test RBAC enforcement (403 for non-SUPER_ADMIN). Test grant creates new subscription with correct expiresAt. Test extend updates expiresAt correctly. Test revoke sets status=CANCELLED. Verify audit logs created with reason field. Test lookup by originalTransactionId finds correct subscription.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T13:04:25.495Z"
          },
          {
            "id": 12,
            "title": "Build subscription management UI with manual operation modals",
            "description": "Create subscription list page, detail view, and modals for manual grant/extend/revoke operations. Include originalTransactionId search for support workflows.",
            "dependencies": [
              1,
              11
            ],
            "details": "1. Create admin-panel/app/(dashboard)/subscriptions/page.tsx with TanStack Table\n2. Columns: user email, product (Pro Monthly/Yearly), status (badge: active=green, expired=red, trial=blue), expires at, actions\n3. Add search by originalTransactionId input (for support tickets like \"customer says they paid but no access\")\n4. Create admin-panel/app/(dashboard)/subscriptions/[id]/page.tsx for detail view\n5. Show subscription info card: user, product, status, created/expires dates, auto-renew status\n6. Show transaction history table: all originalTransactionIds, purchase dates, amounts (from webhook metadata)\n7. Show related webhook events table: notification type, received at, processing status\n8. Create admin-panel/components/subscriptions/grant-modal.tsx for manual grant\n9. Require SUPER_ADMIN role to show manual operation buttons\n10. Grant modal fields: duration (select: 7 days, 30 days, 90 days, 1 year), reason (textarea, required)\n11. Create extend-modal.tsx with days input (number, 1-365) and reason\n12. Create revoke-modal.tsx with reason input only\n13. All modals use shadcn/ui Dialog component with confirmation step\n14. On success, refetch subscription data and show toast notification",
            "status": "done",
            "testStrategy": "Test subscription list loads with correct data and filters. Test search by originalTransactionId finds subscription. Test detail view shows transaction history. Test manual operation modals appear only for SUPER_ADMIN. Test grant modal creates subscription with correct expiration. Test extend modal updates expiresAt. Test revoke modal cancels subscription. Verify success toasts display.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T13:21:22.212Z"
          },
          {
            "id": 13,
            "title": "Build webhook event viewer backend API with filtering and retry",
            "description": "Create API endpoints for listing App Store webhook events with filtering (notification type, date range, subscription ID), event detail view, and retry failed webhook processing.",
            "dependencies": [
              6
            ],
            "details": "1. Assumption: AppStoreWebhookEvent model exists from Task 38 (add to schema if missing)\n2. Create server/src/controllers/adminWebhookController.ts and server/src/services/adminWebhookService.ts\n3. GET /api/admin/webhooks: list webhook events with pagination (newest first)\n4. Query params: notificationType (SUBSCRIBED, DID_RENEW, etc.), status (success, failed), startDate, endDate, subscriptionId, originalTransactionId\n5. Use Prisma where clause with filters, order by createdAt DESC\n6. Include related subscription and user data\n7. GET /api/admin/webhooks/:id: return full webhook event with complete JSON payload, processing status, error message if failed\n8. POST /api/admin/webhooks/:id/retry: retry processing failed webhook\n9. Implementation: call webhook processing service (from Task 38) with stored payload, update status based on result\n10. Require SUPER_ADMIN role for retry endpoint\n11. Apply audit logging: auditLog('WEBHOOK_RETRY')\n12. Create Zod schemas: listWebhooksQuerySchema\n13. Add routes in server/src/routes/admin.ts",
            "status": "done",
            "testStrategy": "Test GET /api/admin/webhooks returns paginated events. Test filters (notification type, date range, status). Test detail view returns full payload. Test retry endpoint processes webhook (mock processing service). Verify RBAC for retry (403 for non-SUPER_ADMIN). Verify audit log created on retry.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T13:10:28.518Z"
          },
          {
            "id": 14,
            "title": "Build webhook event viewer UI with filtering and retry functionality",
            "description": "Create webhook event list page with advanced filtering, event detail view showing full JSON payload, and retry button for failed events with real-time status updates.",
            "dependencies": [
              1,
              13
            ],
            "details": "1. Create admin-panel/app/(dashboard)/webhooks/page.tsx with TanStack Table\n2. Columns: notification type, subscription ID (link to subscription detail), received at, status (badge: success=green, failed=red, pending=yellow), actions\n3. Add filter controls: notification type dropdown (all types from Task 38), status dropdown (success, failed, pending), date range picker (shadcn/ui Calendar)\n4. Implement client-side filtering with URL params (persist filters on page reload)\n5. Click row to expand and show full JSON payload using shadcn/ui Collapsible or Accordion\n6. Use JSON syntax highlighting library (react-json-view or similar) for payload display\n7. For failed events, show error message prominently\n8. Add Retry button for failed events (require SUPER_ADMIN role)\n9. On retry click, call POST /api/admin/webhooks/:id/retry\n10. Show loading spinner on retry button during processing\n11. Poll event status after retry (useQuery with refetchInterval) or use optimistic update\n12. Display success/failure toast after retry completes\n13. Add search input for originalTransactionId (quick lookup from support tickets)",
            "status": "done",
            "testStrategy": "Test webhook list loads with correct data. Test filters (notification type, status, date range) apply correctly. Test JSON payload displays with syntax highlighting. Test retry button appears only for failed events and SUPER_ADMIN role. Test retry updates event status. Test search by originalTransactionId filters events. Test pagination works with filters applied.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T16:38:20.665Z"
          },
          {
            "id": 15,
            "title": "Build analytics calculations backend for MRR, churn, and trial conversion",
            "description": "Create backend API endpoint and service layer for calculating key subscription analytics: MRR, churn rate, trial conversion rate, new subscriptions, and active subscribers by tier.",
            "dependencies": [
              6
            ],
            "details": "1. Create server/src/services/adminAnalyticsService.ts with analytics calculation functions\n2. getSubscriptionMetrics(): calculate active subscribers by tier (Pro Monthly, Pro Yearly, Trial)\n3. MRR calculation: sum of (monthly subscription price) for active subscriptions + (yearly price / 12) for yearly subscriptions\n4. Use Prisma aggregation: Subscription.count({ where: { status: 'ACTIVE', productId: 'pro_monthly' } })\n5. getNewSubscriptions(period): count subscriptions created in period (today, this week, this month)\n6. Use Prisma where: { createdAt: { gte: startDate } }\n7. getChurnMetrics(period): calculate cancellations in period, churn rate = cancellations / active_at_start\n8. Use Subscription status transitions (need to track cancelledAt timestamp - add to schema if missing)\n9. getTrialMetrics(): active trials count, trial conversion rate = (trials converted to paid) / (trials started in last 30 days)\n10. Query: Subscription.count({ where: { status: 'ACTIVE', AND: [{ createdAt: { lte: 30 days ago } }, { originalTransactionId: { not: null } }] } })\n11. Create GET /api/admin/analytics/overview endpoint in adminAnalyticsController\n12. Return JSON: { mrr, activeSubscribers: { total, proMonthly, proYearly, trial }, newSubscriptions: { today, week, month }, churn: { rate, count }, trials: { active, conversionRate } }\n13. Add route in server/src/routes/admin.ts\n14. Apply RBAC: requireAdmin() (all roles can view analytics)",
            "status": "done",
            "testStrategy": "Unit test analytics calculations with mock data. Test MRR calculation (10 monthly at $9.99 + 5 yearly at $79.99 = $132.90). Test churn rate calculation. Test trial conversion rate with sample data. Integration test GET /api/admin/analytics/overview returns correct structure. Test performance with 10,000 subscriptions (should return < 2 seconds).",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T13:06:14.810Z"
          },
          {
            "id": 16,
            "title": "Build analytics dashboard UI with Tremor charts and metric cards",
            "description": "Create dashboard overview page with real-time subscription metrics, MRR/revenue charts, subscriber count over time, and trial conversion metrics using Tremor chart library.",
            "dependencies": [
              1,
              15
            ],
            "details": "1. Create admin-panel/app/(dashboard)/page.tsx for dashboard overview\n2. Fetch analytics data from GET /api/admin/analytics/overview using useQuery\n3. Create metric cards grid (4 cards across) using Tremor Card component:\n   - Total Active Subscribers (with count by tier in subtitle)\n   - Monthly Recurring Revenue (MRR in USD, format with currency)\n   - New Subscriptions This Month (with week/today in subtitle)\n   - Churn Rate (percentage with count in subtitle)\n4. Use Tremor Metric and Text components for card content\n5. Add color coding: green for positive metrics, red for churn\n6. Create admin-panel/components/analytics/metrics-cards.tsx reusable component\n7. Fetch time-series data for charts: GET /api/admin/analytics/subscribers-over-time and GET /api/admin/analytics/revenue-over-time (create these endpoints)\n8. Create Subscribers Over Time line chart using Tremor LineChart component (last 30 days, daily data points)\n9. Create Revenue Over Time area chart using Tremor AreaChart (last 12 months, monthly MRR)\n10. Create Subscription Status pie chart using Tremor DonutChart (active, trial, expired distribution)\n11. Add Trial Conversion Funnel using Tremor BarList (trials started → active → converted)\n12. Implement auto-refresh every 60 seconds using useQuery refetchInterval\n13. Add date range selector for charts (last 7 days, 30 days, 90 days, 1 year)",
            "status": "done",
            "testStrategy": "Test dashboard loads with correct metric values. Verify charts render with sample data. Test auto-refresh updates data every 60 seconds. Test date range selector updates chart data. Test metric cards show color coding correctly. Verify currency formatting for MRR. Test responsive layout on different screen sizes.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T16:38:36.518Z"
          },
          {
            "id": 17,
            "title": "Implement security hardening: rate limiting, session security, IP allowlist",
            "description": "Add production-grade security hardening to admin panel: strict rate limiting on admin endpoints, secure session configuration, optional IP allowlisting, and enhanced security headers.",
            "dependencies": [
              6
            ],
            "details": "1. Create server/src/middleware/adminRateLimiter.ts using express-rate-limit\n2. Admin login endpoint: 5 requests per 15 minutes per IP (more strict than app endpoints)\n3. Admin API endpoints: 100 requests per 15 minutes per admin user (track by adminUserId from JWT)\n4. Use Redis store for rate limiting if available (fallback to memory store)\n5. Return 429 Too Many Requests with Retry-After header\n6. Create server/src/middleware/ipAllowlist.ts for optional IP restriction\n7. Read ADMIN_IP_ALLOWLIST from environment (comma-separated IPs), skip if not set\n8. Check req.ip against allowlist, return 403 if not allowed\n9. Log blocked IPs in AdminAuditLog with action='IP_BLOCKED'\n10. Update helmet configuration in server/src/middleware/security.ts for admin routes:\n    - Stricter CSP: no inline scripts, only same-origin\n    - X-Frame-Options: DENY (prevent iframe embedding)\n    - X-Content-Type-Options: nosniff\n11. Configure CORS for admin API: only allow admin-panel origin (admin.nutri.app or localhost:3001)\n12. Add security headers to Next.js admin panel in next.config.js\n13. Apply adminRateLimiter and ipAllowlist middleware to all /api/admin/* routes\n14. Document in .env.example: ADMIN_IP_ALLOWLIST (optional)",
            "status": "done",
            "testStrategy": "Test rate limiting: make 6 login requests in 15 minutes, verify 6th returns 429. Test IP allowlist blocks non-allowed IPs (set ADMIN_IP_ALLOWLIST=127.0.0.1 and test from different IP). Test CORS rejects requests from unauthorized origins. Test security headers present in responses using securityheaders.com. Verify audit log records blocked IPs.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T13:41:43.832Z"
          },
          {
            "id": 18,
            "title": "Write comprehensive test suite and deployment configuration",
            "description": "Create unit tests, integration tests, E2E tests for admin panel MVP. Set up deployment configuration for Next.js app (Vercel) and document deployment process with environment variables.",
            "dependencies": [
              2,
              3,
              6,
              7,
              8,
              11,
              13,
              15,
              17
            ],
            "details": "1. Backend unit tests in server/src/__tests__/admin/:\n   - adminAuthService.test.ts: password verification, MFA setup, session tokens\n   - adminUserService.test.ts: user list, search, export, delete\n   - adminSubscriptionService.test.ts: grant, extend, revoke\n   - adminAnalyticsService.test.ts: MRR, churn, trial conversion calculations\n2. Backend integration tests in server/src/__tests__/admin/integration/:\n   - adminAuth.integration.test.ts: login flow, MFA flow, session management\n   - adminUsers.integration.test.ts: GET /users, GET /users/:id, DELETE /users/:id\n   - adminSubscriptions.integration.test.ts: manual operations\n   - Test RBAC enforcement (403 for unauthorized roles)\n   - Test audit logging (verify records created)\n3. Frontend tests in admin-panel/:\n   - Install @testing-library/react, @testing-library/jest-dom\n   - Test components: user-table.test.tsx, grant-modal.test.tsx, metrics-cards.test.tsx\n   - Test hooks: useResponsive (if created), useDebounce\n   - Mock API calls with MSW (Mock Service Worker)\n4. Create admin-panel/vercel.json for Vercel deployment configuration\n5. Set environment variables in Vercel dashboard: NEXTAUTH_SECRET, NEXTAUTH_URL, API_URL (backend URL)\n6. Create deployment guide in admin-panel/README.md:\n   - Prerequisites (Node.js 18+, npm)\n   - Environment variables required\n   - Build command: npm run build\n   - Start command: npm start\n   - Database migrations (run before deployment)\n7. Create seed script for AdminUser in server/prisma/seed.ts (create first SUPER_ADMIN account)\n8. Document admin user creation: npm run seed:admin (create initial admin with email/password)\n9. Add npm scripts to admin-panel/package.json: test, test:watch, test:coverage\n10. Achieve > 80% coverage for critical paths (auth, RBAC, audit logging)",
            "status": "done",
            "testStrategy": "Run all tests: `npm test` in server/ and admin-panel/. Verify coverage reports meet 80% threshold. Test deployment to Vercel staging environment. Verify environment variables loaded correctly. Test admin login works in production. Test RBAC and audit logging in staging. Run security scan with `npm audit` and fix high/critical vulnerabilities.",
            "parentId": "undefined",
            "updatedAt": "2025-12-23T13:48:50.941Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 18,
        "expansionPrompt": "Break down this task into detailed subtasks covering: (1) Next.js admin app setup with authentication infrastructure, (2) database schema extensions for AdminUser and audit logging, (3) backend API development for admin operations with proper RBAC, (4) user management UI with search/detail/GDPR features, (5) subscription management UI with manual operations, (6) webhook event viewer, (7) analytics dashboard with Tremor charts, (8) security hardening (MFA, audit logs, rate limiting), (9) comprehensive testing, and (10) deployment configuration. Each subtask should be granular enough to be completed in 4-8 hours. Consider the existing tech stack (Express, Prisma, Zod validation) and leverage patterns already established in the codebase for consistency.",
        "updatedAt": "2025-12-23T16:38:36.518Z"
      },
      {
        "id": 40,
        "title": "Push Notifications System with Admin Management and User Preferences",
        "description": "Implement a comprehensive push notification system supporting iOS (APNs) and Android (FCM) with granular user preference controls, admin panel notification management, and contextual permission requests during onboarding. Follow 2025 iOS development best practices including provisional authorization, Focus Mode respect, Time Sensitive notifications, and Live Activities support.",
        "details": "## Technical Architecture\n\n### Mobile App (expo-notifications)\n1. **Permission Flow**\n   - Pre-permission priming screen with value proposition visuals\n   - Provisional authorization for iOS (silent notifications first)\n   - Just-in-time permission request during onboarding (after first meal logged)\n   - Graceful decline handling with in-app follow-up prompts\n   - Check and request notification permissions via `expo-notifications`\n\n2. **Notification Categories & Actions**\n   - MEAL_REMINDER: Quick-log actions, snooze, dismiss\n   - GOAL_PROGRESS: View details, log meal\n   - HEALTH_INSIGHT: View correlation, dismiss\n   - SUPPLEMENT_REMINDER: Mark taken, snooze\n   - STREAK_ALERT: Log now, remind later\n   - WEEKLY_SUMMARY: View report\n\n3. **Rich Notification Support**\n   - Custom images for meal suggestions\n   - Action buttons for quick interactions\n   - Custom sounds per category (optional)\n   - Notification grouping by category\n\n4. **iOS-Specific Features (2025)**\n   - Live Activities for real-time calorie/macro tracking\n   - Focus Mode filtering (interruptionLevel)\n   - Time Sensitive for health alerts\n   - Provisional authorization flow\n   - Critical alerts (if applicable for health metrics)\n\n5. **User Preferences Screen**\n   - Master toggle (all notifications)\n   - Category toggles with descriptions:\n     * Meal reminders (with time pickers per meal)\n     * Goal progress updates\n     * Health insights from ML\n     * Supplement reminders\n     * Streak alerts\n     * Weekly summaries\n     * Marketing/tips (separate consent)\n   - Quiet hours configuration (start/end times)\n   - Notification frequency controls\n\n### Backend API (Express/Node.js)\n\n1. **Database Schema (Prisma)**\n   - DeviceToken model: userId, token, platform, createdAt, lastActiveAt\n   - NotificationPreference model: userId, category, enabled, settings (JSON)\n   - NotificationLog model: id, userId, type, title, body, sentAt, deliveredAt, openedAt, actionTaken\n   - NotificationCampaign model: id, title, segment, content, scheduledAt, status, analytics\n\n2. **Push Service Integration**\n   - APNs provider configuration (jwt or certificate auth)\n   - FCM HTTP v1 API integration\n   - Unified send interface abstracting platform differences\n   - Token refresh handling and cleanup of stale tokens\n   - Delivery receipt tracking\n\n3. **Scheduling System**\n   - Timezone-aware scheduling (store user timezone)\n   - Recurring notification jobs (meal reminders)\n   - Campaign scheduling with queue (Bull/BullMQ)\n   - Rate limiting to prevent notification fatigue\n   - Smart send time optimization based on user engagement\n\n4. **API Endpoints**\n   - POST /api/notifications/register-device\n   - DELETE /api/notifications/unregister-device\n   - GET /api/notifications/preferences\n   - PUT /api/notifications/preferences\n   - POST /api/notifications/test (dev only)\n   - GET /api/notifications/history\n\n### Admin Panel Features\n\n1. **Campaign Management**\n   - Create notification campaigns with rich editor\n   - Schedule future sends with timezone handling\n   - User segmentation filters:\n     * By activity level (active, dormant, churned)\n     * By goals (weight loss, muscle gain, etc.)\n     * By engagement metrics\n     * By subscription status\n   - A/B testing support (title, body, timing)\n   - Preview on device mockups\n\n2. **Analytics Dashboard**\n   - Delivery rate metrics\n   - Open rate tracking\n   - Engagement metrics (action button taps)\n   - Conversion tracking (e.g., notification → meal logged)\n   - Unsubscribe/opt-out trends\n   - Best performing notification types\n\n3. **Individual User Management**\n   - Send notification to specific user\n   - View user's notification history\n   - View/override user preferences (support use case)\n   - Device token management\n\n4. **Notification Templates**\n   - Reusable templates for common notifications\n   - Variable interpolation ({{userName}}, {{goalProgress}}, etc.)\n   - Multi-language support preparation\n\n5. **Audit & Compliance**\n   - Full notification send history\n   - GDPR-compliant consent tracking\n   - Marketing opt-in separate from transactional\n   - Data retention policies for notification logs\n\n### Onboarding Integration\n\n1. **Permission Request Timing**\n   - Show pre-permission screen after user completes first meal log\n   - Explain 3 key benefits with illustrations\n   - Offer to customize preferences immediately\n   - Skip option with in-app reminder after 3 days\n\n2. **Initial Preference Setup**\n   - Quick toggles for main categories during onboarding\n   - Meal reminder time setup based on typical schedule\n   - Smart defaults based on user goals\n\n3. **Decline Handling**\n   - Track permission status\n   - Show contextual prompts when relevant (e.g., \"Enable reminders to keep your streak!\")\n   - Never ask more than once per week\n   - Deep link to iOS Settings if permanently declined\n\n## Dependencies\n- expo-notifications package\n- APNs credentials (Apple Developer account)\n- FCM project setup (Firebase Console)\n- Redis for job queue (already in stack)\n- Bull/BullMQ for scheduling\n\n## Security Considerations\n- Validate device tokens server-side\n- Rate limit notification API endpoints\n- Secure APNs/FCM credentials in environment\n- Audit logging for admin actions",
        "testStrategy": "## Testing Strategy\n\n### Unit Tests\n- Notification preference CRUD operations\n- Device token registration/validation\n- Notification payload construction per platform\n- Timezone conversion utilities\n- Segmentation filter logic\n\n### Integration Tests\n- End-to-end device registration flow\n- Preference sync between app and server\n- Campaign creation and scheduling\n- Admin API authorization\n\n### E2E Tests (Maestro)\n- Onboarding permission flow\n- Preference screen interactions\n- Notification tap handling and deep links\n\n### Manual Testing\n- Real device testing on iOS and Android\n- APNs sandbox vs production\n- Focus Mode behavior verification\n- Background/foreground notification handling\n- Rich notification rendering\n\n### Load Testing\n- Bulk notification send performance\n- Queue processing under load",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement Prisma database schema for push notifications",
            "description": "Create Prisma models for DeviceToken, NotificationPreference, NotificationLog, and NotificationCampaign with proper indexes and relationships to the User model",
            "dependencies": [],
            "details": "Add the following models to server/prisma/schema.prisma:\n\n1. DeviceToken model:\n   - Fields: id (cuid), userId (relation), token (String), platform (enum: IOS/ANDROID), isActive (Boolean), lastActiveAt (DateTime)\n   - Indexes: [userId, isActive], [token], [userId, platform]\n   - Unique constraint on [userId, token, platform]\n\n2. NotificationPreference model:\n   - Fields: id (cuid), userId (unique relation), enabledCategories (String[]), quietHoursStart (String nullable), quietHoursEnd (String nullable), mealReminderTimes (Json), settings (Json)\n   - Categories: MEAL_REMINDER, GOAL_PROGRESS, HEALTH_INSIGHT, SUPPLEMENT_REMINDER, STREAK_ALERT, WEEKLY_SUMMARY, MARKETING\n   - Index: [userId]\n\n3. NotificationLog model:\n   - Fields: id (cuid), userId, notificationType (String), category (String), title, body, data (Json), platform (enum), sentAt, deliveredAt (nullable), openedAt (nullable), actionTaken (String nullable)\n   - Indexes: [userId, sentAt], [notificationType], [category]\n\n4. NotificationCampaign model:\n   - Fields: id (cuid), title, targetSegment (Json), content (Json), scheduledAt, sentAt (nullable), status (enum: DRAFT/SCHEDULED/SENDING/COMPLETED/FAILED), deliveryCount (Int default 0), openCount (Int default 0)\n   - Indexes: [status], [scheduledAt]\n\nAfter schema creation:\n- Run `npm run db:generate` to generate Prisma client\n- Run `npm run db:push` for development or create migration with `npm run db:migrate`\n- Update server/src/types/index.ts if needed for TypeScript types",
            "status": "pending",
            "testStrategy": "1. Verify schema compiles without errors\n2. Test database migrations run successfully\n3. Verify all relationships and indexes are created\n4. Test CRUD operations on each model\n5. Verify unique constraints work correctly",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement backend push notification service with APNs and FCM integration",
            "description": "Create a unified push notification service that abstracts APNs (iOS) and FCM (Android) provider implementations with token management and delivery tracking",
            "dependencies": [
              1
            ],
            "details": "Create server/src/services/pushNotificationService.ts:\n\n1. Install dependencies:\n   - `npm install @parse/node-apn` for APNs\n   - `npm install firebase-admin` for FCM\n   - Add types: `@types/node-apn`\n\n2. Service structure:\n   - Initialize APNs provider (production/sandbox based on NODE_ENV)\n   - Initialize Firebase Admin SDK for FCM\n   - Abstract send interface: sendNotification(userId, payload, options)\n   - Platform detection from device token registration\n\n3. Core methods:\n   - `sendToUser(userId: string, notification: NotificationPayload)`: Send to all user's active devices\n   - `sendToDevice(token: string, platform: Platform, notification: NotificationPayload)`: Send to specific device\n   - `sendBatch(userIds: string[], notification: NotificationPayload)`: Batch sending\n   - `registerDevice(userId: string, token: string, platform: Platform)`: Register/update device token\n   - `unregisterDevice(userId: string, token: string)`: Mark device inactive\n   - `cleanupStaleTokens()`: Remove tokens that have bounced\n\n4. Notification payload structure:\n   - title, body, data (custom payload)\n   - category (for action buttons)\n   - badge (iOS), sound\n   - interruptionLevel (iOS: passive/active/timeSensitive/critical)\n   - threadId (for grouping)\n\n5. Error handling:\n   - Handle invalid tokens (remove from database)\n   - Retry logic for transient failures\n   - Log delivery failures to NotificationLog\n\n6. Environment variables (server/.env):\n   - APNS_KEY_ID, APNS_TEAM_ID, APNS_KEY_PATH, APNS_BUNDLE_ID\n   - FIREBASE_SERVICE_ACCOUNT_PATH or FIREBASE_PROJECT_ID\n   - APNS_PRODUCTION=false (for development)",
            "status": "pending",
            "testStrategy": "1. Unit tests with mocked APNs/FCM clients\n2. Test token registration and cleanup\n3. Test invalid token handling\n4. Integration test with real APNs sandbox environment\n5. Test batch sending with multiple devices\n6. Verify delivery receipts are logged correctly",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create backend API endpoints for device registration and notification preferences",
            "description": "Implement REST API endpoints following existing controller/service pattern for managing device tokens and user notification preferences",
            "dependencies": [
              1,
              2
            ],
            "details": "Create server/src/routes/notificationRoutes.ts and server/src/controllers/notificationController.ts:\n\n1. POST /api/notifications/register-device\n   - Body: { token: string, platform: 'ios' | 'android' }\n   - Validates token format\n   - Calls pushNotificationService.registerDevice()\n   - Returns: { success: boolean, deviceId: string }\n\n2. DELETE /api/notifications/unregister-device\n   - Body: { token: string }\n   - Marks device as inactive\n   - Returns: { success: boolean }\n\n3. GET /api/notifications/preferences\n   - Returns user's notification preferences\n   - Returns: { enabledCategories: string[], quietHours: {...}, settings: {...} }\n\n4. PUT /api/notifications/preferences\n   - Body: { enabledCategories?: string[], quietHoursStart?: string, quietHoursEnd?: string, settings?: object }\n   - Updates preferences (partial update)\n   - Returns updated preferences\n\n5. GET /api/notifications/history\n   - Query params: ?page=1&limit=20&category=MEAL_REMINDER\n   - Returns paginated notification history\n   - Follows pagination pattern from existing controllers\n\n6. POST /api/notifications/test (dev only)\n   - Sends test notification to user\n   - Only enabled when NODE_ENV=development\n   - Returns: { success: boolean, sentTo: number }\n\nValidation (server/src/validation/schemas.ts):\n- Create registerDeviceSchema, updatePreferencesSchema\n- Use existing patterns from authController.ts and mealController.ts\n\nMiddleware:\n- All endpoints require authentication (use requireAuth)\n- Apply rate limiting (100 req/15min for registration, standard for others)\n- Input sanitization via existing sanitize middleware\n\nRegister routes in server/src/index.ts following existing pattern",
            "status": "pending",
            "testStrategy": "1. Unit tests for each controller method\n2. Test validation schemas with invalid inputs\n3. Integration tests for full request/response cycle\n4. Test authentication middleware enforcement\n5. Test rate limiting on registration endpoint\n6. Test pagination on history endpoint",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement notification scheduling system with Bull/BullMQ and Redis",
            "description": "Create a job queue system for scheduling recurring notifications (meal reminders, weekly summaries) and campaign sends with timezone-aware scheduling",
            "dependencies": [
              2
            ],
            "details": "Create server/src/services/notificationScheduler.ts using Bull:\n\n1. Install dependencies:\n   - `npm install bull` (BullMQ requires Bull v4+ and may have breaking changes)\n   - `npm install @types/bull`\n   - Redis is already in the stack (verify connection in docker-compose)\n\n2. Queue setup:\n   - Create queue: notificationQueue = new Bull('notifications', redisConfig)\n   - Define job types: MEAL_REMINDER, WEEKLY_SUMMARY, CAMPAIGN_SEND, HEALTH_INSIGHT\n\n3. Job processors:\n   - processMealReminder(job): Get users with enabled MEAL_REMINDER, check quiet hours, send notification\n   - processWeeklySummary(job): Generate weekly stats, send to users with enabled WEEKLY_SUMMARY\n   - processCampaignSend(job): Get user segment, batch send notifications\n   - processHealthInsight(job): Check for new ML insights, send notifications\n\n4. Scheduling methods:\n   - `scheduleMealReminder(userId: string, time: string)`: Schedule daily recurring job\n   - `scheduleWeeklySummary(userId: string, dayOfWeek: number, time: string)`: Schedule weekly job\n   - `scheduleCampaign(campaignId: string, sendAt: Date)`: Schedule one-time campaign\n   - `cancelUserJobs(userId: string)`: Remove all scheduled jobs for user\n   - `updateMealReminderSchedule(userId: string, times: object)`: Update user's meal reminder times\n\n5. Timezone handling:\n   - Store user timezone in User model (add timezone field to schema)\n   - Use moment-timezone to convert user local time to UTC for scheduling\n   - Schedule jobs in UTC, convert back to user timezone when processing\n\n6. Smart send time optimization:\n   - Track user's typical engagement times from NotificationLog.openedAt\n   - Adjust send times to user's active hours\n   - Implement in future iteration (add TODO comment)\n\n7. Rate limiting:\n   - Max 5 notifications per user per day\n   - Implement check in job processor\n   - Skip if limit exceeded, log to NotificationLog\n\n8. Queue monitoring:\n   - Add Bull Board for queue UI: `npm install @bull-board/express`\n   - Mount at /admin/queues (admin auth required)\n\nEnvironment variables:\n- REDIS_URL (already configured for ml-service)\n- NOTIFICATION_QUEUE_CONCURRENCY=5",
            "status": "pending",
            "testStrategy": "1. Unit tests for scheduling logic with mocked queue\n2. Test timezone conversion accuracy\n3. Integration test with real Redis instance\n4. Test job retry on failure\n5. Test rate limiting enforcement\n6. Test job cancellation and updates\n7. Manual testing with Bull Board UI",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Setup expo-notifications in mobile app with permission handling",
            "description": "Install and configure expo-notifications, implement permission request flow, and set up notification handlers for foreground/background/tap events",
            "dependencies": [],
            "details": "1. Install expo-notifications (check if already in package.json dependencies - it's not currently installed):\n   - `npx expo install expo-notifications`\n   - `npx expo install expo-device` (for checking if physical device)\n\n2. Create lib/services/notifications/index.ts:\n   - Configure notification channel for Android (high priority, sound enabled)\n   - Set notification handler for foreground notifications\n   - registerForPushNotificationsAsync(): Main permission request function\n   - getExpoPushToken(): Get Expo push token (or native APNs/FCM token)\n\n3. Permission flow:\n   - Check current permissions with Notifications.getPermissionsAsync()\n   - Request permissions with Notifications.requestPermissionsAsync()\n   - For iOS: Check for provisional authorization support\n   - Handle all permission states: granted, denied, undetermined\n   - Return token and permission status\n\n4. Create lib/context/NotificationContext.tsx:\n   - Provide notification state across app\n   - Store: permissionStatus, expoPushToken, notificationListener refs\n   - Methods: requestPermission(), registerDevice(), unregisterDevice()\n\n5. Notification handlers:\n   - Foreground listener: Notifications.addNotificationReceivedListener()\n   - Background/quit handler: Notifications.addNotificationResponseReceivedListener()\n   - Handle tap on notification: route to appropriate screen based on data.screen\n\n6. Update app/_layout.tsx:\n   - Wrap app with NotificationProvider\n   - Initialize notification listeners on mount\n   - Clean up listeners on unmount\n\n7. Notification categories (for action buttons):\n   - Define category identifiers matching backend\n   - Configure action buttons: \"View\", \"Dismiss\", \"Snooze\" (iOS only supports 4 actions max)\n   - Set categories with Notifications.setNotificationCategoryAsync()\n\n8. Testing utilities (lib/services/notifications/test.ts):\n   - scheduleTestNotification(): Schedule local notification for testing\n   - Only available in __DEV__ mode\n\nNote: expo-notifications currently not in package.json - needs to be installed first",
            "status": "pending",
            "testStrategy": "1. Test permission request flow on iOS simulator\n2. Test foreground notification display\n3. Test background notification handling\n4. Test notification tap navigation\n5. Test on physical device (push notifications don't work on simulator)\n6. Test notification categories and action buttons\n7. Verify token registration with backend",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement onboarding pre-permission priming flow",
            "description": "Create contextual permission request screens shown after user logs first meal, explaining notification benefits with option to customize preferences immediately",
            "dependencies": [
              5
            ],
            "details": "Create app/notifications/priming.tsx (new screen):\n\n1. Screen design:\n   - Header: \"Stay on track with smart reminders\"\n   - 3 benefit cards with icons:\n     * \"Never miss a meal\" - Customizable meal reminders\n     * \"Track your progress\" - Weekly summary reports\n     * \"Discover insights\" - ML-powered health correlations\n   - Primary button: \"Enable Notifications\"\n   - Secondary button: \"Customize Settings\" (shows preference toggles inline)\n   - Tertiary link: \"Maybe Later\"\n\n2. Trigger logic (update lib/context/AuthContext.tsx or create notification trigger service):\n   - Track if user has seen priming screen (AsyncStorage: 'hasSeenNotificationPriming')\n   - Track user's first meal log (add firstMealLoggedAt to User model or track locally)\n   - Show priming screen when:\n     * User completes first meal log AND\n     * Has not seen priming screen before AND\n     * Notification permission is 'undetermined'\n   - Use modal presentation or stack navigation\n\n3. Permission request flow:\n   - On \"Enable Notifications\" tap:\n     * Call NotificationContext.requestPermission()\n     * If granted: register device token with backend, show success message\n     * If denied: show instructions to enable in Settings, mark as seen\n   - On \"Customize Settings\" tap:\n     * Show inline category toggles (MEAL_REMINDER, GOAL_PROGRESS, etc.)\n     * Show meal reminder time pickers\n     * Save to backend preferences endpoint\n     * Then request permission\n   - On \"Maybe Later\" tap:\n     * Mark as seen, schedule in-app reminder for 3 days later\n     * Store: 'notificationReminderAt' in AsyncStorage\n\n4. Decline handling flow:\n   - If permission denied, store: 'notificationPermissionDenied' = true\n   - Show contextual in-app prompts when relevant:\n     * After logging 3-day streak: \"Enable reminders to maintain your streak!\"\n     * When viewing health insights: \"Get notified about new insights\"\n   - Prompts include deep link to iOS Settings if permanently declined\n   - Never ask more than once per week (track last prompt date)\n\n5. Navigation integration:\n   - Add route to app/_layout.tsx with headerShown: false\n   - Can be presented modally from anywhere using router.push('/notifications/priming')\n\n6. Illustrations/Assets:\n   - Add simple SVG illustrations or use expo-symbols for icons\n   - Use theme colors from lib/theme/colors.ts\n   - Responsive layout using lib/responsive utilities\n\nFollow existing screen patterns from app/auth/welcome.tsx for styling",
            "status": "pending",
            "testStrategy": "1. Test trigger conditions (first meal logged, permission undetermined)\n2. Test permission grant flow\n3. Test permission denial flow and Settings deep link\n4. Test customize settings inline flow\n5. Test \"Maybe Later\" and reminder scheduling\n6. Test contextual prompts after denial\n7. Visual regression testing on different screen sizes",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Build user notification preferences settings screen",
            "description": "Create a settings screen with master toggle, category-specific toggles, quiet hours configuration, and meal reminder time pickers integrated with backend preferences API",
            "dependencies": [
              3,
              5
            ],
            "details": "Create app/notifications/preferences.tsx:\n\n1. Screen structure:\n   - Header: \"Notification Preferences\" with save button\n   - Master toggle: \"Enable All Notifications\" (disables all categories when off)\n   - Category sections:\n\n2. Category toggles with descriptions:\n   - MEAL_REMINDER: \"Meal Reminders\" - \"Get reminded to log your meals\"\n     * Sub-settings: Time pickers for breakfast/lunch/dinner (conditionally shown when enabled)\n   - GOAL_PROGRESS: \"Goal Progress\" - \"Daily and weekly progress updates\"\n   - HEALTH_INSIGHT: \"Health Insights\" - \"ML-powered nutrition-health correlations\"\n   - SUPPLEMENT_REMINDER: \"Supplement Reminders\" - \"Remember to take your supplements\"\n   - STREAK_ALERT: \"Streak Alerts\" - \"Don't lose your logging streak\"\n   - WEEKLY_SUMMARY: \"Weekly Summary\" - \"Your week in review every Sunday\"\n   - MARKETING: \"Tips & Updates\" - \"Product tips and feature updates\" (separate consent)\n\n3. Quiet hours configuration:\n   - Toggle: \"Enable Quiet Hours\"\n   - Start time picker (default: 10:00 PM)\n   - End time picker (default: 8:00 AM)\n   - Helper text: \"No notifications during these hours\"\n\n4. State management:\n   - Use local state for UI (useState)\n   - Load preferences from API on mount: GET /api/notifications/preferences\n   - Save on button tap or auto-save on toggle: PUT /api/notifications/preferences\n   - Show loading states during API calls\n   - Handle errors with Alert.alert\n\n5. Meal reminder time pickers:\n   - Use @react-native-community/datetimepicker (already in dependencies)\n   - Store times as strings (HH:mm format)\n   - Update backend when changed\n   - Trigger reschedule of meal reminder jobs on backend\n\n6. Permission status indicator:\n   - Show current notification permission status at top\n   - If denied: Show \"Notifications Disabled\" banner with \"Open Settings\" button\n   - Deep link to iOS Settings using Linking.openSettings()\n\n7. Styling:\n   - Follow existing patterns from app/health-settings.tsx\n   - Use theme colors from lib/theme/colors.ts\n   - Responsive layout with lib/responsive utilities\n   - Section headers with separators\n   - Toggle switches with platform-specific styling\n\n8. Navigation:\n   - Add to app/(tabs)/profile.tsx as a list item: \"Notification Preferences\"\n   - Register route in app/_layout.tsx with headerShown: false\n   - Custom header component with back button and save button\n\nAPI integration:\n- Use lib/api/client.ts for authenticated requests\n- Follow error handling pattern from lib/utils/errorHandling.ts\n- Show success feedback after save (subtle checkmark or toast)",
            "status": "pending",
            "testStrategy": "1. Test preferences load from API\n2. Test toggle state management\n3. Test quiet hours time picker\n4. Test meal reminder time pickers\n5. Test save to backend with success/error cases\n6. Test permission denied banner and Settings deep link\n7. Test master toggle disabling all categories\n8. Visual testing on iOS and Android",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement notification handling for foreground, background, and tap actions",
            "description": "Handle notifications in all app states (foreground/background/quit), implement navigation based on notification data, and track notification opens",
            "dependencies": [
              5,
              3
            ],
            "details": "Update lib/services/notifications/index.ts and create lib/services/notifications/handlers.ts:\n\n1. Foreground notification handler:\n   - Notifications.setNotificationHandler({ handleNotification: async () => {...} })\n   - Return: { shouldShowAlert: true, shouldPlaySound: true, shouldSetBadge: false }\n   - Show in-app notification banner (use custom component or native)\n   - Add to notification center\n\n2. Background/tap notification handler:\n   - Notifications.addNotificationResponseReceivedListener((response) => {...})\n   - Extract notification data: response.notification.request.content.data\n   - Route to appropriate screen based on data.screen and data.params\n\n3. Routing logic based on notification type:\n   - MEAL_REMINDER → Navigate to /add-meal with optional data.mealType\n   - GOAL_PROGRESS → Navigate to /(tabs)/ (dashboard)\n   - HEALTH_INSIGHT → Navigate to /health/[metricType] with data.metricType\n   - SUPPLEMENT_REMINDER → Navigate to /supplements with data.supplementId\n   - STREAK_ALERT → Navigate to /add-meal\n   - WEEKLY_SUMMARY → Navigate to /(tabs)/health with data.weekStart\n\n4. Action button handling (iOS notification categories):\n   - Check response.actionIdentifier\n   - Handle actions: VIEW, DISMISS, SNOOZE, LOG_NOW, MARK_TAKEN\n   - SNOOZE: Schedule local notification for 15 minutes later\n   - LOG_NOW: Open appropriate logging screen with pre-filled data\n   - MARK_TAKEN: Call supplement API to mark as taken\n\n5. Track notification opens:\n   - Call backend: POST /api/notifications/track with { notificationId, action: 'opened' }\n   - Include actionIdentifier if action button was tapped\n   - Update NotificationLog.openedAt and actionTaken\n\n6. Badge management:\n   - Get current badge count: Notifications.getBadgeCountAsync()\n   - Set badge count: Notifications.setBadgeCountAsync(count)\n   - Clear badge on app launch: call setBadgeCountAsync(0) in app/_layout.tsx\n   - Decrement badge when notification is read\n\n7. Deep linking integration:\n   - Use expo-router's router.push() for navigation\n   - Handle edge cases: app not fully initialized, auth required\n   - Queue navigation until app is ready if needed\n\n8. Notification state persistence:\n   - Store last notification ID in AsyncStorage to prevent duplicate handling\n   - Clear on app launch\n\n9. Error handling:\n   - Wrap all handlers in try-catch\n   - Log errors but don't crash app\n   - Fallback to dashboard if navigation fails\n\n10. Platform differences:\n    - iOS: Action buttons work, badge count works\n    - Android: Limited action buttons, different badge behavior\n    - Test both platforms thoroughly\n\nIntegration in app/_layout.tsx:\n- Initialize handlers on app mount\n- Clean up listeners on unmount\n- Handle navigation from notification when app is quit (check Notifications.getLastNotificationResponseAsync())",
            "status": "pending",
            "testStrategy": "1. Test foreground notification display\n2. Test background notification tap navigation\n3. Test quit state notification tap (cold start)\n4. Test each notification type's routing\n5. Test action button handling on iOS\n6. Test badge count management\n7. Test tracking API calls\n8. Test error scenarios (invalid data, missing screens)\n9. Test on both iOS and Android",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement iOS-specific notification features (Live Activities, Focus Mode, provisional auth)",
            "description": "Add support for iOS 2025 best practices including provisional authorization, Focus Mode respect via interruptionLevel, Time Sensitive notifications, and Live Activities for real-time tracking",
            "dependencies": [
              5,
              8
            ],
            "details": "1. Provisional Authorization (iOS 12+):\n   - Update lib/services/notifications/index.ts permission request\n   - First attempt provisional authorization: { ios: { allowProvisional: true } }\n   - Deliver notifications silently to notification center without interrupting\n   - After user engages with notification, request full permission\n   - Track provisional state separately from full authorization\n\n2. Focus Mode filtering (iOS 15+):\n   - Set interruptionLevel in notification payload:\n     * passive: Appears in notification center only (default for most)\n     * active: Normal notification with sound (meal reminders)\n     * timeSensitive: Breaks through Focus Mode (health alerts)\n     * critical: Requires special entitlement (skip for now)\n   - Update pushNotificationService.ts to set interruptionLevel based on category:\n     * MEAL_REMINDER → active\n     * HEALTH_INSIGHT → timeSensitive (if critical health metric)\n     * WEEKLY_SUMMARY → passive\n     * SUPPLEMENT_REMINDER → active\n\n3. Time Sensitive notifications:\n   - Request permission for Time Sensitive: { ios: { allowTimeSensitive: true } }\n   - Use for health alerts that need immediate attention\n   - Configure in notification payload: { interruptionLevel: 'timeSensitive' }\n\n4. Live Activities (iOS 16.1+) - Basic implementation:\n   - Install dependencies: `npx expo install expo-live-activities` (if available) or use native iOS module\n   - Note: Live Activities require native iOS development and ActivityKit\n   - Plan for future native module implementation\n   - Add TODO comments for:\n     * Real-time calorie/macro tracking widget\n     * Live progress bar during meal logging\n     * Daily goal progress ring\n   - Document requirements in CLAUDE.md for future implementation\n\n5. Notification relevance score (iOS 15+):\n   - Set relevanceScore (0.0 to 1.0) for notification ranking\n   - Higher scores appear more prominently\n   - Set based on category importance:\n     * STREAK_ALERT → 0.9\n     * HEALTH_INSIGHT → 0.8\n     * MEAL_REMINDER → 0.7\n     * WEEKLY_SUMMARY → 0.5\n\n6. Update notification payload structure:\n   - Add iOS-specific fields in pushNotificationService.ts:\n     * interruptionLevel\n     * relevanceScore\n     * threadId (for grouping)\n     * targetContentId (for replacing notifications)\n\n7. Notification grouping:\n   - Use threadId to group related notifications\n   - Examples:\n     * \"meal-reminders\" for all meal reminders\n     * \"health-insights-{metricType}\" for health insights by metric\n     * \"weekly-summary\" for weekly reports\n   - Configure summary format for notification stacks\n\n8. Critical Alerts (future consideration):\n   - Requires Apple approval and special entitlement\n   - Add TODO for critical health alerts (e.g., dangerous blood glucose)\n   - Document entitlement request process\n\n9. Platform-specific UI updates:\n   - Update priming screen to mention Focus Mode compatibility\n   - Add explanation of Time Sensitive notifications for health alerts\n   - Show current iOS notification settings (can't read programmatically, provide instructions)\n\n10. Testing:\n    - Test on iOS 15+ devices (provisional auth not supported on simulator)\n    - Test with different Focus Modes enabled\n    - Verify Time Sensitive notifications break through Do Not Disturb\n    - Test notification grouping with multiple notifications\n\nNote: Live Activities require native development - document for future iteration",
            "status": "pending",
            "testStrategy": "1. Test provisional authorization flow on iOS device\n2. Test notifications with different interruptionLevels\n3. Test Time Sensitive notifications during Focus Mode\n4. Test notification grouping by threadId\n5. Test relevanceScore ranking (difficult to verify directly)\n6. Test permission request for Time Sensitive\n7. Document Live Activities requirements\n8. Test on iOS 15, 16, and 17",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Build admin panel campaign creation and management UI",
            "description": "Create Next.js admin panel pages for creating notification campaigns, scheduling sends, defining user segments, and A/B testing notification variants",
            "dependencies": [
              1,
              3
            ],
            "details": "Create admin-panel/app/(dashboard)/dashboard/notifications/ directory:\n\n1. Campaign list page (page.tsx):\n   - Table showing all campaigns: title, status, scheduled date, delivery/open rates\n   - Filters: status (all/draft/scheduled/completed/failed), date range\n   - Actions: Edit, Duplicate, Delete, View Analytics\n   - \"Create Campaign\" button\n   - Pagination matching existing admin pages pattern\n\n2. Create/Edit campaign page (create/page.tsx and [id]/edit/page.tsx):\n   - Form fields:\n     * Campaign title (required)\n     * Notification title (max 50 chars, show preview)\n     * Notification body (max 150 chars, show preview)\n     * Category dropdown (MEAL_REMINDER, GOAL_PROGRESS, etc.)\n     * Data payload (JSON editor for custom data)\n     * Schedule: Now, Specific Date/Time, or Save as Draft\n     * Timezone selector (user's timezone or UTC)\n   - User segmentation section:\n     * Filters: Activity level (active/dormant/churned)\n     * Goal type (weight loss/muscle gain/maintain)\n     * Subscription tier (free/pro)\n     * Last active date range\n     * Custom SQL filter (admin only)\n     * Show estimated recipient count\n   - A/B testing section (optional):\n     * Enable A/B test toggle\n     * Variant A/B titles and bodies\n     * Split percentage (default 50/50)\n     * Test duration before auto-selecting winner\n   - Device preview:\n     * iOS and Android notification mockups\n     * Update in real-time as fields change\n     * Use react-device-frameset or similar library\n\n3. Campaign analytics page ([id]/analytics/page.tsx):\n   - Overview cards:\n     * Total sent, Delivered, Opened, Clicked (if action buttons)\n     * Delivery rate %, Open rate %, Click-through rate %\n   - Time-series chart: Opens over time (hourly for first 24h, then daily)\n   - Breakdown tables:\n     * By platform (iOS vs Android)\n     * By user segment\n     * By A/B variant (if test)\n   - Action button performance (if applicable)\n   - Export to CSV button\n\n4. Backend API endpoints (create server/src/routes/adminNotificationRoutes.ts):\n   - GET /api/admin/notifications/campaigns - List campaigns with pagination\n   - POST /api/admin/notifications/campaigns - Create campaign\n   - GET /api/admin/notifications/campaigns/:id - Get campaign details\n   - PUT /api/admin/notifications/campaigns/:id - Update campaign\n   - DELETE /api/admin/notifications/campaigns/:id - Delete campaign (only drafts)\n   - POST /api/admin/notifications/campaigns/:id/send - Send campaign immediately\n   - GET /api/admin/notifications/campaigns/:id/analytics - Get analytics\n   - POST /api/admin/notifications/campaigns/:id/test - Send test to admin's device\n   - POST /api/admin/notifications/segment/estimate - Estimate recipient count\n\n5. Backend controller (server/src/controllers/adminNotificationController.ts):\n   - Implement controllers for each endpoint\n   - User segmentation logic using Prisma queries\n   - Schedule campaign using notificationScheduler\n   - Audit logging for all campaign actions\n   - Permission checks (SUPER_ADMIN or SUPPORT role)\n\n6. Campaign send logic (update notificationScheduler.ts):\n   - Add processCampaignSend job\n   - Load campaign and segment users\n   - Batch send notifications (1000 users per batch)\n   - Update campaign status to SENDING, then COMPLETED\n   - Update deliveryCount and openCount as notifications are sent/opened\n   - Handle failures and retry logic\n\n7. A/B testing logic:\n   - Split users randomly into variants\n   - Track metrics per variant\n   - Auto-select winner after test duration based on open rate\n   - Send winning variant to remaining users (if applicable)\n\n8. UI Components (follow existing admin-panel patterns):\n   - Use admin-panel/components/ui/button.tsx and other shadcn components\n   - Follow layout from admin-panel/app/(dashboard)/layout.tsx\n   - Match styling with existing admin pages\n   - Use admin-panel/lib/api.ts for API calls\n\n9. Device preview component:\n   - Create components/NotificationPreview.tsx\n   - iOS and Android mockup frames\n   - Display title, body, icon, time\n   - Show action buttons if configured\n\n10. Form validation:\n    - Client-side: React Hook Form with zod schemas\n    - Server-side: Zod schemas in validation/adminSchemas.ts\n    - Validate segment filters, schedule times, character limits\n\nSecurity:\n- All endpoints require admin authentication\n- Audit log all campaign actions (create, edit, send)\n- Rate limit campaign sending to prevent spam",
            "status": "pending",
            "testStrategy": "1. Test campaign CRUD operations\n2. Test user segmentation filters and count estimation\n3. Test campaign scheduling with different timezones\n4. Test A/B variant creation and metrics tracking\n5. Test device preview rendering\n6. Test batch sending with large user segments\n7. Test admin authentication and permissions\n8. Test audit logging for all actions\n9. Integration test: create, schedule, send, track analytics",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Create admin panel analytics dashboard for notification metrics",
            "description": "Build comprehensive analytics views showing delivery rates, open rates, engagement metrics, conversion tracking, and opt-out trends with charts and exportable reports",
            "dependencies": [
              10
            ],
            "details": "Create admin-panel/app/(dashboard)/dashboard/notifications/analytics/page.tsx:\n\n1. Overview metrics (top cards):\n   - Total notifications sent (last 30 days)\n   - Average delivery rate %\n   - Average open rate %\n   - Average engagement rate (actions taken / delivered)\n   - Trend indicators (↑/↓ vs previous period)\n\n2. Time-series charts:\n   - Notifications sent over time (daily, weekly, monthly views)\n   - Open rate trend line\n   - Delivery rate trend line\n   - Use recharts or chart.js library\n   - Date range selector (7d, 30d, 90d, custom)\n\n3. Breakdown tables:\n   - By notification category:\n     * Category name, Sent count, Delivery %, Open %, Avg time to open\n     * Sort by any column\n   - By platform:\n     * iOS vs Android metrics\n     * Device model breakdown (from NotificationLog metadata)\n   - Top performing notifications:\n     * Highest open rates\n     * Most actions taken\n     * Show campaign title, sent date, metrics\n\n4. Conversion tracking:\n   - Track post-notification actions:\n     * MEAL_REMINDER → Meal logged within 1 hour\n     * GOAL_PROGRESS → App opened within 30 minutes\n     * HEALTH_INSIGHT → Metric detail viewed\n   - Conversion rate % for each category\n   - Time-to-action histogram\n   - Implementation: Track in NotificationLog with timestamps, correlate with user actions\n\n5. User engagement analysis:\n   - Notification frequency distribution (avg notifications per user per day)\n   - Most engaged users (highest open rates)\n   - Unresponsive users (0% open rate last 30 days)\n   - Engagement heatmap by time of day and day of week\n\n6. Opt-out/unsubscribe trends:\n   - Chart: Opt-outs over time\n   - Breakdown by category (which categories have highest opt-out)\n   - Opt-out reasons (if we add reason collection)\n   - Percentage of users with all notifications disabled\n\n7. Best performing send times:\n   - Heatmap: Open rate by hour of day and day of week\n   - Identify optimal send times per category\n   - Recommendations for campaign scheduling\n\n8. Platform comparison:\n   - Side-by-side metrics: iOS vs Android\n   - Delivery issues by platform\n   - Average time to delivery\n   - Action button engagement (iOS only)\n\n9. Export functionality:\n   - Export to CSV button for each table/chart\n   - PDF report generation (entire dashboard)\n   - Scheduled email reports (future feature - add TODO)\n\n10. Backend API endpoints (server/src/routes/adminNotificationRoutes.ts):\n    - GET /api/admin/notifications/analytics/overview?startDate&endDate\n    - GET /api/admin/notifications/analytics/by-category?startDate&endDate\n    - GET /api/admin/notifications/analytics/by-platform?startDate&endDate\n    - GET /api/admin/notifications/analytics/conversions?startDate&endDate\n    - GET /api/admin/notifications/analytics/engagement?startDate&endDate\n    - GET /api/admin/notifications/analytics/opt-outs?startDate&endDate\n    - GET /api/admin/notifications/analytics/send-times?startDate&endDate\n    - POST /api/admin/notifications/analytics/export - Generate CSV/PDF\n\n11. Backend service (server/src/services/adminNotificationAnalyticsService.ts):\n    - Implement complex Prisma aggregations\n    - Calculate derived metrics (rates, averages, trends)\n    - Optimize queries with indexes (NotificationLog indexes already in schema)\n    - Cache results for expensive queries (use Redis)\n    - Conversion tracking logic: correlate NotificationLog with Meal/Activity/HealthMetric timestamps\n\n12. UI components:\n    - Reuse admin panel patterns and components\n    - Responsive charts (mobile-friendly)\n    - Loading skeletons during data fetch\n    - Error states with retry buttons\n    - Empty states with helpful messages\n\n13. Performance optimization:\n    - Paginate large result sets\n    - Server-side aggregations (don't load all logs to client)\n    - Cache dashboard data (5-minute TTL)\n    - Lazy load charts below the fold\n\n14. Real-time updates (optional future feature):\n    - WebSocket connection for live metrics\n    - Auto-refresh every 30 seconds\n    - Add TODO for implementation\n\nStyling:\n- Match existing admin panel design\n- Use tailwind classes\n- Responsive grid layout\n- Print-friendly styles for PDF export",
            "status": "pending",
            "testStrategy": "1. Test metric calculations with sample data\n2. Test date range filtering\n3. Test each chart renders correctly\n4. Test conversion tracking accuracy\n5. Test CSV/PDF export generation\n6. Test performance with large datasets (10k+ notification logs)\n7. Test responsive design on different screen sizes\n8. Integration test: send campaign, verify metrics update\n9. Test caching behavior",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Implement admin panel individual user notification management and templates",
            "description": "Create admin interface for sending notifications to specific users, viewing user notification history, managing reusable notification templates, and overriding user preferences for support cases",
            "dependencies": [
              10,
              11
            ],
            "details": "Create admin-panel pages and backend endpoints:\n\n1. User notification management page (admin-panel/app/(dashboard)/dashboard/users/[id]/notifications/page.tsx):\n   - Accessible from user detail page\n   - Sections:\n     * Send notification to this user\n     * User's notification preferences (view/override)\n     * User's notification history\n     * User's device tokens\n\n2. Send notification to user:\n   - Form fields:\n     * Template dropdown (load from NotificationTemplate model)\n     * Or custom: Title, Body, Category, Data payload\n     * Send immediately or schedule\n   - Preview notification mockup\n   - Send button with confirmation\n   - Use cases: Support messages, account alerts, custom offers\n\n3. User preferences view/override:\n   - Display current preferences (enabled categories, quiet hours)\n   - Override toggle (support use case: re-enable critical health alerts)\n   - Reason field (required for audit log)\n   - Save override with admin audit logging\n   - Show override indicator in user preferences screen\n\n4. User notification history table:\n   - Columns: Date, Type, Title, Status (sent/delivered/opened), Action\n   - Filters: Date range, Category, Status\n   - Pagination (20 per page)\n   - Click row to view full notification details and user response\n\n5. User device tokens:\n   - Table: Platform, Token (truncated), Registered date, Last active, Status\n   - Actions: Revoke token (for troubleshooting)\n   - Show push token validity status\n\n6. Notification templates page (admin-panel/app/(dashboard)/dashboard/notifications/templates/page.tsx):\n   - List all templates: Name, Category, Usage count, Last updated\n   - Create/Edit template form:\n     * Template name (internal)\n     * Category\n     * Title (supports variables: {{userName}}, {{goalProgress}}, etc.)\n     * Body (supports variables)\n     * Default data payload (JSON)\n     * Action buttons configuration (iOS)\n   - Variable interpolation preview\n   - Delete template (only if not used in any campaigns)\n\n7. Template variable system:\n   - Supported variables: {{userName}}, {{goalCalories}}, {{currentWeight}}, {{goalWeight}}, {{streakDays}}, {{weeklyProgress}}, {{metricName}}, {{metricValue}}\n   - Backend service: interpolateTemplate(template, userData)\n   - Validation: Ensure all variables are valid before saving\n\n8. Backend models (add to schema.prisma):\n   - NotificationTemplate model:\n     * id, name, category, title, body, dataPayload (Json), variables (String[]), createdAt, updatedAt\n     * Index: [category]\n   - NotificationPreferenceOverride model (optional):\n     * id, userId, overriddenBy (adminUserId), reason, settings (Json), createdAt, expiresAt\n\n9. Backend API endpoints (server/src/routes/adminNotificationRoutes.ts):\n   - POST /api/admin/notifications/send-to-user - Send to specific user\n   - GET /api/admin/notifications/users/:userId/history - User's notification history\n   - GET /api/admin/notifications/users/:userId/devices - User's device tokens\n   - DELETE /api/admin/notifications/users/:userId/devices/:tokenId - Revoke token\n   - PUT /api/admin/notifications/users/:userId/preferences/override - Override preferences\n   - GET /api/admin/notifications/templates - List templates\n   - POST /api/admin/notifications/templates - Create template\n   - PUT /api/admin/notifications/templates/:id - Update template\n   - DELETE /api/admin/notifications/templates/:id - Delete template\n   - GET /api/admin/notifications/templates/:id/preview - Preview with sample data\n\n10. Backend service (server/src/services/adminNotificationService.ts):\n    - sendToUser(userId, notification, adminUserId): Send and log admin action\n    - getUserNotificationHistory(userId, pagination): Get NotificationLog with pagination\n    - getUserDeviceTokens(userId): Get active device tokens\n    - overrideUserPreferences(userId, settings, reason, adminUserId): Update and log\n    - Template CRUD operations\n    - interpolateTemplate(template, userData): Replace variables with user data\n\n11. Audit logging:\n    - Log all admin actions in AdminAuditLog:\n      * SEND_NOTIFICATION_TO_USER\n      * OVERRIDE_NOTIFICATION_PREFERENCES\n      * REVOKE_DEVICE_TOKEN\n      * CREATE_NOTIFICATION_TEMPLATE\n    - Include userId, templateId, reason in details (Json)\n\n12. Multi-language support (preparation):\n    - Add locale field to NotificationTemplate\n    - Support template variants by language\n    - Fallback to default language if user's language not available\n    - Add TODO for full i18n implementation\n\n13. UI components:\n    - Template editor with syntax highlighting for variables\n    - Variable picker dropdown\n    - Real-time preview with sample data\n    - Confirmation modals for destructive actions\n    - Success/error toasts\n\n14. Security:\n    - Require SUPER_ADMIN or SUPPORT role for sending to individual users\n    - Require SUPER_ADMIN for preference overrides\n    - Rate limit individual sends (max 10 per hour per admin)\n    - Audit log all actions with reason field\n\n15. Data retention (GDPR compliance):\n    - Document data retention policy for NotificationLog\n    - Add script to delete notification logs older than 90 days\n    - Exclude from deletion: Audit logs, campaign analytics\n    - Add TODO for automated cleanup job",
            "status": "pending",
            "testStrategy": "1. Test sending notification to specific user\n2. Test template CRUD operations\n3. Test variable interpolation with user data\n4. Test preference override and audit logging\n5. Test device token revocation\n6. Test notification history pagination and filtering\n7. Test template preview with sample data\n8. Test multi-language fallback logic\n9. Test admin role permissions enforcement\n10. Integration test: Create template, send to user, verify delivery, check audit log",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-26T11:45:36.172Z"
      },
      {
        "id": 41,
        "title": "Email Marketing System with Admin Content Management",
        "description": "Implement a comprehensive email marketing and transactional email system with full admin panel content management. Includes rich HTML email editor, template library, campaign scheduling, audience segmentation, automated email sequences (drip campaigns), analytics tracking, and user email preference management. Follow 2025 email deliverability best practices including authentication (DKIM/SPF/DMARC), one-click unsubscribe (RFC 8058), Apple Mail Privacy Protection awareness, and GDPR/CAN-SPAM compliance.",
        "details": "## Technical Architecture\n\n### Email Service Provider Integration\n\n1. **Provider Selection**\n   - Primary: Resend (modern API, excellent DX, React Email support)\n   - Alternative: SendGrid or Postmark for enterprise needs\n   - Separate sending domains: \n     * mail.nutriapp.com (transactional)\n     * marketing.nutriapp.com (campaigns)\n   - Dedicated IP consideration for high volume (>100k/month)\n\n2. **Authentication Setup**\n   - DKIM: Domain key signing for email authenticity\n   - SPF: Authorized sender IP records\n   - DMARC: Policy for failed authentication handling\n   - BIMI: Brand logo in email clients (future enhancement)\n\n3. **Webhook Integration**\n   - Bounce handling (hard/soft bounces)\n   - Complaint handling (spam reports)\n   - Delivery confirmations\n   - Open tracking (with privacy caveats)\n   - Click tracking\n   - Unsubscribe events\n\n### Email Types & Categories\n\n1. **Transactional Emails (always delivered)**\n   - Welcome email (after signup)\n   - Email verification\n   - Password reset\n   - Password changed confirmation\n   - Subscription confirmation/changes\n   - Payment receipts (if applicable)\n   - Account security alerts\n   - Goal achievement celebrations\n   - Weekly/monthly progress reports (user-triggered)\n\n2. **Marketing Emails (opt-in required)**\n   - Feature announcements\n   - Tips and educational content\n   - Recipe suggestions based on goals\n   - Health insights digest\n   - Re-engagement campaigns\n   - Promotional offers\n   - Newsletter\n\n3. **Automated Sequences (Drip Campaigns)**\n   - Onboarding sequence (Days 1, 3, 7, 14)\n   - First meal logged celebration\n   - 7-day streak achievement\n   - Dormant user re-engagement (7, 14, 30 days inactive)\n   - Goal milestone celebrations\n   - Subscription renewal reminders\n\n### Backend Architecture\n\n1. **Database Schema (Prisma)**\n   - EmailTemplate model: id, name, slug, category, subject, mjmlContent, htmlContent, variables, version, isActive\n   - EmailCampaign model: id, name, templateId, segment, scheduledAt, sentAt, status, analytics\n   - EmailLog model: id, userId, templateSlug, campaignId, status, sentAt, deliveredAt, openedAt, clickedAt, bouncedAt, unsubscribedAt\n   - EmailPreference model: userId, categories (Json), frequency, unsubscribedAt, doubleOptInAt\n   - EmailSequence model: id, name, triggerEvent, steps (Json array of delays and templateIds)\n   - EmailSequenceEnrollment model: userId, sequenceId, currentStep, startedAt, completedAt\n\n2. **Email Service (server/src/services/emailService.ts)**\n   - sendTransactional(userId, templateSlug, variables): Send transactional email\n   - sendMarketing(userIds, campaignId): Send marketing campaign\n   - sendBatch(emails[]): Batch sending with rate limiting\n   - renderTemplate(templateSlug, variables): Render MJML to HTML\n   - trackEvent(emailId, event): Handle webhook events\n   - validateEmail(email): Check deliverability\n\n3. **Queue System (Bull/BullMQ)**\n   - emailQueue: Process email sends with retries\n   - campaignQueue: Handle large campaign sends in batches\n   - sequenceQueue: Process drip campaign steps\n   - Rate limiting: 100 emails/second default\n   - Retry strategy: Exponential backoff, max 3 retries\n\n4. **API Endpoints**\n   User-facing:\n   - GET /api/email/preferences - Get user email preferences\n   - PUT /api/email/preferences - Update preferences\n   - POST /api/email/unsubscribe - One-click unsubscribe\n   - GET /api/email/unsubscribe/:token - Unsubscribe page\n\n   Admin:\n   - Full CRUD for templates, campaigns, sequences\n   - Analytics endpoints\n   - Subscriber management\n\n### Admin Panel Features\n\n1. **Email Template Editor**\n   - MJML-based editor (compiles to responsive HTML)\n   - React Email components for developer templates\n   - Visual drag-and-drop builder option (unlayer.com or similar)\n   - Variable system: {{userName}}, {{goalProgress}}, {{weeklyCalories}}, etc.\n   - Conditional blocks: {{#if isPremium}}...{{/if}}\n   - Dynamic content based on user data\n   - Version history with rollback\n   - Template categories and organization\n\n2. **Template Preview & Testing**\n   - Desktop/mobile/dark mode preview\n   - Send test email to admin\n   - Spam score check (mail-tester integration)\n   - Render with sample user data\n   - Preview across email clients (Litmus/Email on Acid integration - optional)\n\n3. **Campaign Management**\n   - Create campaign from template\n   - Audience segmentation:\n     * Activity level (active, dormant, churned)\n     * Subscription tier\n     * Goal type\n     * Signup date range\n     * Custom filters (SQL for admins)\n   - Schedule send time with timezone handling\n   - A/B testing:\n     * Subject line variants\n     * Content variants\n     * Send time variants\n     * Statistical significance calculator\n   - Estimated audience size preview\n\n4. **Automated Sequences Builder**\n   - Visual sequence builder (node-based flow)\n   - Trigger events: signup, meal_logged, goal_achieved, subscription_changed, inactivity\n   - Steps: Wait (delay), Send Email, Check Condition, Branch\n   - Entry conditions and exit conditions\n   - Enrollment management (pause, resume, remove users)\n   - Performance analytics per step\n\n5. **Analytics Dashboard**\n   - Campaign metrics: Sent, Delivered, Opened, Clicked, Bounced, Unsubscribed\n   - Open rate with Apple MPP caveat (machine opens flagged)\n   - Click heatmaps (which links clicked most)\n   - Conversion tracking (email → app action)\n   - Time-series trends\n   - Comparative analysis (this campaign vs average)\n   - Best performing subject lines\n   - Optimal send time analysis\n\n6. **Subscriber Management**\n   - Subscriber list with search and filters\n   - Individual subscriber view: Preference, history, engagement score\n   - Bulk import/export (CSV)\n   - Suppression list management (bounces, complaints, unsubscribes)\n   - Re-engagement targeting\n   - List hygiene tools (identify inactive subscribers)\n\n7. **Deliverability Monitoring**\n   - Bounce rate tracking\n   - Complaint rate tracking (stay below 0.1%)\n   - Domain reputation indicators\n   - Authentication status (DKIM/SPF/DMARC)\n   - Blocklist monitoring integration (optional)\n\n### Mobile App Integration\n\n1. **Email Preferences Screen**\n   - Category toggles:\n     * Weekly Progress Reports\n     * Health Insights\n     * Tips & Recipes\n     * Feature Updates\n     * Promotional Offers\n   - Frequency control: Real-time, Daily digest, Weekly digest\n   - Unsubscribe all marketing (keep transactional)\n   - Update email address\n\n2. **Onboarding Email Opt-in**\n   - During signup or shortly after\n   - Explain email benefits\n   - Pre-select recommended categories\n   - GDPR: Explicit consent checkbox for marketing\n\n3. **In-App Email Preview**\n   - Show recent emails in notification center\n   - Link to web version of email\n   - Quick unsubscribe from specific category\n\n### Compliance & Privacy\n\n1. **GDPR Compliance**\n   - Explicit opt-in for marketing emails\n   - Double opt-in option (confirmation email)\n   - Easy preference management\n   - Complete unsubscribe option\n   - Data export includes email preferences\n   - Right to erasure includes email logs\n\n2. **CAN-SPAM Compliance**\n   - Physical address in email footer\n   - Clear sender identification\n   - Honest subject lines\n   - Unsubscribe link in every email\n   - Honor unsubscribes within 10 days\n\n3. **One-Click Unsubscribe (RFC 8058)**\n   - List-Unsubscribe-Post header\n   - Immediate processing of unsubscribe\n   - No login required\n   - Confirmation page (not confirmation email)\n\n4. **Apple Mail Privacy Protection**\n   - Detect Apple proxy opens\n   - Don't rely solely on open rates\n   - Focus on click tracking for engagement\n   - Document in analytics with caveat\n\n### Email Design System\n\n1. **Brand Consistency**\n   - Nutri color palette in email templates\n   - Logo and visual assets\n   - Typography matching app design\n   - Consistent CTA button styles\n\n2. **Responsive Design**\n   - Mobile-first templates\n   - Fluid layouts\n   - Touch-friendly buttons (44px min)\n   - Dark mode support (@media prefers-color-scheme)\n\n3. **Accessibility**\n   - Alt text for images\n   - Sufficient color contrast\n   - Semantic HTML structure\n   - Screen reader friendly\n\n### Environment Variables\n\n```env\n# Email Provider (Resend)\nRESEND_API_KEY=re_xxxxx\nRESEND_WEBHOOK_SECRET=whsec_xxxxx\nEMAIL_FROM_TRANSACTIONAL=Nutri <hello@mail.nutriapp.com>\nEMAIL_FROM_MARKETING=Nutri <updates@marketing.nutriapp.com>\nEMAIL_REPLY_TO=support@nutriapp.com\n\n# Domain Configuration\nEMAIL_DOMAIN_TRANSACTIONAL=mail.nutriapp.com\nEMAIL_DOMAIN_MARKETING=marketing.nutriapp.com\n\n# Rate Limiting\nEMAIL_RATE_LIMIT_PER_SECOND=100\nEMAIL_BATCH_SIZE=1000\n\n# Optional Integrations\nLITMUS_API_KEY=xxxxx  # Email client testing\nMAIL_TESTER_API_KEY=xxxxx  # Spam score\n```\n\n### Dependencies\n\n- resend (or @sendgrid/mail)\n- mjml (email templating)\n- react-email (React components for emails)\n- bull (job queue - already in stack)\n- handlebars or mustache (variable interpolation)\n- unlayer-react (optional drag-and-drop builder)\n\n### Security Considerations\n\n- Validate all template variables server-side\n- Sanitize user-generated content in emails\n- Rate limit email sending per user\n- Secure webhook endpoints with signature verification\n- Encrypt sensitive tokens in unsubscribe links\n- Audit log all template changes",
        "testStrategy": "## Testing Strategy\n\n### Unit Tests\n- Template rendering with variables\n- MJML to HTML compilation\n- Email validation\n- Unsubscribe token generation/verification\n- Segment filter logic\n- Sequence step progression\n\n### Integration Tests\n- End-to-end email sending (use test mode/sandbox)\n- Webhook event processing\n- Campaign scheduling and execution\n- Sequence enrollment and progression\n- Preference update sync\n\n### E2E Tests\n- Email preference screen interactions\n- Unsubscribe flow (web page)\n- Admin template editor save/preview\n- Campaign creation and scheduling\n\n### Deliverability Testing\n- SPF/DKIM/DMARC verification\n- Spam score testing (mail-tester.com)\n- Inbox placement testing (optional Litmus integration)\n\n### Load Testing\n- Batch sending performance (10k+ emails)\n- Queue processing under load\n- Webhook handling at scale\n\n### Manual Testing\n- Email rendering across clients (Gmail, Outlook, Apple Mail)\n- Dark mode rendering\n- Mobile responsiveness\n- Accessibility audit",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement email database schema in Prisma",
            "description": "Create Prisma models for EmailTemplate, EmailCampaign, EmailLog, EmailPreference, EmailSequence, and EmailSequenceEnrollment to support the complete email marketing system",
            "dependencies": [],
            "details": "Add to server/prisma/schema.prisma:\n\n1. EmailTemplate model:\n   - id, name, slug (unique), category (enum: TRANSACTIONAL, MARKETING)\n   - subject, mjmlContent, htmlContent, plainTextContent\n   - variables (Json array of variable names)\n   - version (Int), isActive (Boolean)\n   - createdBy, updatedBy (reference to AdminUser)\n   - timestamps\n   - @@index on [slug], [category, isActive]\n\n2. EmailCampaign model:\n   - id, name, description\n   - templateId (reference to EmailTemplate)\n   - segmentCriteria (Json - targeting rules)\n   - scheduledAt, sentAt, completedAt\n   - status (enum: DRAFT, SCHEDULED, SENDING, SENT, CANCELLED)\n   - abTestConfig (Json - subject variants, content variants)\n   - estimatedAudience (Int), actualSent (Int)\n   - createdBy (AdminUser reference)\n   - timestamps\n   - @@index on [status, scheduledAt]\n\n3. EmailLog model:\n   - id, userId, email\n   - templateSlug, campaignId (optional)\n   - status (enum: QUEUED, SENDING, SENT, DELIVERED, OPENED, CLICKED, BOUNCED, COMPLAINED, UNSUBSCRIBED)\n   - metadata (Json - provider message ID, error details)\n   - sentAt, deliveredAt, openedAt, clickedAt, bouncedAt, unsubscribedAt\n   - isAppleProxyOpen (Boolean - for MPP detection)\n   - clickData (Json array - URLs clicked)\n   - bounceType (String - hard/soft)\n   - timestamps\n   - @@index on [userId, createdAt], [campaignId, status], [templateSlug]\n   - @@unique on [userId, templateSlug, campaignId, sentAt] for deduplication\n\n4. EmailPreference model:\n   - id, userId (unique)\n   - categories (Json - {weekly_reports: true, health_insights: true, tips: true, features: true, promotions: false})\n   - frequency (enum: REALTIME, DAILY_DIGEST, WEEKLY_DIGEST)\n   - marketingOptIn (Boolean)\n   - doubleOptInConfirmedAt (DateTime)\n   - globalUnsubscribedAt (DateTime)\n   - unsubscribeToken (String, unique, indexed)\n   - timestamps\n   - @@index on [userId], [unsubscribeToken]\n\n5. EmailSequence model:\n   - id, name, description\n   - triggerEvent (enum: SIGNUP, FIRST_MEAL, GOAL_ACHIEVED, SUBSCRIPTION_CHANGED, INACTIVITY_7D, INACTIVITY_14D, INACTIVITY_30D)\n   - isActive (Boolean)\n   - steps (Json array - [{stepNumber: 1, delayHours: 0, templateId: \"...\", condition: {...}}])\n   - enrollmentCriteria (Json - who can enter this sequence)\n   - exitCriteria (Json - when to stop sequence)\n   - totalEnrollments (Int), activeEnrollments (Int), completedEnrollments (Int)\n   - createdBy (AdminUser reference)\n   - timestamps\n   - @@index on [triggerEvent, isActive]\n\n6. EmailSequenceEnrollment model:\n   - id, userId, sequenceId\n   - currentStep (Int - which step they're on)\n   - status (enum: ACTIVE, PAUSED, COMPLETED, EXITED)\n   - startedAt, pausedAt, completedAt, exitedAt\n   - exitReason (String - why they exited early)\n   - metadata (Json - tracking data)\n   - nextStepScheduledAt (DateTime)\n   - timestamps\n   - @@index on [userId, status], [sequenceId, status], [nextStepScheduledAt]\n   - @@unique on [userId, sequenceId] - user can only be enrolled once\n\n7. Create enums:\n   - EmailCategory: TRANSACTIONAL, MARKETING\n   - EmailCampaignStatus: DRAFT, SCHEDULED, SENDING, SENT, CANCELLED\n   - EmailLogStatus: QUEUED, SENDING, SENT, DELIVERED, OPENED, CLICKED, BOUNCED, COMPLAINED, UNSUBSCRIBED\n   - EmailFrequency: REALTIME, DAILY_DIGEST, WEEKLY_DIGEST\n   - EmailSequenceTrigger: SIGNUP, FIRST_MEAL, GOAL_ACHIEVED, SUBSCRIPTION_CHANGED, INACTIVITY_7D, INACTIVITY_14D, INACTIVITY_30D\n   - EmailSequenceStatus: ACTIVE, PAUSED, COMPLETED, EXITED\n\n8. After schema changes:\n   - Run `npm run db:generate`\n   - Run `npm run db:push` (dev) or create migration\n   - Verify schema in Prisma Studio",
            "status": "pending",
            "testStrategy": "1. Verify Prisma client generation succeeds\n2. Test database push/migration creates all tables and indexes\n3. Verify unique constraints (slug, unsubscribeToken, userId+sequenceId)\n4. Test cascade deletes (user deletion should cascade to EmailLog, EmailPreference, EmailSequenceEnrollment)\n5. Verify enum values are correctly defined\n6. Test complex queries (find users in active sequences, get campaign analytics)\n7. Check index performance for common queries (userId lookups, campaign status filters)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate email service provider (Resend) with authentication setup",
            "description": "Set up Resend SDK integration with proper API key management, webhook signature verification, and email domain configuration for both transactional and marketing emails",
            "dependencies": [
              1
            ],
            "details": "1. Install dependencies in server/:\n   ```bash\n   npm install resend @types/node\n   ```\n\n2. Update server/.env with email configuration:\n   ```env\n   # Resend Configuration\n   RESEND_API_KEY=re_xxxxx\n   RESEND_WEBHOOK_SECRET=whsec_xxxxx\n   EMAIL_FROM_TRANSACTIONAL=Nutri <hello@mail.nutriapp.com>\n   EMAIL_FROM_MARKETING=Nutri <updates@marketing.nutriapp.com>\n   EMAIL_REPLY_TO=support@nutriapp.com\n   EMAIL_DOMAIN_TRANSACTIONAL=mail.nutriapp.com\n   EMAIL_DOMAIN_MARKETING=marketing.nutriapp.com\n   ```\n\n3. Update server/src/config/env.ts:\n   - Add email configuration to config object\n   - Validate required env vars (RESEND_API_KEY, EMAIL_FROM_TRANSACTIONAL)\n\n4. Create server/src/config/resend.ts:\n   ```typescript\n   import { Resend } from 'resend';\n   import { config } from './env';\n\n   export const resend = new Resend(config.email.resendApiKey);\n\n   export const EMAIL_CONFIG = {\n     from: {\n       transactional: config.email.fromTransactional,\n       marketing: config.email.fromMarketing,\n     },\n     replyTo: config.email.replyTo,\n     domains: {\n       transactional: config.email.domainTransactional,\n       marketing: config.email.domainMarketing,\n     },\n   };\n   ```\n\n5. Domain authentication setup (documentation/manual steps):\n   - Add DNS records for DKIM, SPF, DMARC for both domains\n   - Verify domains in Resend dashboard\n   - Configure return-path for bounce handling\n   - Set up BIMI record (optional, future enhancement)\n\n6. Create server/src/utils/emailHelpers.ts:\n   - generateUnsubscribeToken(userId): Create secure token\n   - verifyUnsubscribeToken(token): Verify and decode token\n   - validateEmailDeliverability(email): Basic email validation\n   - generateListUnsubscribeHeader(userId, campaignId): RFC 8058 headers\n\n7. Create webhook signature verification utility:\n   - verifyResendWebhookSignature(payload, signature, secret): boolean\n\n8. Error handling:\n   - Wrap Resend calls with try/catch\n   - Log all API errors with correlation IDs\n   - Handle rate limiting (429 responses)\n   - Implement exponential backoff for retries",
            "status": "pending",
            "testStrategy": "1. Test Resend SDK initialization with valid/invalid API keys\n2. Send test email to verify domain authentication\n3. Test DKIM/SPF/DMARC validation with mail-tester.com\n4. Verify webhook signature validation with sample payloads\n5. Test unsubscribe token generation and verification\n6. Test email validation utility with valid/invalid emails\n7. Test List-Unsubscribe header generation\n8. Verify error handling for API failures and rate limiting",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement backend email service with Bull queue-based sending",
            "description": "Create a centralized email service that uses Bull/BullMQ for queue-based email sending with retry logic, rate limiting, batch processing, and template rendering",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Install dependencies in server/:\n   ```bash\n   npm install bull @types/bull ioredis @types/ioredis mjml handlebars\n   ```\n\n2. Update server/.env:\n   ```env\n   REDIS_URL=redis://localhost:6379\n   EMAIL_RATE_LIMIT_PER_SECOND=100\n   EMAIL_BATCH_SIZE=1000\n   EMAIL_QUEUE_CONCURRENCY=10\n   ```\n\n3. Create server/src/queues/emailQueue.ts:\n   - Initialize Bull queue connected to Redis\n   - Configure retry strategy: exponential backoff, max 3 retries\n   - Rate limiting: 100 emails/second (configurable)\n   - Job types: TRANSACTIONAL, CAMPAIGN_BATCH, SEQUENCE_STEP\n   - Job data interface: { userId?, email, templateSlug, variables, campaignId?, sequenceId? }\n   - Process handler: calls emailService.sendEmail()\n   - Event handlers: completed, failed, stalled\n\n4. Create server/src/services/emailService.ts:\n   Main methods:\n   - sendTransactional(userId: string, templateSlug: string, variables: Record<string, any>): Promise<void>\n     * Look up user email and preferences\n     * Check if unsubscribed (skip if marketing category)\n     * Render template with variables\n     * Queue email job\n     * Create EmailLog entry with status QUEUED\n   \n   - sendMarketing(userIds: string[], campaignId: string): Promise<void>\n     * Filter out unsubscribed users\n     * Check email preferences (opt-in, categories)\n     * Batch users into chunks (EMAIL_BATCH_SIZE)\n     * Queue batch jobs\n     * Update EmailCampaign status to SENDING\n   \n   - sendBatch(emails: Array<{userId, email, templateSlug, variables, campaignId?}>): Promise<void>\n     * Send batch via Resend batch API\n     * Create EmailLog entries for each\n     * Handle partial failures\n   \n   - renderTemplate(templateSlug: string, variables: Record<string, any>): Promise<{html: string, plainText: string, subject: string}>\n     * Fetch EmailTemplate from database\n     * Compile MJML to HTML (mjml2html)\n     * Interpolate variables with Handlebars\n     * Generate plain text version (html-to-text)\n     * Return compiled template\n   \n   - processSequenceStep(enrollmentId: string): Promise<void>\n     * Get enrollment and current step\n     * Send email for current step\n     * Increment step or mark completed\n     * Schedule next step if exists\n   \n   - trackEvent(emailLogId: string, event: EmailLogStatus, metadata?: any): Promise<void>\n     * Update EmailLog status and timestamp\n     * Handle bounce detection (hard/soft)\n     * Process unsubscribe events\n     * Detect Apple Mail Privacy Protection opens\n\n5. Template variable interpolation:\n   - Use Handlebars for variable substitution: {{userName}}, {{goalProgress}}\n   - Conditional blocks: {{#if isPremium}}...{{/if}}\n   - Helpers: formatDate, formatNumber, formatCurrency\n   - Sanitize user-generated content (escape HTML)\n\n6. Error handling:\n   - Catch Resend API errors\n   - Log failures with correlation ID\n   - Update EmailLog with error details\n   - Implement circuit breaker for Resend outages\n\n7. Queue monitoring:\n   - Expose queue stats endpoint for admin panel\n   - Track: pending jobs, active jobs, failed jobs, completed jobs\n   - Alert on high failure rate\n\n8. One-click unsubscribe:\n   - Add List-Unsubscribe and List-Unsubscribe-Post headers (RFC 8058)\n   - Immediate unsubscribe on POST to unsubscribe endpoint",
            "status": "pending",
            "testStrategy": "1. Unit test template rendering with variables and conditionals\n2. Unit test MJML compilation to HTML\n3. Test queue job creation and processing\n4. Test retry logic with simulated failures\n5. Test rate limiting: verify 100 emails/second limit\n6. Test batch sending with 1000+ users\n7. Test unsubscribed user filtering\n8. Test email preference checking\n9. Test sequence step progression\n10. Integration test: send test email through full pipeline\n11. Test circuit breaker during Resend outage\n12. Verify EmailLog creation and updates",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement backend webhook handler for email events",
            "description": "Create webhook endpoint to receive and process email events from Resend (bounces, opens, clicks, unsubscribes, deliveries) with signature verification and proper event logging",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. Create server/src/controllers/emailWebhookController.ts:\n   - handleResendWebhook(req, res): Main webhook handler\n   - Verify webhook signature using RESEND_WEBHOOK_SECRET\n   - Parse event payload\n   - Route to appropriate event handler\n   - Return 200 OK immediately (process async)\n   - Log all webhook events for debugging\n\n2. Event handlers in emailWebhookController:\n   - handleDelivered(event): Update EmailLog status to DELIVERED, set deliveredAt\n   - handleBounce(event): Update status to BOUNCED, set bouncedAt, bounceType (hard/soft), bounceReason\n     * Hard bounce: Add email to suppression list, mark user preference\n     * Soft bounce: Increment retry counter\n   - handleOpen(event): Update status to OPENED, set openedAt\n     * Detect Apple Mail Privacy Protection (check user agent)\n     * Set isAppleProxyOpen flag if detected\n   - handleClick(event): Update status to CLICKED, set clickedAt\n     * Append clicked URL to clickData array\n     * Track link performance\n   - handleComplaint(event): Update status to COMPLAINED\n     * Auto-unsubscribe user from all marketing\n     * Flag account for review\n   - handleUnsubscribe(event): Update status to UNSUBSCRIBED, set unsubscribedAt\n     * Update EmailPreference: set globalUnsubscribedAt\n     * Remove from active sequences\n\n3. Create route in server/src/routes/emailWebhookRoutes.ts:\n   - POST /api/webhooks/email/resend\n   - No authentication (uses signature verification)\n   - Rate limiting: 1000 requests/minute\n   - Request logging with correlation ID\n\n4. Suppression list management:\n   - Track bounced emails in EmailPreference\n   - Prevent sending to hard bounced addresses\n   - Daily cleanup job for old soft bounces\n\n5. Apple Mail Privacy Protection handling:\n   - Detect proxy opens from Apple's IP ranges\n   - Set isAppleProxyOpen = true in EmailLog\n   - Don't count as genuine engagement\n   - Display caveat in analytics dashboard\n\n6. Analytics aggregation:\n   - Update EmailCampaign analytics on each event\n   - Increment counters: delivered, opened, clicked, bounced, unsubscribed\n   - Calculate rates: open rate, click rate, bounce rate\n   - Store in campaign metadata for fast access\n\n7. Error handling:\n   - Catch database errors\n   - Log invalid webhook payloads\n   - Handle missing EmailLog entries gracefully\n   - Implement idempotency (duplicate webhook prevention)\n\n8. Security:\n   - Always verify webhook signature\n   - Reject unsigned requests with 401\n   - Rate limit webhook endpoint\n   - Sanitize all incoming data\n\n9. Monitoring:\n   - Track webhook processing latency\n   - Alert on high bounce rate (>5%)\n   - Alert on high complaint rate (>0.1%)\n   - Dashboard for webhook event volume",
            "status": "pending",
            "testStrategy": "1. Test signature verification with valid/invalid signatures\n2. Test each event type handler (delivered, bounce, open, click, complaint, unsubscribe)\n3. Test hard bounce suppression list updates\n4. Test Apple Mail Privacy Protection detection\n5. Test campaign analytics aggregation\n6. Test idempotency with duplicate webhook events\n7. Test error handling for malformed payloads\n8. Integration test: simulate full email lifecycle (sent → delivered → opened → clicked)\n9. Test rate limiting on webhook endpoint\n10. Verify EmailLog updates for each event type",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create backend API endpoints for user email preferences",
            "description": "Implement user-facing API endpoints for managing email preferences, including opt-in/opt-out, frequency settings, category preferences, and one-click unsubscribe",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. Create Zod schemas in server/src/validation/schemas.ts:\n   - emailPreferencesUpdateSchema:\n     * categories: object with boolean fields (weekly_reports, health_insights, tips, features, promotions)\n     * frequency: enum (REALTIME, DAILY_DIGEST, WEEKLY_DIGEST)\n     * marketingOptIn: boolean\n   - emailUnsubscribeSchema:\n     * token: string (for one-click unsubscribe)\n     * categories: optional array of strings (selective unsubscribe)\n\n2. Create server/src/services/emailPreferenceService.ts:\n   - getPreferences(userId: string): Get or create user email preferences\n   - updatePreferences(userId: string, data: UpdatePreferencesInput): Update preferences\n   - doubleOptIn(userId: string): Send double opt-in confirmation email, update doubleOptInConfirmedAt on confirmation\n   - unsubscribeAll(userId: string): Set globalUnsubscribedAt, exit all active sequences\n   - unsubscribeCategory(userId: string, category: string): Disable specific category\n   - unsubscribeByToken(token: string): One-click unsubscribe, verify token, update preferences\n   - resubscribe(userId: string): Clear globalUnsubscribedAt, restore previous preferences\n\n3. Create server/src/controllers/emailPreferenceController.ts:\n   - getPreferences(req, res): GET /api/email/preferences\n     * Requires authentication\n     * Returns EmailPreference for current user\n     * Creates default preferences if none exist\n   \n   - updatePreferences(req, res): PUT /api/email/preferences\n     * Validate input with Zod schema\n     * Update preferences\n     * Return updated preferences\n   \n   - requestDoubleOptIn(req, res): POST /api/email/opt-in\n     * Send double opt-in confirmation email\n     * Return success message\n   \n   - confirmDoubleOptIn(req, res): GET /api/email/opt-in/confirm?token=xxx\n     * Verify token\n     * Update doubleOptInConfirmedAt\n     * Redirect to success page\n   \n   - unsubscribeAll(req, res): POST /api/email/unsubscribe\n     * Requires authentication OR valid token\n     * Unsubscribe user from all marketing\n     * Return success message\n   \n   - unsubscribePage(req, res): GET /api/email/unsubscribe/:token\n     * Display unsubscribe confirmation page (HTML)\n     * Show unsubscribe options (all marketing, specific categories)\n     * Form submits to POST /api/email/unsubscribe\n   \n   - oneClickUnsubscribe(req, res): POST /api/email/unsubscribe/one-click\n     * RFC 8058 compliant\n     * Verify List-Unsubscribe-Post header\n     * Process unsubscribe immediately\n     * Return 200 OK (no body)\n\n4. Create routes in server/src/routes/emailPreferenceRoutes.ts:\n   - GET /api/email/preferences (authenticated)\n   - PUT /api/email/preferences (authenticated)\n   - POST /api/email/opt-in (authenticated)\n   - GET /api/email/opt-in/confirm (public, requires token)\n   - POST /api/email/unsubscribe (public with token or authenticated)\n   - GET /api/email/unsubscribe/:token (public)\n   - POST /api/email/unsubscribe/one-click (public, RFC 8058)\n\n5. Default preferences:\n   - On user signup: Create EmailPreference with default settings\n   - Default to marketingOptIn = false (GDPR compliant)\n   - Transactional emails always enabled (can't be disabled)\n\n6. Security:\n   - Unsubscribe tokens: Signed JWT with userId and expiry (7 days)\n   - Rate limiting on unsubscribe endpoints (prevent abuse)\n   - Validate all inputs with Zod\n   - Sanitize user input\n\n7. GDPR compliance:\n   - Explicit opt-in for marketing emails\n   - Double opt-in option (recommended)\n   - Easy unsubscribe mechanism\n   - Clear preference management\n   - Data export includes email preferences\n   - Right to erasure deletes all email logs\n\n8. CAN-SPAM compliance:\n   - Physical address in all marketing emails\n   - Unsubscribe link in every email\n   - Honor unsubscribes within 10 days (immediate in our case)\n   - No false/misleading header information",
            "status": "pending",
            "testStrategy": "1. Test getPreferences creates default preferences if none exist\n2. Test updatePreferences validates input and updates database\n3. Test double opt-in flow: request → email sent → confirmation → doubleOptInConfirmedAt updated\n4. Test unsubscribeAll sets globalUnsubscribedAt and exits sequences\n5. Test category-specific unsubscribe\n6. Test one-click unsubscribe (RFC 8058)\n7. Test unsubscribe token generation and verification\n8. Test resubscribe flow\n9. Test authentication middleware on protected endpoints\n10. Test rate limiting on unsubscribe endpoints\n11. Verify Zod schema validation with invalid inputs\n12. Integration test: full preference update lifecycle",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create backend admin API endpoints for email management",
            "description": "Implement admin-only API endpoints for managing email templates, campaigns, sequences, analytics, and subscribers with role-based access control",
            "dependencies": [
              1,
              2,
              3,
              5
            ],
            "details": "1. Create Zod schemas in server/src/validation/adminSchemas.ts (if not exists, create it):\n   - emailTemplateCreateSchema: name, slug, category, subject, mjmlContent, variables\n   - emailTemplateUpdateSchema: partial of create schema\n   - emailCampaignCreateSchema: name, templateId, segmentCriteria, scheduledAt, abTestConfig\n   - emailCampaignUpdateSchema: partial of create schema\n   - emailSequenceCreateSchema: name, triggerEvent, steps, enrollmentCriteria, exitCriteria\n   - emailSequenceUpdateSchema: partial of create schema\n   - emailAnalyticsQuerySchema: campaignId, startDate, endDate, groupBy\n\n2. Create server/src/services/adminEmailService.ts:\n   Template methods:\n   - listTemplates(filters, pagination): List all templates with filtering\n   - getTemplate(id): Get single template\n   - createTemplate(data, adminUserId): Create new template, compile MJML, create version 1\n   - updateTemplate(id, data, adminUserId): Update template, increment version, recompile MJML\n   - deleteTemplate(id, adminUserId): Soft delete (set isActive=false), audit log\n   - duplicateTemplate(id, newName, adminUserId): Copy template as new version\n   - testTemplate(id, testEmail, sampleData): Send test email with sample variables\n   \n   Campaign methods:\n   - listCampaigns(filters, pagination): List campaigns\n   - getCampaign(id): Get campaign with analytics\n   - createCampaign(data, adminUserId): Create campaign in DRAFT status\n   - updateCampaign(id, data, adminUserId): Update draft campaign\n   - deleteCampaign(id, adminUserId): Delete draft campaign only\n   - scheduleCampaign(id, scheduledAt, adminUserId): Set status to SCHEDULED, schedule queue job\n   - cancelCampaign(id, adminUserId): Cancel scheduled campaign\n   - getAudienceSize(segmentCriteria): Calculate estimated audience size\n   - sendTestCampaign(id, testEmails, adminUserId): Send campaign to test emails\n   \n   Sequence methods:\n   - listSequences(filters, pagination): List sequences\n   - getSequence(id): Get sequence with analytics\n   - createSequence(data, adminUserId): Create sequence\n   - updateSequence(id, data, adminUserId): Update sequence (only if no active enrollments)\n   - deleteSequence(id, adminUserId): Delete sequence (only if no enrollments)\n   - activateSequence(id, adminUserId): Set isActive=true, enable triggers\n   - deactivateSequence(id, adminUserId): Set isActive=false, pause new enrollments\n   - getEnrollments(sequenceId, filters, pagination): List enrollments\n   - pauseEnrollment(enrollmentId, adminUserId): Pause individual enrollment\n   - resumeEnrollment(enrollmentId, adminUserId): Resume paused enrollment\n   - exitEnrollment(enrollmentId, reason, adminUserId): Exit user from sequence\n   \n   Analytics methods:\n   - getCampaignAnalytics(campaignId): Get detailed campaign stats\n   - getTemplatePerformance(templateId): Aggregate stats across all campaigns\n   - getOverviewStats(dateRange): High-level metrics (total sent, open rate, click rate, etc.)\n   - getEmailLogs(filters, pagination): Search/filter email logs\n   - exportAnalytics(query): Export analytics to CSV\n   \n   Subscriber methods:\n   - listSubscribers(filters, pagination): List all users with email preferences\n   - getSubscriber(userId): Get detailed subscriber info (preferences, logs, engagement)\n   - updateSubscriberPreferences(userId, data, adminUserId): Admin override of preferences\n   - suppressEmail(email, reason, adminUserId): Add to suppression list\n   - removeSuppress(email, adminUserId): Remove from suppression list\n   - importSubscribers(csvData, adminUserId): Bulk import (validate emails, create preferences)\n   - exportSubscribers(filters, adminUserId): Export to CSV\n\n3. Create server/src/controllers/adminEmailController.ts:\n   Organize endpoints by resource:\n   - Template endpoints: GET/POST/PUT/DELETE /api/admin/email/templates\n   - Campaign endpoints: GET/POST/PUT/DELETE /api/admin/email/campaigns\n   - Sequence endpoints: GET/POST/PUT/DELETE /api/admin/email/sequences\n   - Analytics endpoints: GET /api/admin/email/analytics/*\n   - Subscriber endpoints: GET/PUT /api/admin/email/subscribers\n   - Each endpoint validates input, calls service method, returns response\n   - Audit logging for all mutations\n\n4. Add routes to server/src/routes/admin.ts:\n   - All under /api/admin/email/*\n   - Require adminAuth middleware (SUPER_ADMIN or SUPPORT role)\n   - Require adminAudit middleware for all mutations\n   - Rate limiting: 1000 requests/hour per admin user\n\n5. RBAC permissions:\n   - SUPER_ADMIN: Full access to all endpoints\n   - SUPPORT: Read-only access to analytics, can update subscriber preferences\n   - ANALYST: Read-only access to analytics only\n   - VIEWER: Read-only access to templates and campaigns\n\n6. Audience segmentation logic:\n   - Support filters: activityLevel, subscriptionTier, goalType, signupDateRange, lastLoginDateRange\n   - SQL query builder for custom filters (admin only, sanitized)\n   - Preview audience size before sending\n   - Save segment as reusable template\n\n7. A/B testing:\n   - Subject line variants: split audience, track performance\n   - Content variants: different templates for same campaign\n   - Send time optimization: test different send times\n   - Statistical significance calculator: determine winner\n\n8. Error handling:\n   - Validate all inputs with Zod\n   - Return detailed error messages for admin debugging\n   - Log all errors with correlation ID\n   - Handle partial failures in bulk operations",
            "status": "pending",
            "testStrategy": "1. Test RBAC: verify each role has correct permissions\n2. Test template CRUD operations with MJML compilation\n3. Test template versioning (updates increment version)\n4. Test campaign creation and scheduling\n5. Test audience size calculation with various segment criteria\n6. Test A/B testing configuration and tracking\n7. Test sequence creation with multi-step flows\n8. Test sequence activation/deactivation\n9. Test enrollment management (pause, resume, exit)\n10. Test analytics aggregation accuracy\n11. Test subscriber import/export with CSV\n12. Test suppression list management\n13. Verify audit logging for all admin actions\n14. Integration test: full campaign lifecycle (create → schedule → send → analyze)",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Build admin panel MJML email template editor with variable support",
            "description": "Create React-based MJML editor in the Next.js admin panel with syntax highlighting, variable insertion, live preview, and template management UI",
            "dependencies": [
              1,
              2,
              6
            ],
            "details": "1. Install dependencies in admin-panel/:\n   ```bash\n   npm install @monaco-editor/react monaco-editor mjml-browser handlebars html-to-text\n   npm install @radix-ui/react-popover @radix-ui/react-switch @radix-ui/react-separator\n   ```\n\n2. Create admin-panel/app/(dashboard)/email/templates/page.tsx:\n   - List all email templates in table\n   - Columns: Name, Category, Subject, Status, Last Updated, Actions\n   - Filters: Category (Transactional/Marketing), Status (Active/Inactive)\n   - Search by name or slug\n   - Pagination (20 per page)\n   - Action buttons: Edit, Duplicate, Test, Delete\n   - \"Create Template\" button → navigate to /email/templates/new\n\n3. Create admin-panel/app/(dashboard)/email/templates/new/page.tsx:\n   - Template form fields:\n     * Name (text input)\n     * Slug (auto-generated from name, editable, validates uniqueness)\n     * Category (select: Transactional/Marketing)\n     * Subject (text input with variable picker)\n     * Description (textarea)\n   - MJML editor (Monaco Editor with MJML syntax)\n   - Variable picker sidebar:\n     * Common variables: {{userName}}, {{email}}, {{goalProgress}}, etc.\n     * Click to insert at cursor position\n     * Group by category (User, Goals, Nutrition, Health, App)\n   - Live preview panel (right side):\n     * Compile MJML to HTML on change (debounced 500ms)\n     * Render HTML in iframe\n     * Desktop/Mobile/Dark mode toggle\n     * Sample data for variables\n   - Error display:\n     * Show MJML compilation errors inline\n     * Highlight error line in editor\n   - Actions:\n     * Save Draft (create template with isActive=false)\n     * Save & Activate (create template with isActive=true)\n     * Send Test Email (modal to enter test email address)\n     * Cancel (navigate back)\n\n4. Create admin-panel/app/(dashboard)/email/templates/[id]/edit/page.tsx:\n   - Same UI as new template page\n   - Load existing template data\n   - Version history sidebar:\n     * Show all versions of template\n     * Preview previous versions\n     * Rollback to previous version (creates new version)\n   - Additional actions:\n     * Duplicate Template\n     * Deactivate/Activate\n     * Delete (soft delete)\n\n5. Create admin-panel/components/email/MJMLEditor.tsx:\n   - Monaco Editor configured for MJML\n   - Custom MJML syntax highlighting (if available)\n   - Auto-complete for MJML tags\n   - Validation on change\n   - Error indicators in gutter\n   - Variable insertion at cursor\n\n6. Create admin-panel/components/email/EmailPreview.tsx:\n   - Iframe for rendering HTML\n   - Device preview modes (desktop 600px, mobile 375px)\n   - Dark mode preview (CSS media query simulation)\n   - Refresh button to force re-render\n   - \"Open in New Tab\" to view full email\n\n7. Create admin-panel/components/email/VariablePicker.tsx:\n   - Collapsible sidebar or popover\n   - Search/filter variables\n   - Grouped by category\n   - Click to insert {{variableName}} at cursor\n   - Show variable description on hover\n\n8. Create admin-panel/components/email/TemplateTestModal.tsx:\n   - Input for test email address\n   - Select sample data set (different user scenarios)\n   - Send button\n   - Loading state\n   - Success/error message\n\n9. MJML compilation:\n   - Use mjml-browser for client-side compilation (preview)\n   - Server-side compilation in backend (for actual sending)\n   - Display compilation errors with line numbers\n   - Validate required MJML structure (mj-body, mj-section, etc.)\n\n10. Variable system:\n   - Define standard variables in constants file\n   - Validate variable usage in template\n   - Warn about undefined variables\n   - Support conditional blocks: {{#if isPremium}}...{{/if}}\n   - Support loops: {{#each meals}}...{{/each}}\n\n11. Template library:\n   - Provide starter templates (Welcome, Password Reset, Weekly Report, etc.)\n   - \"Use Template\" button to copy starter template\n   - Template categories for organization\n\n12. Error handling:\n   - Catch MJML compilation errors\n   - Display user-friendly error messages\n   - Prevent saving invalid templates\n   - Validate slug uniqueness before save",
            "status": "pending",
            "testStrategy": "1. Test MJML editor syntax highlighting and auto-complete\n2. Test live preview with various MJML structures\n3. Test variable insertion at cursor position\n4. Test desktop/mobile/dark mode preview switching\n5. Test MJML compilation error display\n6. Test template CRUD operations (create, read, update, delete)\n7. Test version history display and rollback\n8. Test duplicate template functionality\n9. Test send test email with sample data\n10. Test slug uniqueness validation\n11. Test conditional blocks and loops in preview\n12. Visual test: verify email renders correctly in preview iframe\n13. Test starter template copying",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Build admin panel template preview, testing, and version management",
            "description": "Create UI components for previewing templates across email clients, sending test emails, checking spam scores, and managing template versions with rollback capability",
            "dependencies": [
              7
            ],
            "details": "1. Create admin-panel/components/email/TemplatePreviewTabs.tsx:\n   - Tab interface:\n     * Desktop Preview (600px width)\n     * Mobile Preview (375px width)\n     * Dark Mode Preview (with prefers-color-scheme: dark)\n     * HTML Source (syntax highlighted HTML code)\n     * Plain Text (auto-generated from HTML)\n   - Each tab renders EmailPreview component with different config\n   - Persist selected tab in URL query params\n\n2. Create admin-panel/components/email/EmailClientPreview.tsx:\n   - Integration with Litmus or Email on Acid (optional, paid service)\n   - If configured:\n     * \"Preview in Email Clients\" button\n     * Generate previews for: Gmail, Outlook, Apple Mail, etc.\n     * Display screenshots in grid\n     * Note: Requires LITMUS_API_KEY or EMAIL_ON_ACID_API_KEY\n   - If not configured:\n     * Show note about email client testing\n     * Link to documentation for setup\n\n3. Create admin-panel/components/email/SpamScoreChecker.tsx:\n   - Integration with mail-tester.com or similar\n   - \"Check Spam Score\" button\n   - Generate unique email address from mail-tester API\n   - Send test email to that address\n   - Fetch and display spam score (0-10)\n   - Show recommendations:\n     * SPF/DKIM/DMARC status\n     * Spam trigger words detected\n     * Image-to-text ratio\n     * Link quality\n     * Blacklist status\n   - Action items to improve score\n\n4. Create admin-panel/components/email/SendTestEmailForm.tsx:\n   - Input fields:\n     * Test email address (comma-separated for multiple)\n     * Sample data selector (dropdown of user scenarios)\n     * Custom variable values (JSON editor for advanced users)\n   - \"Send Test\" button\n   - Loading state with progress indicator\n   - Success message with links to email logs\n   - Error handling with detailed messages\n   - Rate limiting: max 10 test emails per minute\n\n5. Create admin-panel/components/email/VersionHistory.tsx:\n   - Timeline view of template versions\n   - Each version shows:\n     * Version number\n     * Created by (admin user)\n     * Created at (timestamp)\n     * Change summary (if provided)\n     * Preview button\n   - Compare versions:\n     * Side-by-side diff of MJML content\n     * Highlight changes (additions in green, deletions in red)\n   - Rollback action:\n     * \"Restore this version\" button\n     * Creates new version (doesn't delete newer versions)\n     * Confirmation modal before rollback\n   - Export version as JSON for backup\n\n6. Create admin-panel/components/email/TemplateDiffViewer.tsx:\n   - Use react-diff-viewer or similar library\n   - Side-by-side diff of two template versions\n   - Syntax highlighting for MJML\n   - Line-by-line comparison\n   - Collapsible unchanged sections\n\n7. Update backend API in server/src/controllers/adminEmailController.ts:\n   - POST /api/admin/email/templates/:id/test\n     * Input: testEmails[], sampleDataKey\n     * Render template with sample data\n     * Send via Resend\n     * Return email log IDs\n   \n   - POST /api/admin/email/templates/:id/spam-score\n     * Integration with mail-tester.com API\n     * Send test email to mail-tester\n     * Poll for results\n     * Return spam score and recommendations\n   \n   - GET /api/admin/email/templates/:id/versions\n     * Return all versions of template\n     * Include diff metadata\n   \n   - POST /api/admin/email/templates/:id/rollback\n     * Input: targetVersion\n     * Create new version with content from targetVersion\n     * Audit log the rollback action\n   \n   - GET /api/admin/email/templates/:id/diff\n     * Input: version1, version2\n     * Return diff data for comparison\n\n8. Sample data presets:\n   - Create admin-panel/lib/emailSampleData.ts\n   - Define user scenarios:\n     * New user (just signed up)\n     * Active user (7-day streak)\n     * Premium user (all features)\n     * Inactive user (14 days no activity)\n     * Goal achieved user (reached target weight)\n   - Each scenario has complete variable values\n   - Used for preview and test emails\n\n9. Error handling:\n   - Catch Litmus/Email on Acid API errors\n   - Handle mail-tester API failures gracefully\n   - Validate test email addresses\n   - Rate limit test email sends\n   - Display clear error messages to admin\n\n10. Performance:\n   - Debounce live preview rendering\n   - Cache MJML compilation results\n   - Lazy load email client previews\n   - Optimize version history queries (paginate if >50 versions)",
            "status": "pending",
            "testStrategy": "1. Test desktop/mobile/dark mode preview switching\n2. Test HTML source and plain text views\n3. Test send test email with valid/invalid addresses\n4. Test sample data preset selection and rendering\n5. Test spam score checker integration (if configured)\n6. Test email client preview integration (if configured)\n7. Test version history display\n8. Test version comparison diff viewer\n9. Test rollback functionality (creates new version)\n10. Test rate limiting on test email sends\n11. Visual test: verify previews match actual email rendering\n12. Test error handling for API failures\n13. Performance test: verify debounced preview rendering",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Build admin panel campaign creation with audience segmentation",
            "description": "Create UI for creating and managing email campaigns with advanced audience segmentation, A/B testing configuration, scheduling, and estimated audience preview",
            "dependencies": [
              6,
              7
            ],
            "details": "1. Create admin-panel/app/(dashboard)/email/campaigns/page.tsx:\n   - Campaign list table:\n     * Columns: Name, Template, Status, Scheduled At, Audience Size, Sent, Opened, Clicked, Actions\n     * Status badges: Draft, Scheduled, Sending, Sent, Cancelled\n     * Filters: Status, Date range, Template\n     * Search by name\n     * Pagination (20 per page)\n   - Action buttons: View, Edit (draft only), Cancel (scheduled only), Duplicate, Analytics\n   - \"Create Campaign\" button → /email/campaigns/new\n   - Campaign stats summary cards:\n     * Total campaigns\n     * Active campaigns (scheduled/sending)\n     * Total emails sent (last 30 days)\n     * Average open rate\n\n2. Create admin-panel/app/(dashboard)/email/campaigns/new/page.tsx:\n   - Multi-step wizard:\n     Step 1: Campaign Details\n     - Name (text input)\n     - Description (textarea)\n     - Template selector (dropdown with preview)\n     - Campaign type (One-time, Recurring - future enhancement)\n     \n     Step 2: Audience Segmentation\n     - Segment builder UI (see details below)\n     - Estimated audience size (live update)\n     - Preview audience (show sample users)\n     - Save segment as template (optional)\n     \n     Step 3: A/B Testing (optional)\n     - Enable A/B testing toggle\n     - Test type: Subject line, Content, Send time\n     - Variant configuration:\n       * Variant A (default)\n       * Variant B (if subject: alternate subject, if content: alternate template)\n       * Split percentage (50/50, 70/30, etc.)\n     - Sample size for test (percentage of audience)\n     - Winner criteria: Open rate, Click rate, Manual\n     - Auto-send winner: If enabled, send winning variant to remaining audience after X hours\n     \n     Step 4: Schedule\n     - Send immediately (radio button)\n     - Schedule for later (radio button)\n       * Date picker\n       * Time picker\n       * Timezone selector (user's timezone, recipient's timezone, UTC)\n     - Throttling: Send X emails per hour (optional, for large campaigns)\n     \n     Step 5: Review & Confirm\n     - Summary of all settings\n     - Estimated audience size\n     - Template preview\n     - \"Send Test Email\" button\n     - \"Save as Draft\" or \"Schedule Campaign\" buttons\n\n3. Create admin-panel/components/email/SegmentBuilder.tsx:\n   - Visual query builder for audience segmentation\n   - Add condition button (+)\n   - Each condition has:\n     * Field selector (dropdown): Activity Level, Subscription Tier, Goal Type, Signup Date, Last Login, Goal Progress, Total Meals Logged, etc.\n     * Operator selector: is, is not, greater than, less than, between, contains, etc.\n     * Value input: varies by field type (text, number, date, select)\n   - Logical operators: AND/OR between conditions\n   - Condition groups (nested AND/OR)\n   - Example conditions:\n     * Activity Level is \"active\"\n     * Subscription Tier is \"PRO\"\n     * Signup Date is between \"2024-01-01\" and \"2024-12-31\"\n     * Total Meals Logged > 50\n     * Last Login < 7 days ago\n   - Live preview:\n     * Show estimated audience size\n     * \"Preview Users\" button → show sample users matching criteria\n   - Save as segment template:\n     * Name the segment\n     * Reuse in future campaigns\n\n4. Create admin-panel/components/email/AudiencePreview.tsx:\n   - Modal with table of sample users (10-20 users)\n   - Columns: Name, Email, Signup Date, Subscription Tier, Last Login\n   - \"Export Full List\" button (CSV download)\n   - Refresh button to re-fetch sample\n\n5. Create admin-panel/components/email/ABTestConfig.tsx:\n   - Subject line A/B test:\n     * Input for Variant A subject\n     * Input for Variant B subject\n     * Split slider (adjust percentage)\n   - Content A/B test:\n     * Template selector for Variant A\n     * Template selector for Variant B\n     * Preview both variants side-by-side\n   - Send time A/B test:\n     * Time picker for Variant A\n     * Time picker for Variant B\n   - Winner selection:\n     * Auto-select based on metric (open rate, click rate)\n     * Manual selection by admin\n     * Minimum sample size (e.g., 1000 emails)\n     * Minimum time before declaring winner (e.g., 24 hours)\n\n6. Create admin-panel/components/email/CampaignScheduler.tsx:\n   - Date picker (react-day-picker or similar)\n   - Time picker (hour/minute selector)\n   - Timezone selector (Intl.DateTimeFormat)\n   - \"Send immediately\" checkbox\n   - Throttling options:\n     * Max emails per hour\n     * Spread over X hours\n   - Confirmation modal:\n     * \"You're about to send to X users\"\n     * Show send time in user's timezone\n     * Final confirmation button\n\n7. Update backend API in server/src/controllers/adminEmailController.ts:\n   - POST /api/admin/email/campaigns (create campaign)\n   - PUT /api/admin/email/campaigns/:id (update draft campaign)\n   - POST /api/admin/email/campaigns/:id/schedule (schedule campaign)\n   - POST /api/admin/email/campaigns/:id/cancel (cancel scheduled campaign)\n   - GET /api/admin/email/campaigns/:id/audience-preview (get sample users matching segment)\n   - POST /api/admin/email/campaigns/:id/test (send test campaign)\n   - POST /api/admin/email/segments (save segment template)\n   - GET /api/admin/email/segments (list saved segments)\n\n8. Segment query builder backend:\n   - Parse segment criteria JSON\n   - Build dynamic Prisma query\n   - Apply filters, joins, aggregations\n   - Count matching users (for audience size)\n   - Fetch sample users (for preview)\n   - Validate segment criteria (prevent SQL injection)\n\n9. Campaign scheduling:\n   - Create Bull queue job for scheduled campaigns\n   - Job data: campaignId, scheduledAt\n   - On job execution:\n     * Fetch campaign and audience\n     * Send emails in batches\n     * Update campaign status (SENDING → SENT)\n     * Track progress\n\n10. Error handling:\n   - Validate segment criteria (no empty conditions)\n   - Validate A/B test config (must have 2 variants)\n   - Check scheduled time is in future\n   - Prevent scheduling campaign with 0 audience\n   - Handle timezone conversion errors\n   - Display clear error messages",
            "status": "pending",
            "testStrategy": "1. Test campaign creation wizard (all steps)\n2. Test segment builder condition creation and removal\n3. Test audience size calculation with various segment criteria\n4. Test audience preview (sample users display)\n5. Test A/B testing configuration (subject, content, send time)\n6. Test campaign scheduling (immediate vs. scheduled)\n7. Test timezone handling in scheduler\n8. Test throttling options\n9. Test campaign cancellation (scheduled campaigns only)\n10. Test segment template save and reuse\n11. Integration test: create campaign → schedule → send → verify emails sent\n12. Test validation errors (empty segment, past scheduled time, etc.)\n13. Visual test: verify multi-step wizard navigation\n14. Performance test: audience size calculation with large datasets",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Build admin panel automated email sequence builder (drip campaigns)",
            "description": "Create visual sequence builder UI with drag-and-drop flow editor, trigger configuration, step delays, conditional branching, and enrollment management",
            "dependencies": [
              6,
              7
            ],
            "details": "1. Install dependencies in admin-panel/:\n   ```bash\n   npm install reactflow @xyflow/react\n   npm install dagre  # for auto-layout\n   ```\n\n2. Create admin-panel/app/(dashboard)/email/sequences/page.tsx:\n   - Sequence list table:\n     * Columns: Name, Trigger Event, Status, Active Enrollments, Completed, Actions\n     * Status badges: Active, Inactive\n     * Filters: Trigger Event, Status\n     * Search by name\n   - Action buttons: View, Edit, Activate/Deactivate, Duplicate, Analytics\n   - \"Create Sequence\" button → /email/sequences/new\n   - Sequence stats summary:\n     * Total sequences\n     * Active sequences\n     * Total enrollments (all time)\n     * Active enrollments (current)\n\n3. Create admin-panel/app/(dashboard)/email/sequences/new/page.tsx:\n   - Multi-step wizard:\n     Step 1: Sequence Details\n     - Name (text input)\n     - Description (textarea)\n     - Trigger event selector (dropdown):\n       * User signup\n       * First meal logged\n       * Goal achieved\n       * Subscription changed (free → pro)\n       * Inactivity 7 days\n       * Inactivity 14 days\n       * Inactivity 30 days\n     - Enrollment criteria (optional filters):\n       * Who can enter this sequence?\n       * E.g., Only free users, Only users with goal type \"weight_loss\"\n     - Exit criteria (optional):\n       * When to automatically exit sequence?\n       * E.g., User upgrades to Pro, User achieves goal\n     \n     Step 2: Build Sequence Flow\n     - Visual flow builder (ReactFlow)\n     - Node types:\n       * Start node (trigger event)\n       * Wait node (delay for X hours/days)\n       * Email node (send specific template)\n       * Condition node (if/else branching)\n       * End node (complete sequence)\n     - Drag-and-drop interface:\n       * Sidebar with node types\n       * Drag onto canvas\n       * Connect nodes with edges\n     - Node configuration:\n       * Wait node: duration (hours/days/weeks)\n       * Email node: template selector, variable values\n       * Condition node: criteria (e.g., \"has logged meal in last 3 days?\")\n     - Auto-layout button (arrange nodes neatly)\n     - Validation:\n       * All nodes must be connected\n       * No orphan nodes\n       * Must end with End node\n     \n     Step 3: Review & Activate\n     - Sequence summary\n     - Flow visualization (read-only)\n     - Estimated duration (time from start to end)\n     - \"Save as Draft\" or \"Activate Sequence\" buttons\n\n4. Create admin-panel/components/email/SequenceFlowBuilder.tsx:\n   - ReactFlow canvas\n   - Custom node components:\n     * StartNode: Display trigger event, green color\n     * WaitNode: Display delay duration, gray color\n     * EmailNode: Display template name and subject, blue color\n     * ConditionNode: Display condition logic, yellow diamond shape\n     * EndNode: Display \"Complete\", red color\n   - Node toolbar:\n     * Edit (open config modal)\n     * Delete\n     * Duplicate\n   - Edge types:\n     * Default (solid line)\n     * Conditional (dashed line with label: \"Yes\"/\"No\")\n   - Controls:\n     * Zoom in/out\n     * Fit view\n     * Auto-layout (dagre algorithm)\n   - Validation on save:\n     * Check all nodes connected\n     * Verify no infinite loops\n     * Ensure at least one Email node exists\n\n5. Create admin-panel/components/email/SequenceNodeConfig.tsx:\n   - Modal for configuring each node type\n   - WaitNode config:\n     * Duration input (number)\n     * Unit selector (hours, days, weeks)\n   - EmailNode config:\n     * Template selector (dropdown with preview)\n     * Override variables (optional, JSON editor)\n   - ConditionNode config:\n     * Condition builder (similar to segment builder)\n     * Fields: Meals logged, Goal progress, Subscription tier, etc.\n     * Operators: >, <, =, between, etc.\n     * Yes/No branches\n\n6. Create admin-panel/app/(dashboard)/email/sequences/[id]/enrollments/page.tsx:\n   - Enrollments list table:\n     * Columns: User, Status, Current Step, Started At, Next Email, Actions\n     * Status badges: Active, Paused, Completed, Exited\n     * Filters: Status, Date range\n     * Search by user email/name\n   - Action buttons: View Details, Pause, Resume, Exit\n   - Bulk actions: Pause all, Resume all, Export\n\n7. Create admin-panel/components/email/EnrollmentTimeline.tsx:\n   - Timeline view of user's progress through sequence\n   - Each step shows:\n     * Step name (Wait, Email sent, Condition checked)\n     * Timestamp\n     * Status (Completed, Pending, Skipped)\n   - Email steps show:\n     * Email sent status (Sent, Delivered, Opened, Clicked)\n     * Link to email log\n   - Current step highlighted\n   - Next scheduled email with countdown\n\n8. Update backend API in server/src/controllers/adminEmailController.ts:\n   - POST /api/admin/email/sequences (create sequence)\n   - PUT /api/admin/email/sequences/:id (update sequence)\n   - POST /api/admin/email/sequences/:id/activate (activate sequence)\n   - POST /api/admin/email/sequences/:id/deactivate (deactivate sequence)\n   - GET /api/admin/email/sequences/:id/enrollments (list enrollments)\n   - POST /api/admin/email/sequences/:id/enrollments/:enrollmentId/pause (pause enrollment)\n   - POST /api/admin/email/sequences/:id/enrollments/:enrollmentId/resume (resume enrollment)\n   - POST /api/admin/email/sequences/:id/enrollments/:enrollmentId/exit (exit enrollment)\n   - DELETE /api/admin/email/sequences/:id (delete sequence, only if no enrollments)\n\n9. Sequence execution (backend):\n   - Create Bull queue: sequenceQueue\n   - On trigger event (e.g., user signup):\n     * Check if user meets enrollment criteria\n     * Create EmailSequenceEnrollment (status: ACTIVE, currentStep: 0)\n     * Schedule first step (queue job with delay)\n   - On sequence step job:\n     * Get enrollment and sequence\n     * Execute current step (send email, check condition)\n     * If Email node: send email, create EmailLog\n     * If Condition node: evaluate, determine next path\n     * If Wait node: schedule next step after delay\n     * Increment currentStep\n     * If End node: mark enrollment as COMPLETED\n   - Cron job to check for stuck enrollments:\n     * Find enrollments with nextStepScheduledAt in past\n     * Retry or exit with error\n\n10. Error handling:\n   - Validate sequence flow (no loops, all nodes connected)\n   - Handle email send failures (retry or exit sequence)\n   - Prevent activating sequence with errors\n   - Log all sequence execution errors\n   - Display clear error messages in admin panel",
            "status": "pending",
            "testStrategy": "1. Test sequence flow builder (drag-and-drop nodes)\n2. Test node configuration modals (wait, email, condition)\n3. Test auto-layout algorithm\n4. Test sequence validation (connected nodes, no loops)\n5. Test sequence activation/deactivation\n6. Test enrollment creation on trigger events\n7. Test enrollment progression through steps\n8. Test pause/resume enrollment functionality\n9. Test exit enrollment functionality\n10. Test condition node evaluation (branching logic)\n11. Integration test: create sequence → activate → trigger event → verify emails sent in sequence\n12. Test error handling for failed email sends\n13. Visual test: verify ReactFlow canvas renders correctly\n14. Performance test: sequence execution with 1000+ enrollments",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Build admin panel email analytics dashboard",
            "description": "Create comprehensive analytics dashboard with campaign performance metrics, email log search, trend charts, and export capabilities with Apple Mail Privacy Protection awareness",
            "dependencies": [
              6,
              9,
              10
            ],
            "details": "1. Create admin-panel/app/(dashboard)/email/analytics/page.tsx:\n   - Overview metrics cards (top of page):\n     * Total Emails Sent (last 30 days)\n     * Overall Open Rate (with Apple MPP caveat)\n     * Overall Click Rate\n     * Bounce Rate\n     * Unsubscribe Rate\n     * Active Campaigns\n   - Date range selector: Last 7 days, Last 30 days, Last 90 days, Custom range\n   - Filter by: Campaign, Template, Email category (Transactional/Marketing)\n   - Charts section (see below for details)\n   - Top performing campaigns table:\n     * Columns: Campaign Name, Sent, Delivered, Opened, Clicked, CTR\n     * Sort by any column\n     * Click to view detailed analytics\n   - Bottom performing campaigns (for optimization)\n\n2. Create admin-panel/components/email/EmailVolumeChart.tsx:\n   - Line chart: Emails sent over time\n   - Series: Total sent, Delivered, Bounced\n   - X-axis: Date\n   - Y-axis: Email count\n   - Stacked area chart option\n   - Tooltip with detailed stats\n   - Export chart as PNG/CSV\n\n3. Create admin-panel/components/email/EngagementChart.tsx:\n   - Multi-line chart: Open rate, Click rate, Unsubscribe rate over time\n   - X-axis: Date\n   - Y-axis: Percentage (0-100%)\n   - Apple Mail Privacy Protection indicator:\n     * Show percentage of opens from Apple proxy\n     * Display caveat: \"X% of opens may be automated by Apple Mail Privacy Protection\"\n   - Toggle to show/hide Apple proxy opens\n   - Compare mode: Compare two time periods side-by-side\n\n4. Create admin-panel/components/email/CampaignFunnelChart.tsx:\n   - Funnel visualization for a campaign:\n     * Sent → Delivered → Opened → Clicked\n     * Show count and percentage at each stage\n   - Highlight drop-off points\n   - Identify bottlenecks (e.g., high bounce rate, low open rate)\n\n5. Create admin-panel/components/email/EmailHeatmap.tsx:\n   - Heatmap: Best send times analysis\n   - X-axis: Hour of day (0-23)\n   - Y-axis: Day of week (Mon-Sun)\n   - Color intensity: Open rate or Click rate\n   - Identify optimal send times\n   - Recommendation: \"Best time to send: Tuesday at 10 AM\"\n\n6. Create admin-panel/app/(dashboard)/email/analytics/campaigns/[id]/page.tsx:\n   - Detailed campaign analytics page\n   - Campaign info section:\n     * Name, Template, Sent date, Audience size\n   - Key metrics cards:\n     * Sent, Delivered, Opened, Clicked, Bounced, Unsubscribed\n     * Open rate, Click-through rate, Bounce rate, Unsubscribe rate\n   - Email lifecycle funnel (sent → delivered → opened → clicked)\n   - Click heatmap:\n     * Show which links in email were clicked most\n     * Overlay click counts on email preview\n   - Time-series chart: Opens and clicks over time (first 48 hours)\n   - Top clicked links table:\n     * Columns: Link URL, Clicks, Unique Clicks, CTR\n   - Bounces breakdown:\n     * Hard bounces vs. Soft bounces\n     * Bounce reasons (table)\n   - Unsubscribe reasons (if collected)\n   - A/B test results (if applicable):\n     * Variant A vs. Variant B performance\n     * Winner declared at\n     * Statistical significance\n   - Export campaign analytics (CSV, PDF)\n\n7. Create admin-panel/components/email/ClickHeatmap.tsx:\n   - Overlay click data on email HTML preview\n   - Use absolute positioning to show click counts on links\n   - Color-code links by click volume (green = most clicks, red = least)\n   - Tooltip on hover: Show exact click count and CTR\n   - Toggle to show/hide heatmap\n\n8. Create admin-panel/app/(dashboard)/email/logs/page.tsx:\n   - Email log search and filter interface\n   - Filters:\n     * Date range\n     * Status (Sent, Delivered, Opened, Clicked, Bounced, Unsubscribed)\n     * User email/name\n     * Campaign\n     * Template\n     * Email category (Transactional/Marketing)\n   - Search bar: Free text search (email, subject)\n   - Logs table:\n     * Columns: User, Email, Template, Campaign, Status, Sent At, Opened At, Clicked At, Actions\n     * Expandable row: Show full email details (metadata, bounce reason, clicks)\n   - Pagination (50 per page)\n   - Export logs (CSV) with filters applied\n   - Bulk actions: Resend (for bounced emails), View email content\n\n9. Create admin-panel/components/email/EmailLogDetails.tsx:\n   - Modal or drawer with detailed log info\n   - Sections:\n     * Email metadata (Message ID, From, To, Subject, Sent At)\n     * Delivery timeline (Sent → Delivered → Opened → Clicked)\n     * Bounce info (if bounced): Type, Reason, Provider response\n     * Click data (if clicked): URLs clicked, Timestamps\n     * Apple MPP detection (if opened): Flag if proxy open\n   - \"View Email\" button: Open email HTML in new tab\n   - \"Resend Email\" button (for failed/bounced emails)\n\n10. Update backend API in server/src/controllers/adminEmailController.ts:\n   - GET /api/admin/email/analytics/overview (date range, filters → overview stats)\n   - GET /api/admin/email/analytics/trends (date range, metric → time-series data)\n   - GET /api/admin/email/analytics/campaigns/:id (detailed campaign analytics)\n   - GET /api/admin/email/analytics/click-heatmap/:campaignId (click data for heatmap)\n   - GET /api/admin/email/analytics/send-time-heatmap (best send times analysis)\n   - GET /api/admin/email/logs (filters, pagination → email logs)\n   - GET /api/admin/email/logs/:id (detailed log info)\n   - POST /api/admin/email/analytics/export (filters → CSV/PDF export)\n\n11. Analytics calculations:\n   - Open rate: (Opened / Delivered) * 100\n     * Caveat: Exclude or flag Apple proxy opens\n   - Click-through rate: (Clicked / Delivered) * 100\n   - Bounce rate: (Bounced / Sent) * 100\n   - Unsubscribe rate: (Unsubscribed / Delivered) * 100\n   - Conversion rate: (Conversions / Clicked) * 100 (if tracking conversions)\n\n12. Apple Mail Privacy Protection handling:\n   - Flag opens from Apple proxy IPs\n   - Display MPP percentage in analytics\n   - Show caveat in open rate metrics\n   - Provide \"Adjusted Open Rate\" (excluding MPP)\n   - Recommend focusing on click rate for engagement\n\n13. Performance optimizations:\n   - Cache analytics queries (5-minute TTL)\n   - Pre-aggregate campaign stats in EmailCampaign metadata\n   - Use database indexes for log queries\n   - Paginate large result sets\n   - Export large datasets as background job (send download link via email)",
            "status": "pending",
            "testStrategy": "1. Test overview metrics calculation accuracy\n2. Test date range filtering\n3. Test email volume chart rendering with time-series data\n4. Test engagement chart with Apple MPP filtering\n5. Test campaign funnel visualization\n6. Test send time heatmap calculation\n7. Test detailed campaign analytics page\n8. Test click heatmap overlay on email preview\n9. Test A/B test results display\n10. Test email log search and filtering\n11. Test email log details modal\n12. Test export functionality (CSV, PDF)\n13. Verify Apple MPP detection and flagging\n14. Performance test: analytics queries with 100k+ email logs\n15. Visual test: verify all charts render correctly with various data ranges",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Build admin panel subscriber management and list hygiene",
            "description": "Create UI for managing email subscribers, viewing engagement scores, importing/exporting lists, managing suppression lists, and performing list hygiene operations",
            "dependencies": [
              6,
              11
            ],
            "details": "1. Create admin-panel/app/(dashboard)/email/subscribers/page.tsx:\n   - Subscribers list table:\n     * Columns: User, Email, Preferences, Engagement Score, Last Email Opened, Status, Actions\n     * Status indicators: Active, Unsubscribed, Bounced, Complained\n     * Filters:\n       - Status (Active, Unsubscribed, Bounced, Complained)\n       - Subscription tier (Free, Pro)\n       - Engagement level (High, Medium, Low, Inactive)\n       - Preference categories (subscribed to X category)\n       - Signup date range\n       - Last activity date range\n     * Search: Email, Name, User ID\n   - Pagination (50 per page)\n   - Action buttons: View Details, Edit Preferences, Suppress, Unsuppress\n   - Bulk actions:\n     * Export selected (CSV)\n     * Suppress selected\n     * Update preferences (bulk)\n   - \"Import Subscribers\" button → open import modal\n   - Subscriber stats cards:\n     * Total subscribers\n     * Active (opted-in)\n     * Unsubscribed\n     * Suppressed (bounced/complained)\n\n2. Create admin-panel/components/email/SubscriberDetails.tsx:\n   - Modal or side panel with detailed subscriber info\n   - Sections:\n     * User info: Name, Email, Signup date, Subscription tier\n     * Email preferences:\n       - Categories (checkboxes for each category)\n       - Frequency (dropdown)\n       - Marketing opt-in status\n       - Double opt-in confirmed date\n     * Engagement metrics:\n       - Total emails received\n       - Total opened (percentage)\n       - Total clicked (percentage)\n       - Last email opened (date)\n       - Engagement score (0-100, calculated)\n     * Email history:\n       - Recent emails sent (last 10)\n       - Table: Template, Campaign, Sent At, Status (Delivered/Opened/Clicked)\n       - Click to view email log details\n     * Suppression status:\n       - Is suppressed? (Yes/No)\n       - Reason (Hard bounce, Soft bounce, Complaint, Manual)\n       - Suppressed at (date)\n       - \"Remove from suppression\" button\n   - Edit preferences:\n     * Update any preference\n     * Save button\n     * Audit log action\n   - Actions:\n     * Send test email\n     * View full email logs\n     * Suppress/Unsuppress\n     * Export subscriber data (JSON)\n\n3. Create admin-panel/components/email/EngagementScoreCalculator.tsx:\n   - Calculate engagement score (0-100) based on:\n     * Open rate (40 points max): (Opened / Sent) * 40\n     * Click rate (40 points max): (Clicked / Sent) * 40\n     * Recency (20 points max):\n       - Last opened < 7 days ago: 20 points\n       - Last opened 7-30 days ago: 10 points\n       - Last opened > 30 days ago: 0 points\n   - Display score with color indicator:\n     * 80-100: Green (Highly engaged)\n     * 50-79: Yellow (Moderately engaged)\n     * 20-49: Orange (Low engagement)\n     * 0-19: Red (Inactive)\n   - Show score breakdown tooltip\n\n4. Create admin-panel/components/email/ImportSubscribersModal.tsx:\n   - CSV upload interface\n   - Expected CSV format:\n     * Required columns: email, name\n     * Optional columns: goalCalories, goalProtein, marketingOptIn, categories\n   - Upload steps:\n     1. Upload CSV file\n     2. Preview data (show first 10 rows)\n     3. Map columns (if headers don't match exactly)\n     4. Validate emails (check format, duplicates)\n     5. Confirm import\n   - Import options:\n     * Skip duplicates\n     * Update existing users\n     * Send welcome email to new subscribers\n   - Progress indicator during import\n   - Results summary:\n     * X subscribers imported\n     * Y skipped (duplicates)\n     * Z errors (invalid emails)\n   - Download error log (CSV) if any errors\n\n5. Create admin-panel/components/email/ExportSubscribersModal.tsx:\n   - Export options:\n     * Format: CSV, JSON\n     * Filters: Apply current filters or select custom\n     * Include fields:\n       - User info (email, name, signup date)\n       - Preferences (categories, frequency)\n       - Engagement metrics (open rate, click rate, score)\n       - Email history (optional)\n   - Export button\n   - Download link (generated server-side)\n   - For large exports (>10k subscribers):\n     * Process as background job\n     * Send download link via email when ready\n\n6. Create admin-panel/app/(dashboard)/email/suppression/page.tsx:\n   - Suppression list management\n   - Tabs:\n     * Hard Bounces\n     * Soft Bounces\n     * Complaints (spam reports)\n     * Manual Suppressions\n   - Each tab shows table:\n     * Columns: Email, Reason, Suppressed At, Actions\n   - Filters: Date range, Reason\n   - Search by email\n   - Action buttons: View Details, Remove from Suppression\n   - Bulk actions:\n     * Remove selected from suppression\n     * Export suppression list (CSV)\n   - Suppression stats:\n     * Total suppressed\n     * Hard bounces count\n     * Soft bounces count\n     * Complaints count\n     * Manual suppressions count\n\n7. Create admin-panel/components/email/ListHygieneTools.tsx:\n   - List hygiene operations panel\n   - Tools:\n     * Identify inactive subscribers:\n       - Define: No email opened in last X days (configurable)\n       - Show count of inactive subscribers\n       - Actions: Suppress, Re-engagement campaign, Export\n     * Remove duplicate emails:\n       - Find users with duplicate emails\n       - Show count and list\n       - Action: Merge or delete duplicates\n     * Validate email addresses:\n       - Check for invalid email formats\n       - Check for disposable email domains\n       - Show count and list\n       - Action: Suppress invalid emails\n     * Clean soft bounces:\n       - Remove soft bounces older than X days (default 30)\n       - Give them another chance\n   - Schedule automated list hygiene:\n     * Cron job to run list hygiene weekly\n     * Send report to admin email\n\n8. Update backend API in server/src/controllers/adminEmailController.ts:\n   - GET /api/admin/email/subscribers (filters, pagination → subscribers list)\n   - GET /api/admin/email/subscribers/:userId (detailed subscriber info)\n   - PUT /api/admin/email/subscribers/:userId/preferences (update preferences)\n   - POST /api/admin/email/subscribers/:userId/suppress (add to suppression list)\n   - POST /api/admin/email/subscribers/:userId/unsuppress (remove from suppression)\n   - POST /api/admin/email/subscribers/import (CSV upload → import subscribers)\n   - POST /api/admin/email/subscribers/export (filters → CSV/JSON export)\n   - GET /api/admin/email/suppression (filters, pagination → suppression list)\n   - DELETE /api/admin/email/suppression/:email (remove from suppression)\n   - POST /api/admin/email/hygiene/inactive (threshold → identify inactive subscribers)\n   - POST /api/admin/email/hygiene/duplicates (→ find and merge/delete duplicates)\n   - POST /api/admin/email/hygiene/validate (→ validate email addresses)\n   - POST /api/admin/email/hygiene/soft-bounces (→ clean old soft bounces)\n\n9. Engagement score calculation (backend):\n   - Calculate on-demand or cache in EmailPreference\n   - Recalculate daily via cron job\n   - Use for segmentation (e.g., send re-engagement campaign to low-engagement users)\n\n10. List hygiene automations:\n   - Daily cron job:\n     * Suppress hard bounces automatically\n     * Flag users with >3 soft bounces\n     * Identify inactive users (no opens in 90 days)\n   - Weekly cron job:\n     * Clean soft bounces older than 30 days\n     * Validate new email addresses\n     * Generate list hygiene report\n   - Monthly cron job:\n     * Re-engagement campaign for inactive users\n     * Remove suppression for soft bounces (give second chance)\n\n11. Security and compliance:\n   - Audit log all subscriber preference updates\n   - Require admin authentication for all operations\n   - RBAC: SUPER_ADMIN can suppress/unsuppress, SUPPORT can view only\n   - Validate all imported data\n   - Prevent suppression of transactional emails\n\n12. Performance:\n   - Index EmailPreference by email, status\n   - Cache engagement scores\n   - Paginate large subscriber lists\n   - Process large imports as background jobs\n   - Export large lists as background jobs",
            "status": "pending",
            "testStrategy": "1. Test subscriber list with various filters\n2. Test subscriber details modal (all sections)\n3. Test engagement score calculation accuracy\n4. Test CSV import with valid/invalid data\n5. Test duplicate handling in import\n6. Test export functionality (CSV, JSON)\n7. Test suppression list management (add, remove)\n8. Test list hygiene tools (identify inactive, validate emails)\n9. Test bulk actions (export, suppress, update preferences)\n10. Integration test: import CSV → verify subscribers created with correct preferences\n11. Test RBAC permissions for subscriber management\n12. Verify audit logging for all admin actions\n13. Performance test: subscriber list with 100k+ users\n14. Visual test: verify tables and charts render correctly",
            "parentId": "undefined"
          },
          {
            "id": 13,
            "title": "Build mobile app email preferences screen",
            "description": "Create React Native screens for users to manage their email preferences, including category toggles, frequency settings, and unsubscribe options, integrated with backend email preference API",
            "dependencies": [
              5
            ],
            "details": "1. Create app/email-preferences.tsx:\n   - Screen title: \"Email Preferences\"\n   - Description text: \"Choose which emails you'd like to receive from Nutri\"\n   - Fetch user's EmailPreference on mount (GET /api/email/preferences)\n   - Loading state while fetching\n   - Error handling with retry button\n\n2. Email category toggles:\n   - Section: \"Email Categories\"\n   - Each category as toggle switch:\n     * Weekly Progress Reports\n       - Description: \"Your weekly nutrition and health summary\"\n       - Icon: ChartBarIcon\n     * Health Insights\n       - Description: \"Personalized insights based on your data\"\n       - Icon: LightbulbIcon\n     * Tips & Recipes\n       - Description: \"Nutrition tips and healthy recipe ideas\"\n       - Icon: BookOpenIcon\n     * Feature Updates\n       - Description: \"New features and app improvements\"\n       - Icon: BellIcon\n     * Promotional Offers\n       - Description: \"Special offers and promotions\"\n       - Icon: TagIcon\n   - Each toggle updates local state immediately\n   - Debounced save to backend (500ms after last change)\n\n3. Email frequency setting:\n   - Section: \"Email Frequency\"\n   - Radio buttons or picker:\n     * Real-time (as events happen)\n     * Daily Digest (once per day)\n     * Weekly Digest (once per week)\n   - Selected option highlighted\n   - Save to backend on change\n\n4. Marketing opt-in:\n   - Section: \"Marketing Emails\"\n   - Toggle switch: \"Receive marketing emails\"\n   - Description: \"Get updates about new features, tips, and offers\"\n   - Disabled if user has globally unsubscribed\n   - Note: \"Transactional emails (like password resets) will always be sent\"\n\n5. Global unsubscribe:\n   - Section: \"Unsubscribe\"\n   - Danger zone (red background)\n   - \"Unsubscribe from all marketing emails\" button\n   - Confirmation alert:\n     * Title: \"Unsubscribe from all?\"\n     * Message: \"You'll no longer receive marketing emails. Transactional emails (like password resets) will still be sent.\"\n     * Buttons: Cancel, Confirm\n   - On confirm: Call POST /api/email/unsubscribe\n   - Show success message: \"You've been unsubscribed. You can resubscribe anytime.\"\n\n6. Resubscribe option:\n   - If user is globally unsubscribed:\n     * Show message: \"You're currently unsubscribed from all marketing emails.\"\n     * \"Resubscribe\" button\n     * On tap: Clear globalUnsubscribedAt, restore previous preferences\n     * Show success message: \"You've been resubscribed. Update your preferences below.\"\n\n7. Update email address:\n   - Section: \"Email Address\"\n   - Display current email (read-only or editable)\n   - \"Change Email\" button → navigate to profile settings\n   - Note: \"Email updates will be sent to this address\"\n\n8. Save button:\n   - Sticky button at bottom: \"Save Preferences\"\n   - Enabled only if preferences have changed\n   - Loading state during save\n   - Success message: \"Preferences saved!\"\n   - Error handling: Display error message, retry option\n\n9. Create lib/api/emailPreferences.ts:\n   - getPreferences(): GET /api/email/preferences\n   - updatePreferences(data): PUT /api/email/preferences\n   - unsubscribeAll(): POST /api/email/unsubscribe\n   - resubscribe(): POST /api/email/resubscribe (or updatePreferences with globalUnsubscribedAt = null)\n   - All methods use authenticated API client\n\n10. Add navigation to email preferences:\n   - From app/(tabs)/profile.tsx:\n     * Add \"Email Preferences\" row in Settings section\n     * Icon: EnvelopeIcon\n     * On tap: router.push('/email-preferences')\n\n11. Optional: Onboarding email opt-in:\n   - During signup flow (app/auth/signup.tsx):\n     * After creating account, show modal:\n       - Title: \"Stay updated with Nutri\"\n       - Description: \"Get personalized health insights, nutrition tips, and progress reports delivered to your inbox.\"\n       - Checkboxes for pre-selected categories (Weekly Reports, Health Insights)\n       - \"Get Started\" button (opt-in)\n       - \"Skip\" button (opt-out)\n     * On \"Get Started\": Create EmailPreference with marketingOptIn=true\n     * On \"Skip\": Create EmailPreference with marketingOptIn=false\n   - GDPR compliant: Explicit consent, no pre-checked boxes (unless user actively taps \"Get Started\")\n\n12. Styling:\n   - Use consistent design system (lib/theme/colors.ts)\n   - Toggle switches: iOS-style or Material-style\n   - Sections separated with borders or spacing\n   - Danger zone (unsubscribe) with red/orange background\n   - Icons for each category (Lucide icons or SF Symbols)\n   - Responsive padding and margins\n\n13. Accessibility:\n   - accessibilityLabel for all toggles and buttons\n   - accessibilityHint for non-obvious actions\n   - Screen reader announcements for save success/error\n   - Sufficient color contrast\n   - Touch targets ≥44px\n\n14. Analytics (optional):\n   - Track events:\n     * Email preferences viewed\n     * Category toggled (on/off)\n     * Frequency changed\n     * Unsubscribed\n     * Resubscribed\n   - Use existing analytics service",
            "status": "pending",
            "testStrategy": "1. Test fetching email preferences on mount\n2. Test category toggle updates local state and saves to backend\n3. Test frequency selector updates backend\n4. Test marketing opt-in toggle\n5. Test global unsubscribe flow (confirmation, API call, success message)\n6. Test resubscribe flow\n7. Test debounced save (multiple quick toggles → single API call)\n8. Test error handling (network failure, 401, 500)\n9. Test navigation to email preferences from profile screen\n10. Test onboarding opt-in modal (if implemented)\n11. Accessibility test: verify labels and hints\n12. Visual test: verify layout on iOS/Android, light/dark mode\n13. Integration test: update preferences in app → verify in admin panel\n14. Test with no network connection (offline state)",
            "parentId": "undefined"
          },
          {
            "id": 14,
            "title": "Implement compliance features: GDPR double opt-in, one-click unsubscribe (RFC 8058), and CAN-SPAM",
            "description": "Implement all compliance features including GDPR-compliant double opt-in flow, RFC 8058 one-click unsubscribe headers, CAN-SPAM footer requirements, and privacy policy integration",
            "dependencies": [
              1,
              2,
              3,
              5
            ],
            "details": "1. GDPR Double Opt-In Implementation:\n   - Update backend service (server/src/services/emailPreferenceService.ts):\n     * initiateDoubleOptIn(userId: string): \n       - Generate secure token (JWT with 7-day expiry)\n       - Send confirmation email with confirmation link\n       - Email template: \"Please confirm your email subscription\"\n       - Link format: https://nutriapp.com/api/email/opt-in/confirm?token=xxx\n     * confirmDoubleOptIn(token: string):\n       - Verify token\n       - Update EmailPreference: set doubleOptInConfirmedAt = now()\n       - Send welcome email\n       - Return success message\n   - Create double opt-in email template:\n     * Subject: \"Please confirm your email subscription to Nutri\"\n     * Body: \n       - \"Thanks for subscribing to Nutri emails!\"\n       - \"Please confirm your subscription by clicking the button below.\"\n       - Confirmation button (CTA)\n       - \"If you didn't subscribe, you can safely ignore this email.\"\n     * Template type: TRANSACTIONAL (always delivered)\n   - API endpoints:\n     * POST /api/email/opt-in (authenticated) → sends confirmation email\n     * GET /api/email/opt-in/confirm?token=xxx (public) → confirms opt-in\n\n2. One-Click Unsubscribe (RFC 8058):\n   - Update emailService.ts to include List-Unsubscribe headers:\n     * List-Unsubscribe: <https://nutriapp.com/api/email/unsubscribe/{{token}}>, <mailto:unsubscribe@nutriapp.com?subject=unsubscribe>\n     * List-Unsubscribe-Post: List-Unsubscribe=One-Click\n   - Unsubscribe token generation:\n     * generateUnsubscribeToken(userId, campaignId):\n       - JWT with userId, campaignId, expiry (90 days)\n       - Signed with EMAIL_UNSUBSCRIBE_SECRET\n   - Backend endpoint:\n     * POST /api/email/unsubscribe/one-click\n       - No authentication required\n       - Parse List-Unsubscribe-Post header\n       - Verify token\n       - Immediately unsubscribe user (set globalUnsubscribedAt)\n       - Exit user from all active sequences\n       - Return 200 OK (no body, per RFC 8058)\n       - Log action in EmailLog\n   - GET /api/email/unsubscribe/:token\n     * Display unsubscribe confirmation page (HTML)\n     * Show message: \"You've been unsubscribed from Nutri marketing emails.\"\n     * Options:\n       - \"Unsubscribe from all marketing\" (default, already done)\n       - \"Unsubscribe from specific categories\" (show checkboxes)\n       - \"Update email preferences\" (link to mobile app or web preferences page)\n     * No login required\n     * Track unsubscribe in EmailLog\n\n3. CAN-SPAM Compliance:\n   - Email footer template (add to all marketing emails):\n     * Physical address: \n       - \"Nutri Inc., [Your Company Address], [City, State, ZIP]\"\n       - Use env var: EMAIL_PHYSICAL_ADDRESS\n     * Sender identification:\n       - \"This email was sent to {{email}} by Nutri.\"\n     * Unsubscribe link:\n       - \"Unsubscribe from marketing emails: {{unsubscribeUrl}}\"\n       - \"Update your email preferences: {{preferencesUrl}}\"\n     * Disclaimer:\n       - \"We respect your privacy. View our Privacy Policy: {{privacyPolicyUrl}}\"\n   - Update email templates:\n     * Include footer in all MJML templates\n     * Use mj-section for footer\n     * Style: Gray background, small font, centered text\n   - Honest subject lines:\n     * Validate subject lines in admin panel\n     * Warn if subject contains misleading words (\"Free\", \"Urgent\", \"Act now\")\n     * Prevent \"RE:\" or \"FWD:\" in subject (unless genuine reply/forward)\n   - Honor unsubscribes:\n     * Process unsubscribes immediately (already implemented)\n     * Do not send marketing emails to unsubscribed users\n     * Check unsubscribe status before queuing emails\n\n4. Privacy Policy Integration:\n   - Update app/privacy.tsx (mobile app):\n     * Add section: \"Email Communications\"\n     * Explain:\n       - What emails we send (transactional vs. marketing)\n       - How to opt-in/opt-out\n       - How we use email data (open/click tracking)\n       - Third-party email service provider (Resend)\n       - Data retention policy (email logs kept for X days)\n     * Link to email preferences screen\n   - Email footer includes link to privacy policy:\n     * https://nutriapp.com/privacy (web version)\n     * Or app deep link: nutriapp://privacy\n\n5. Data Retention Policy:\n   - Define retention periods:\n     * EmailLog: Keep for 90 days, then delete (GDPR right to erasure)\n     * EmailPreference: Keep as long as user account exists\n     * EmailCampaign: Keep indefinitely for analytics (anonymize after 1 year)\n     * EmailTemplate: Keep indefinitely (version history)\n   - Implement data deletion cron job:\n     * Daily job: Delete EmailLog entries older than 90 days\n     * On user deletion: Delete all EmailLog, EmailPreference, EmailSequenceEnrollment\n   - GDPR data export:\n     * Include email preferences and email history in user data export\n     * Format: JSON or CSV\n\n6. GDPR Right to Erasure:\n   - On user account deletion:\n     * Delete EmailPreference\n     * Delete EmailLog\n     * Delete EmailSequenceEnrollment\n     * Anonymize EmailCampaign analytics (remove userId, keep aggregated stats)\n   - Provide user data export:\n     * Include email preferences, email history, unsubscribe status\n     * Downloadable from profile settings\n\n7. Consent Management:\n   - Track consent:\n     * EmailPreference.doubleOptInConfirmedAt: When user confirmed opt-in\n     * EmailPreference.marketingOptIn: Explicit consent for marketing\n     * Audit log: Track all preference changes\n   - Granular consent:\n     * Category-level opt-in (Weekly Reports, Tips, Promotions, etc.)\n     * User can opt-in/out of specific categories\n   - Re-consent flow (if needed):\n     * If email laws change, trigger re-consent campaign\n     * Send email: \"We've updated our email policy. Please confirm your subscription.\"\n     * Link to double opt-in confirmation\n\n8. Apple Mail Privacy Protection Handling:\n   - Detect Apple proxy opens:\n     * Check user agent for \"AppleMailProxy\"\n     * Check IP address against known Apple proxy IPs\n     * Set EmailLog.isAppleProxyOpen = true\n   - Analytics adjustments:\n     * Display open rate with caveat: \"May include automated opens\"\n     * Provide \"Adjusted Open Rate\" (excluding Apple proxy opens)\n     * Focus on click rate for engagement metrics\n   - Inform admins:\n     * Dashboard notice: \"Apple Mail Privacy Protection may inflate open rates\"\n     * Link to documentation explaining MPP\n\n9. Unsubscribe Confirmation Page:\n   - Create server/src/views/unsubscribe.html (or use template engine):\n     * HTML page shown after one-click unsubscribe\n     * Message: \"You've been unsubscribed from Nutri marketing emails.\"\n     * Options:\n       - \"Resubscribe\" button (POST /api/email/resubscribe with token)\n       - \"Update preferences\" link (to mobile app or web preferences)\n     * Footer with privacy policy link\n   - Serve via Express:\n     * app.get('/email/unsubscribe/:token', renderUnsubscribePage)\n\n10. Compliance Monitoring:\n   - Admin dashboard alerts:\n     * High unsubscribe rate (>2% per campaign)\n     * High complaint rate (>0.1%)\n     * High bounce rate (>5%)\n     * Low double opt-in confirmation rate (<50%)\n   - Weekly compliance report:\n     * Unsubscribe rate trend\n     * Complaint rate trend\n     * Bounce rate trend\n     * Email sent to unsubscribed users (should be 0)\n   - Audit log:\n     * All unsubscribe events\n     * All preference changes\n     * All admin actions (suppress, unsuppress, etc.)\n\n11. Email Authentication Monitoring:\n   - Monitor DKIM/SPF/DMARC status:\n     * Check domain authentication in Resend dashboard\n     * Alert if authentication fails\n   - Monitor domain reputation:\n     * Check blacklist status (use MXToolbox API or similar)\n     * Alert if domain is blacklisted\n   - Monitor deliverability:\n     * Track bounce rate, complaint rate\n     * Alert if rates exceed thresholds\n\n12. Testing Compliance:\n   - Test double opt-in flow:\n     * User opts in → receives confirmation email → confirms → doubleOptInConfirmedAt set\n   - Test one-click unsubscribe:\n     * Email sent with List-Unsubscribe headers → user clicks unsubscribe → immediately unsubscribed\n   - Test CAN-SPAM footer:\n     * All marketing emails include footer with address, unsubscribe link, privacy policy link\n   - Test unsubscribe honor:\n     * Unsubscribed user should not receive marketing emails\n     * Verify in campaign sending logic\n   - Test data deletion:\n     * User deletes account → all email data deleted/anonymized\n   - Test GDPR data export:\n     * User requests data export → receives email preferences and history",
            "status": "pending",
            "testStrategy": "1. Test double opt-in flow: initiate → confirm → doubleOptInConfirmedAt set\n2. Test one-click unsubscribe (RFC 8058): verify List-Unsubscribe headers, POST endpoint\n3. Test unsubscribe confirmation page rendering\n4. Test CAN-SPAM footer in email templates\n5. Test unsubscribe honor: verify unsubscribed users don't receive marketing emails\n6. Test data retention: verify old EmailLogs are deleted after 90 days\n7. Test GDPR data export: verify email data included in export\n8. Test user deletion: verify all email data deleted/anonymized\n9. Test Apple Mail Privacy Protection detection: verify isAppleProxyOpen flag\n10. Test compliance monitoring alerts (high unsubscribe rate, etc.)\n11. Integration test: full user lifecycle (signup → opt-in → receive emails → unsubscribe → data deleted)\n12. Legal review: verify all GDPR and CAN-SPAM requirements met\n13. Test email authentication: verify DKIM/SPF/DMARC configured correctly\n14. Penetration test: verify unsubscribe tokens cannot be forged",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 42,
        "title": "Water Tracking Mobile UI with Daily Goals and Reminders",
        "description": "Implement complete water tracking functionality including mobile UI screens, backend API endpoints, daily goal management, quick-add interactions, and hydration reminders integration. The WaterIntake Prisma model already exists but has no API or UI implementation.",
        "details": "## Current State Analysis\n\n### Existing Infrastructure:\n- **Prisma Model** (`server/prisma/schema.prisma` lines 120-130):\n  ```prisma\n  model WaterIntake {\n    id        String   @id @default(cuid())\n    userId    String\n    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n    amount    Float    // in ml\n    recordedAt DateTime @default(now())\n    createdAt DateTime @default(now())\n    @@index([userId, recordedAt])\n  }\n  ```\n- **User Model**: Has `waterIntakes WaterIntake[]` relation\n- **NO backend API endpoints** for water tracking\n- **NO mobile UI screens** for water tracking\n- **NO water goal field** in User model (need to add)\n\n### Required Schema Updates\n\nAdd to User model in `server/prisma/schema.prisma`:\n```prisma\n// Water tracking\ngoalWaterMl       Int      @default(2500)  // Daily water goal in ml (default 2.5L)\nwaterReminderEnabled Boolean @default(false)\nwaterReminderInterval Int?   // Minutes between reminders (e.g., 60, 90, 120)\n```\n\n## Backend API Implementation\n\n### 1. Water Service (`server/src/services/waterService.ts`)\n\n```typescript\ninterface WaterIntakeInput {\n  amount: number;      // ml\n  recordedAt?: Date;   // defaults to now\n}\n\ninterface DailyWaterSummary {\n  date: string;\n  totalMl: number;\n  goalMl: number;\n  percentComplete: number;\n  entries: WaterIntake[];\n}\n\nclass WaterService {\n  // Create water intake entry\n  async createWaterIntake(userId: string, data: WaterIntakeInput): Promise<WaterIntake>;\n  \n  // Get daily summary with goal progress\n  async getDailySummary(userId: string, date: string): Promise<DailyWaterSummary>;\n  \n  // Get entries for date range\n  async getWaterIntakes(userId: string, startDate: Date, endDate: Date): Promise<WaterIntake[]>;\n  \n  // Delete entry\n  async deleteWaterIntake(userId: string, entryId: string): Promise<void>;\n  \n  // Update user's daily water goal\n  async updateWaterGoal(userId: string, goalMl: number): Promise<User>;\n  \n  // Get weekly/monthly trends\n  async getWaterTrends(userId: string, period: 'week' | 'month'): Promise<WaterTrend[]>;\n}\n```\n\n### 2. Water Controller (`server/src/controllers/waterController.ts`)\n\nEndpoints:\n- `POST /api/water` - Log water intake\n- `GET /api/water/today` - Get today's summary with goal progress\n- `GET /api/water/daily/:date` - Get specific day's summary\n- `GET /api/water?startDate=&endDate=` - Get entries for range\n- `DELETE /api/water/:id` - Delete entry\n- `PUT /api/user/water-goal` - Update water goal\n- `GET /api/water/trends?period=week|month` - Get trends\n\n### 3. Validation Schemas (`server/src/validation/schemas.ts`)\n\n```typescript\nexport const createWaterIntakeSchema = z.object({\n  amount: z.number().min(1).max(5000), // 1ml to 5L per entry\n  recordedAt: z.string().datetime().optional(),\n});\n\nexport const updateWaterGoalSchema = z.object({\n  goalMl: z.number().min(500).max(10000), // 0.5L to 10L\n});\n\nexport const getWaterTrendsSchema = z.object({\n  period: z.enum(['week', 'month']),\n});\n```\n\n### 4. Routes (`server/src/routes/waterRoutes.ts`)\n\n- Apply `requireAuth` middleware to all routes\n- Apply rate limiting (100 req/15min)\n- Register in `server/src/index.ts`\n\n## Mobile App Implementation\n\n### 1. API Client (`lib/api/water.ts`)\n\n```typescript\nexport const waterApi = {\n  logWater: (amount: number, recordedAt?: string) => \n    apiClient.post('/water', { amount, recordedAt }),\n  \n  getTodaySummary: () => \n    apiClient.get('/water/today'),\n  \n  getDailySummary: (date: string) => \n    apiClient.get(`/water/daily/${date}`),\n  \n  getWaterIntakes: (startDate: string, endDate: string) => \n    apiClient.get('/water', { params: { startDate, endDate } }),\n  \n  deleteEntry: (id: string) => \n    apiClient.delete(`/water/${id}`),\n  \n  updateGoal: (goalMl: number) => \n    apiClient.put('/user/water-goal', { goalMl }),\n  \n  getTrends: (period: 'week' | 'month') => \n    apiClient.get('/water/trends', { params: { period } }),\n};\n```\n\n### 2. Water Tracking Screen (`app/water.tsx`)\n\nMain screen with:\n- **Circular Progress Ring**: Visual representation of daily progress\n  - Shows current ml / goal ml\n  - Percentage complete\n  - Animated fill as water is logged\n  - Color changes: blue → light blue → green when goal reached\n  \n- **Quick Add Buttons Grid**:\n  - 150ml (small glass)\n  - 250ml (glass/cup)\n  - 500ml (bottle)\n  - 750ml (large bottle)\n  - Custom amount button (opens modal)\n  \n- **Today's Log Section**:\n  - Scrollable list of today's entries\n  - Each entry shows: time, amount, delete button\n  - Swipe to delete (use existing SwipeableCard pattern)\n  \n- **Weekly Overview Chart**:\n  - Bar chart showing last 7 days\n  - Goal line overlay\n  - Tap day to see details\n\n### 3. Water Goal Settings (`app/water-settings.tsx`)\n\n- Daily goal input with slider (500ml - 5000ml)\n- Preset goals: 2L, 2.5L, 3L, 3.5L, 4L\n- Goal calculator based on:\n  - Body weight (0.033L per kg)\n  - Activity level adjustment\n  - Climate/season adjustment\n- Reminder settings:\n  - Enable/disable toggle\n  - Interval picker (30min, 1hr, 1.5hr, 2hr)\n  - Quiet hours (sleep time exclusion)\n  - Integration with push notifications (Task 40)\n\n### 4. Water Widget Component (`lib/components/WaterWidget.tsx`)\n\nCompact widget for dashboard (`app/(tabs)/index.tsx`):\n- Small circular progress indicator\n- Current ml / goal\n- Quick +250ml button\n- Tap to open full water screen\n\n### 5. Custom Amount Modal (`lib/components/WaterAmountModal.tsx`)\n\n- Number input with +/- buttons\n- Common amounts as chips: 100, 200, 300, 400, 500ml\n- Unit toggle: ml / oz / cups\n- Keyboard-friendly numeric input\n\n## UI/UX Design Specifications\n\n### Design Tokens (from `lib/theme/colors.ts`):\n```typescript\nwater: {\n  background: colors.background.tertiary,\n  progressEmpty: '#1E3A5F',      // Dark blue\n  progressFill: '#3B82F6',        // Bright blue\n  progressComplete: '#10B981',    // Green when goal met\n  quickAddButton: colors.background.secondary,\n  quickAddButtonPressed: colors.primary.main,\n}\n```\n\n### Animations:\n- Progress ring fills with spring animation on log\n- Ripple effect on quick add buttons\n- Celebration animation when goal reached (confetti or pulse)\n- Entry items slide in with stagger\n\n### Accessibility:\n- VoiceOver: \"Water tracking, 1500 milliliters of 2500 milliliter goal, 60 percent complete\"\n- Quick add buttons have clear labels\n- Color contrast for all states\n\n## Integration Points\n\n### 1. Dashboard Widget:\nAdd to `app/(tabs)/index.tsx` between existing cards:\n```tsx\n<WaterWidget onPress={() => router.push('/water')} />\n```\n\n### 2. Navigation:\n- Add route to `app/_layout.tsx` with `headerShown: false`\n- Add \"Water\" row in profile settings linking to water-settings\n- Optional: Add Water as a tab (but may clutter - recommend modal access)\n\n### 3. Push Notification Integration (Task 40):\n- Hydration reminders as WATER_REMINDER category\n- Smart reminders based on:\n  - Time since last log\n  - Current progress vs goal\n  - User's typical drinking patterns\n\n### 4. HealthKit Integration (Task 5):\n- Write water data to HealthKit (HKQuantityTypeIdentifierDietaryWater)\n- Read water from HealthKit if user logs elsewhere\n- Deduplicate entries\n\n### 5. ML Insights (Task 8):\n- Correlate hydration with:\n  - Energy levels\n  - Sleep quality\n  - Exercise performance\n- Generate insights: \"You drink 30% more water on workout days\"\n\n## Unit Conversions\n\nSupport user preference for units:\n```typescript\nconst CONVERSIONS = {\n  ml_to_oz: 0.033814,\n  oz_to_ml: 29.5735,\n  ml_to_cups: 0.00422675,\n  cups_to_ml: 236.588,\n};\n\n// Store in ml, display in user's preferred unit\n// Add `waterUnit` field to User model: 'ml' | 'oz' | 'cups'\n```\n\n## Error Handling\n\nFollow existing patterns from `lib/utils/errorHandling.ts`:\n- Network errors: Show retry button\n- Validation errors: Inline field errors\n- Server errors: Alert with generic message\n- Optimistic updates: Log immediately, rollback on failure\n\n## Performance Considerations\n\n- Cache today's summary in memory\n- Debounce frequent logging (if user taps rapidly)\n- Lazy load weekly chart data\n- Prefetch trends when entering screen",
        "testStrategy": "## Testing Strategy\n\n### Backend Unit Tests (`server/src/__tests__/water.test.ts`)\n\n1. **Service Tests**:\n   - createWaterIntake: Valid input creates entry\n   - createWaterIntake: Invalid amount (negative, too large) throws\n   - getDailySummary: Returns correct total and percentage\n   - getDailySummary: Handles no entries (0%)\n   - getDailySummary: Respects timezone for \"today\"\n   - deleteWaterIntake: Only owner can delete\n   - updateWaterGoal: Validates min/max bounds\n   - getWaterTrends: Aggregates correctly for week/month\n\n2. **Controller Tests**:\n   - POST /api/water: 201 on success\n   - POST /api/water: 400 on invalid amount\n   - POST /api/water: 401 without auth\n   - GET /api/water/today: Returns summary\n   - DELETE /api/water/:id: 404 for non-existent\n   - DELETE /api/water/:id: 403 for other user's entry\n\n3. **Integration Tests**:\n   - Full flow: Log multiple entries → Get summary → Verify total\n   - Goal update → Summary reflects new goal percentage\n\n### Mobile Tests\n\n1. **Component Tests** (`__tests__/components/WaterWidget.test.tsx`):\n   - Renders current progress correctly\n   - Quick add button calls API\n   - Tap navigates to full screen\n\n2. **Screen Tests** (`__tests__/screens/WaterScreen.test.tsx`):\n   - Loads today's summary on mount\n   - Quick add buttons log correct amounts\n   - Custom amount modal validates input\n   - Delete entry removes from list\n   - Progress ring animates on log\n   - Goal reached shows celebration\n\n3. **API Client Tests** (`__tests__/api/water.test.ts`):\n   - Mock axios, verify correct endpoints called\n   - Error handling for network failures\n\n### E2E Tests (Maestro)\n\n1. **Water Logging Flow** (`e2e/tests/water/log_water.yaml`):\n   - Open water screen from dashboard\n   - Tap 250ml quick add\n   - Verify progress updates\n   - Add custom amount\n   - Verify total increases\n\n2. **Water Goal Flow** (`e2e/tests/water/water_goal.yaml`):\n   - Open water settings\n   - Change goal to 3000ml\n   - Verify home screen reflects new goal\n\n### Manual Testing Checklist\n\n- [ ] Progress ring fills smoothly\n- [ ] Quick add haptic feedback works\n- [ ] Goal completion celebration triggers\n- [ ] Entries appear in correct order (newest first)\n- [ ] Swipe to delete works\n- [ ] Custom amount keyboard is numeric\n- [ ] Unit conversion displays correctly\n- [ ] Offline logging queues correctly\n- [ ] HealthKit sync (if implemented)",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Prisma schema and create water service backend layer",
            "description": "Add water goal fields to User model, create WaterService class following mealService.ts pattern with CRUD operations and daily/weekly summary methods",
            "dependencies": [],
            "details": "1. Update `server/prisma/schema.prisma` User model:\n   - Add `goalWaterMl Int @default(2500)` (daily water goal in ml, default 2.5L)\n   - Add `waterReminderEnabled Boolean @default(false)`\n   - Add `waterReminderInterval Int?` (minutes between reminders)\n\n2. Run database migration:\n   - `cd server && npm run db:generate`\n   - `cd server && npm run db:push`\n\n3. Create `server/src/services/waterService.ts` following mealService.ts pattern:\n   - Class-based singleton export: `export class WaterService` + `export const waterService = new WaterService()`\n   - Methods:\n     - `createWaterIntake(userId: string, data: { amount: number, recordedAt?: Date })` - Create entry\n     - `getWaterIntakes(userId: string, date?: Date)` - Get entries for day using getDayBoundaries\n     - `deleteWaterIntake(userId: string, entryId: string)` - Delete entry with ownership check\n     - `getDailySummary(userId: string, date?: Date)` - Return { totalMl, goalMl, percentComplete, entries }\n     - `getWeeklySummary(userId: string)` - Last 7 days with averages using getDaysAgo(WEEK_IN_DAYS)\n     - `updateWaterGoal(userId: string, goalMl: number)` - Update user.goalWaterMl\n   - Use prisma for database access\n   - Use getDayBoundaries, getDaysAgo from utils/dateHelpers\n   - Use USER_GOALS_SELECT_FIELDS pattern for user data\n   - Follow exact structure of mealService.ts",
            "status": "pending",
            "testStrategy": "Unit tests in `server/src/__tests__/water.test.ts`:\n- Test createWaterIntake creates entry correctly\n- Test amount validation (min 1ml, max 5000ml per entry)\n- Test getDailySummary calculates total and percentage\n- Test getWaterIntakes filters by date boundaries\n- Test deleteWaterIntake ownership verification\n- Test updateWaterGoal updates user field\n- Test getWeeklySummary returns 7-day averages\n- Mock prisma.waterIntake and prisma.user\n- Use existing test utilities from __tests__/setup.ts",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create water controller with Zod validation and API routes",
            "description": "Implement WaterController class following mealController.ts pattern with withErrorHandling wrapper, create Zod schemas, and set up Express routes",
            "dependencies": [
              1
            ],
            "details": "1. Add Zod schemas to `server/src/validation/schemas.ts`:\n   ```typescript\n   export const createWaterIntakeSchema = z.object({\n     amount: z.number().min(1).max(5000),\n     recordedAt: datetimeSchema.optional(),\n   });\n   export const updateWaterGoalSchema = z.object({\n     goalMl: z.number().min(500).max(10000),\n   });\n   ```\n\n2. Create `server/src/controllers/waterController.ts` following mealController.ts pattern:\n   - Import waterService, requireAuth, withErrorHandling, ErrorHandlers\n   - Class-based with singleton export\n   - Methods:\n     - `createWaterIntake` - withErrorHandling, requireAuth, validate with createWaterIntakeSchema\n     - `getWaterIntakes` - Get entries for date (query param)\n     - `deleteWaterIntake` - ErrorHandlers.withNotFound for 404 handling\n     - `getDailySummary` - Optional date query param\n     - `getWeeklySummary` - No params\n     - `updateWaterGoal` - Validate with updateWaterGoalSchema\n   - Use HTTP_STATUS constants (OK=200, CREATED=201)\n   - Use parseOptionalDate for date query params\n\n3. Create `server/src/routes/waterRoutes.ts` following mealRoutes.ts:\n   - Apply authenticate middleware to all routes\n   - Routes:\n     - `POST /` - createWaterIntake\n     - `GET /` - getWaterIntakes\n     - `GET /summary/daily` - getDailySummary\n     - `GET /summary/weekly` - getWeeklySummary\n     - `DELETE /:id` - deleteWaterIntake\n     - `PUT /goal` - updateWaterGoal (user goal, not entry-specific)\n   - Export default router\n\n4. Register routes in `server/src/index.ts`:\n   - Import waterRoutes\n   - Add `app.use('/api/water', waterRoutes)`",
            "status": "pending",
            "testStrategy": "Integration tests in `server/src/__tests__/water.test.ts`:\n- Test POST /api/water creates entry and returns 201\n- Test POST /api/water validates amount (rejects -1, 0, 10000)\n- Test GET /api/water?date=YYYY-MM-DD returns filtered entries\n- Test GET /api/water/summary/daily returns correct totals and percentages\n- Test DELETE /api/water/:id removes entry and returns 200\n- Test DELETE /api/water/:id returns 404 for non-existent entry\n- Test PUT /api/water/goal updates user.goalWaterMl\n- Test all routes require authentication (401 without token)\n- Use supertest for HTTP testing\n- Use createTestUser, createTestToken from __tests__/setup.ts",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create mobile water API client and TypeScript types",
            "description": "Implement waterApi client following mealsApi pattern with typed responses, add WaterIntake and summary types to lib/types",
            "dependencies": [
              2
            ],
            "details": "1. Add TypeScript types to `lib/types/index.ts`:\n   ```typescript\n   export interface WaterIntake {\n     id: string;\n     userId: string;\n     amount: number;  // ml\n     recordedAt: string;\n     createdAt: string;\n   }\n   export interface DailyWaterSummary {\n     totalMl: number;\n     goalMl: number;\n     percentComplete: number;\n     entries: WaterIntake[];\n   }\n   export interface WeeklyWaterSummary {\n     date: string;\n     totalMl: number;\n     goalMl: number;\n   }\n   ```\n\n2. Create `lib/api/water.ts` following mealsApi pattern:\n   - Import api from './client'\n   - Export waterApi object with methods:\n     - `createWaterIntake(amount: number, recordedAt?: string): Promise<WaterIntake>`\n     - `getWaterIntakes(date?: Date): Promise<WaterIntake[]>`\n     - `deleteWaterIntake(id: string): Promise<void>`\n     - `getDailySummary(date?: Date): Promise<DailyWaterSummary>`\n     - `getWeeklySummary(): Promise<WeeklyWaterSummary[]>`\n     - `updateWaterGoal(goalMl: number): Promise<User>`\n   - Use api.post, api.get, api.delete, api.put\n   - Convert Date to ISO string for params\n   - Return typed responses: `api.get<WaterIntake[]>(...)`\n   - Follow exact structure of mealsApi.ts",
            "status": "pending",
            "testStrategy": "Mobile API client tests:\n- Mock axios responses\n- Test createWaterIntake sends correct POST data\n- Test getWaterIntakes converts date to ISO string\n- Test getDailySummary returns typed DailyWaterSummary\n- Test deleteWaterIntake sends DELETE to correct endpoint\n- Test updateWaterGoal sends PUT with goalMl\n- Test error handling (network errors, 400, 401, 404)\n- Use Jest mock functions",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build main water tracking screen with progress ring and quick-add UI",
            "description": "Create app/water.tsx screen with circular progress visualization, quick-add buttons for common amounts, today's log list with swipeable cards, and weekly chart",
            "dependencies": [
              3
            ],
            "details": "1. Create `app/water.tsx` following app/activity/index.tsx screen pattern:\n   - Import waterApi, useAuth, useRouter, colors, spacing, typography\n   - State: dailySummary, isLoading, refreshing\n   - useFocusEffect to load data on screen focus\n   - SafeAreaView with ScrollView and RefreshControl\n\n2. Circular Progress Ring component:\n   - SVG-based ring (react-native-svg) showing totalMl/goalMl\n   - Center text: \"1500 / 2500 ml\" and \"60%\"\n   - Color gradient: colors.secondary.main → colors.status.success as progress increases\n   - Animated using Animated API (spring animation on update)\n   - Celebration animation when goal reached (confetti or scale pulse)\n\n3. Quick Add Buttons Grid (4x2 layout):\n   - Common amounts: 150ml, 250ml, 500ml, 750ml\n   - Each button:\n     - TouchableOpacity with icon (water drop) and amount label\n     - onPress: Call waterApi.createWaterIntake(amount), reload summary\n     - Ripple effect on press\n     - backgroundColor: colors.background.elevated\n     - activeOpacity: 0.7\n   - Custom amount button: Opens modal (handled in subtask 5)\n\n4. Today's Log Section:\n   - ScrollView with swipeable cards (use SwipeableWaterCard pattern like SwipeableMealCard)\n   - Each entry shows:\n     - Time (formatTime from utils/formatters)\n     - Amount (\"250 ml\")\n     - Delete button on swipe\n   - Empty state: \"No water logged today. Tap a quick-add button to start!\"\n   - List reverse chronological (latest first)\n\n5. Weekly Overview Chart:\n   - Bar chart component (react-native-chart-kit or custom with react-native-svg)\n   - Load getWeeklySummary data\n   - Show last 7 days with goal line overlay\n   - Tap day to navigate to that day's detail\n   - X-axis: Day names (M, T, W, T, F, S, S)\n   - Y-axis: ml (0 to max of goal+500)\n\n6. Floating Action Button (FAB):\n   - Position: absolute, bottom: 20, right: 20\n   - Opens water-settings screen\n   - Icon: settings gear\n   - backgroundColor: colors.primary.main\n\n7. Register screen in `app/_layout.tsx`:\n   - Add 'water' route with headerShown: false\n   - Add 'water-settings' route with headerShown: false",
            "status": "pending",
            "testStrategy": "Component tests:\n- Test screen loads and displays daily summary\n- Test quick-add buttons call createWaterIntake with correct amounts\n- Test progress ring shows correct percentage\n- Test swipe-to-delete removes entry\n- Test weekly chart displays 7 days\n- Test empty state when no entries\n- Test loading and error states\n- Test refresh control reloads data\n- Mock waterApi responses\n- Use react-native-testing-library",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create water goal settings screen and dashboard widget integration",
            "description": "Build water-settings.tsx for goal management and reminders, create WaterWidget component for dashboard, integrate into app/(tabs)/index.tsx",
            "dependencies": [
              4
            ],
            "details": "1. Create `app/water-settings.tsx`:\n   - Daily goal input:\n     - Slider (500ml - 5000ml) with live preview\n     - Preset buttons: 2000ml, 2500ml, 3000ml, 3500ml, 4000ml\n     - Save button calls waterApi.updateWaterGoal\n   - Goal calculator (optional):\n     - Input: body weight (kg)\n     - Formula: weight * 33ml\n     - Activity level multiplier: sedentary (1.0), active (1.2), very active (1.5)\n     - Climate adjustment: +500ml for hot/dry\n   - Reminder settings:\n     - Toggle: Enable reminders\n     - Interval picker: 30min, 1hr, 1.5hr, 2hr\n     - Quiet hours: Start time, End time (future: integrate with Task 40 push notifications)\n   - Save button updates User model fields\n   - Follow existing settings screen patterns\n\n2. Create `lib/components/WaterWidget.tsx` for dashboard:\n   - Compact widget (height: ~100px)\n   - Circular mini progress ring (size: 60px)\n   - Text: \"1500 / 2500 ml\"\n   - Quick add button: \"+250ml\" (most common amount)\n   - onPress (on widget): Navigate to /water screen using router.push('/water')\n   - onPress (on quick add): Call waterApi.createWaterIntake(250), update widget\n   - Style: colors.background.tertiary card with borderRadius.md\n   - Follow existing widget patterns from dashboard\n\n3. Integrate WaterWidget into `app/(tabs)/index.tsx`:\n   - Add import: `import { WaterWidget } from '@/lib/components/WaterWidget'`\n   - Insert widget after meals summary section, before health metrics\n   - Load water summary in parallel with meals/supplements (add to Promise.all)\n   - Pass summary data to WaterWidget as prop\n   - Widget should blend seamlessly with existing dashboard cards\n\n4. Add navigation link in profile settings:\n   - In `app/(tabs)/profile.tsx`\n   - Add row: \"Water Goal & Reminders\" → links to /water-settings\n   - Icon: water drop\n   - Follow existing settings row pattern\n\n5. Accessibility:\n   - All buttons have accessibilityLabel\n   - Progress ring announces \"Water tracking, 1500 milliliters of 2500 milliliter goal, 60 percent complete\"\n   - Quick add buttons: \"Add 250 milliliters\"\n   - VoiceOver support for slider and inputs",
            "status": "pending",
            "testStrategy": "Component and integration tests:\n- Test water-settings screen loads current goal from user\n- Test slider updates goal preview\n- Test preset buttons set correct values\n- Test save button calls updateWaterGoal API\n- Test goal calculator computes correctly\n- Test WaterWidget displays current progress\n- Test WaterWidget quick-add updates summary\n- Test WaterWidget navigation to /water screen\n- Test dashboard integration loads water data\n- Test accessibility labels with screen reader\n- Mock waterApi and user context\n- Use react-native-testing-library",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-26T11:45:36.293Z"
      },
      {
        "id": 43,
        "title": "Weight Tracking Mobile UI with Progress Visualization and Goal Tracking",
        "description": "Implement complete weight tracking functionality including mobile UI screens, backend API endpoints, weight trend visualization, goal progress tracking, and body composition integration. The WeightRecord Prisma model exists but has no API or UI. User model has currentWeight and goalWeight fields that need integration.",
        "details": "## Current State Analysis\n\n### Existing Infrastructure:\n- **Prisma Model** (`server/prisma/schema.prisma` lines 132-142):\n  ```prisma\n  model WeightRecord {\n    id        String   @id @default(cuid())\n    userId    String\n    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n    weight    Float    // in kg\n    recordedAt DateTime @default(now())\n    createdAt DateTime @default(now())\n    @@index([userId, recordedAt])\n  }\n  ```\n- **User Model Fields**:\n  - `currentWeight Float?` - Current weight\n  - `goalWeight Float?` - Target weight\n  - `height Float?` - For BMI calculation\n  - `weightRecords WeightRecord[]` - Relation\n- **NO backend API endpoints** for weight tracking\n- **NO mobile UI screens** for weight tracking\n\n### Required Schema Updates\n\nAdd to WeightRecord model:\n```prisma\nmodel WeightRecord {\n  // ... existing fields ...\n  \n  // Optional body composition data (from smart scales)\n  bodyFatPercentage  Float?\n  muscleMass         Float?  // kg\n  boneMass           Float?  // kg\n  waterPercentage    Float?\n  visceralFat        Float?  // level 1-60\n  \n  // Source tracking\n  source             String  @default(\"manual\") // \"manual\", \"apple_health\", \"withings\", \"fitbit\"\n  sourceId           String?\n  \n  // Notes\n  notes              String?\n  \n  @@unique([userId, recordedAt, source]) // Prevent duplicates from same source\n}\n```\n\nAdd to User model:\n```prisma\n// Weight preferences\nweightUnit          String   @default(\"kg\")  // \"kg\" or \"lb\"\nweightGoalType      WeightGoalType @default(MAINTAIN)\nweightGoalPace      Float?   // kg per week (0.25, 0.5, 0.75, 1.0)\nweightGoalStartDate DateTime?\nweightGoalStartWeight Float?\n```\n\nAdd enum:\n```prisma\nenum WeightGoalType {\n  LOSE\n  GAIN\n  MAINTAIN\n}\n```\n\n## Backend API Implementation\n\n### 1. Weight Service (`server/src/services/weightService.ts`)\n\n```typescript\ninterface WeightRecordInput {\n  weight: number;           // kg\n  recordedAt?: Date;\n  bodyFatPercentage?: number;\n  muscleMass?: number;\n  boneMass?: number;\n  waterPercentage?: number;\n  visceralFat?: number;\n  source?: string;\n  notes?: string;\n}\n\ninterface WeightTrend {\n  date: string;\n  weight: number;\n  movingAverage7d: number;\n  movingAverage30d: number;\n}\n\ninterface WeightProgress {\n  currentWeight: number;\n  goalWeight: number;\n  startWeight: number;\n  weightLost: number;        // or gained if positive\n  percentComplete: number;\n  projectedGoalDate: Date | null;\n  weeklyChange: number;\n  monthlyChange: number;\n  trend: 'losing' | 'gaining' | 'maintaining';\n}\n\nclass WeightService {\n  // CRUD operations\n  async createWeightRecord(userId: string, data: WeightRecordInput): Promise<WeightRecord>;\n  async getWeightRecords(userId: string, startDate: Date, endDate: Date): Promise<WeightRecord[]>;\n  async getLatestWeight(userId: string): Promise<WeightRecord | null>;\n  async updateWeightRecord(userId: string, recordId: string, data: Partial<WeightRecordInput>): Promise<WeightRecord>;\n  async deleteWeightRecord(userId: string, recordId: string): Promise<void>;\n  \n  // Analytics\n  async getWeightTrends(userId: string, period: 'month' | '3months' | '6months' | 'year' | 'all'): Promise<WeightTrend[]>;\n  async getWeightProgress(userId: string): Promise<WeightProgress>;\n  async getWeightStats(userId: string): Promise<WeightStats>;\n  \n  // Goal management\n  async setWeightGoal(userId: string, goalWeight: number, goalType: WeightGoalType, pace?: number): Promise<User>;\n  async updateCurrentWeight(userId: string, weight: number): Promise<User>;\n  \n  // Body composition trends (if data available)\n  async getBodyCompositionTrends(userId: string, period: string): Promise<BodyCompositionTrend[]>;\n}\n```\n\n### 2. Weight Controller (`server/src/controllers/weightController.ts`)\n\nEndpoints:\n- `POST /api/weight` - Log weight entry\n- `GET /api/weight/latest` - Get most recent weight\n- `GET /api/weight?startDate=&endDate=` - Get weight records\n- `GET /api/weight/:id` - Get specific record\n- `PUT /api/weight/:id` - Update record\n- `DELETE /api/weight/:id` - Delete record\n- `GET /api/weight/trends?period=` - Get weight trends with moving averages\n- `GET /api/weight/progress` - Get goal progress stats\n- `GET /api/weight/stats` - Get statistics (min, max, avg, change)\n- `PUT /api/user/weight-goal` - Set/update weight goal\n- `GET /api/weight/body-composition` - Body composition trends\n\n### 3. Validation Schemas (`server/src/validation/schemas.ts`)\n\n```typescript\nexport const createWeightRecordSchema = z.object({\n  weight: z.number().min(20).max(500), // 20kg to 500kg\n  recordedAt: z.string().datetime().optional(),\n  bodyFatPercentage: z.number().min(1).max(70).optional(),\n  muscleMass: z.number().min(10).max(150).optional(),\n  boneMass: z.number().min(1).max(10).optional(),\n  waterPercentage: z.number().min(20).max(80).optional(),\n  visceralFat: z.number().min(1).max(60).optional(),\n  notes: z.string().max(500).optional(),\n});\n\nexport const weightGoalSchema = z.object({\n  goalWeight: z.number().min(30).max(300),\n  goalType: z.enum(['LOSE', 'GAIN', 'MAINTAIN']),\n  pace: z.number().min(0.1).max(1.5).optional(), // kg per week\n});\n\nexport const weightTrendsQuerySchema = z.object({\n  period: z.enum(['month', '3months', '6months', 'year', 'all']),\n});\n```\n\n## Mobile App Implementation\n\n### 1. API Client (`lib/api/weight.ts`)\n\n```typescript\nexport const weightApi = {\n  logWeight: (data: WeightRecordInput) => \n    apiClient.post('/weight', data),\n  \n  getLatest: () => \n    apiClient.get('/weight/latest'),\n  \n  getRecords: (startDate: string, endDate: string) => \n    apiClient.get('/weight', { params: { startDate, endDate } }),\n  \n  getRecord: (id: string) => \n    apiClient.get(`/weight/${id}`),\n  \n  updateRecord: (id: string, data: Partial<WeightRecordInput>) => \n    apiClient.put(`/weight/${id}`, data),\n  \n  deleteRecord: (id: string) => \n    apiClient.delete(`/weight/${id}`),\n  \n  getTrends: (period: string) => \n    apiClient.get('/weight/trends', { params: { period } }),\n  \n  getProgress: () => \n    apiClient.get('/weight/progress'),\n  \n  setGoal: (goalWeight: number, goalType: string, pace?: number) => \n    apiClient.put('/user/weight-goal', { goalWeight, goalType, pace }),\n  \n  getBodyComposition: (period: string) => \n    apiClient.get('/weight/body-composition', { params: { period } }),\n};\n```\n\n### 2. Weight Tracking Screen (`app/weight/index.tsx`)\n\nMain screen layout:\n\n**Header Section:**\n- Current weight (large, prominent)\n- Change from last entry (+/- X.X kg)\n- Last weighed date\n\n**Progress Card (if goal set):**\n- Visual progress bar: Start → Current → Goal\n- \"X kg to go\" or \"Goal reached!\"\n- Projected completion date\n- Weekly rate indicator\n\n**Quick Log Button:**\n- Floating action button or prominent CTA\n- Opens weight entry modal\n\n**Trend Chart:**\n- Line chart with:\n  - Raw data points\n  - 7-day moving average line (smoothed trend)\n  - 30-day moving average line (long-term trend)\n  - Goal line (horizontal target)\n- Period selector: 1M, 3M, 6M, 1Y, All\n- Pinch to zoom, pan to scroll\n- Tap point to see details\n\n**History Section:**\n- List of recent entries\n- Each shows: date, weight, change from previous\n- Body composition data if available\n- Swipe to delete\n\n**Stats Card:**\n- Lowest weight (with date)\n- Highest weight (with date)\n- Average weight (selected period)\n- Total change (selected period)\n\n### 3. Weight Entry Modal (`lib/components/WeightEntryModal.tsx`)\n\n- Large numeric input for weight\n- Unit toggle (kg/lb) with instant conversion\n- Date/time picker (defaults to now)\n- Optional body composition fields (expandable):\n  - Body fat %\n  - Muscle mass\n  - Water %\n- Notes field\n- Save button with validation\n\n**Smart Features:**\n- Pre-fill with last weight for quick increment/decrement\n- +/- 0.1kg buttons for fine adjustment\n- Haptic feedback on changes\n\n### 4. Weight Goal Setup (`app/weight/goal.tsx`)\n\nStep-by-step wizard:\n\n**Step 1: Current Status**\n- Display current weight\n- Enter if not set\n\n**Step 2: Goal Type**\n- Lose weight (with icon)\n- Gain weight (with icon)\n- Maintain weight (with icon)\n\n**Step 3: Target Weight**\n- Slider or numeric input\n- Shows BMI at target (if height set)\n- Healthy range indicator\n\n**Step 4: Timeline (for lose/gain)**\n- Pace selector: Slow (0.25kg/wk), Moderate (0.5kg/wk), Fast (0.75kg/wk), Aggressive (1kg/wk)\n- Projected completion date shown\n- Calorie adjustment recommendation\n\n**Step 5: Confirmation**\n- Summary of goal\n- Daily calorie target (calculated)\n- \"Set Goal\" button\n\n### 5. Body Composition View (`app/weight/composition.tsx`)\n\nFor users with smart scale data:\n- Body fat % trend chart\n- Muscle mass trend chart\n- Water % trend chart\n- Visceral fat level\n- Comparison cards: Current vs 30 days ago\n\n### 6. Weight Widget (`lib/components/WeightWidget.tsx`)\n\nDashboard widget:\n- Current weight\n- Change arrow (up/down)\n- Mini sparkline of last 7 entries\n- \"Log Weight\" quick action\n\n## Unit Conversion System\n\n```typescript\n// lib/utils/weightConversions.ts\nexport const WEIGHT_CONVERSIONS = {\n  kg_to_lb: 2.20462,\n  lb_to_kg: 0.453592,\n};\n\nexport const convertWeight = (value: number, from: 'kg' | 'lb', to: 'kg' | 'lb'): number => {\n  if (from === to) return value;\n  return from === 'kg' ? value * WEIGHT_CONVERSIONS.kg_to_lb : value * WEIGHT_CONVERSIONS.lb_to_kg;\n};\n\n// Always store in kg, display in user's preference\nexport const formatWeight = (kg: number, unit: 'kg' | 'lb'): string => {\n  const value = unit === 'kg' ? kg : convertWeight(kg, 'kg', 'lb');\n  return `${value.toFixed(1)} ${unit}`;\n};\n```\n\n## BMI Calculation\n\n```typescript\n// lib/utils/bmi.ts\nexport const calculateBMI = (weightKg: number, heightCm: number): number => {\n  const heightM = heightCm / 100;\n  return weightKg / (heightM * heightM);\n};\n\nexport const getBMICategory = (bmi: number): string => {\n  if (bmi < 18.5) return 'Underweight';\n  if (bmi < 25) return 'Normal';\n  if (bmi < 30) return 'Overweight';\n  return 'Obese';\n};\n\nexport const getHealthyWeightRange = (heightCm: number): { min: number; max: number } => {\n  const heightM = heightCm / 100;\n  return {\n    min: 18.5 * heightM * heightM,\n    max: 24.9 * heightM * heightM,\n  };\n};\n```\n\n## Integration Points\n\n### 1. Dashboard (`app/(tabs)/index.tsx`):\n```tsx\n<WeightWidget \n  currentWeight={user.currentWeight}\n  goalWeight={user.goalWeight}\n  onLogPress={() => setShowWeightModal(true)}\n  onPress={() => router.push('/weight')}\n/>\n```\n\n### 2. Profile Settings:\n- Weight goal link in profile\n- Unit preference (kg/lb)\n- Connect smart scale option\n\n### 3. HealthKit Integration (Task 5):\n- Read weight from Apple Health (HKQuantityTypeIdentifierBodyMass)\n- Read body fat % (HKQuantityTypeIdentifierBodyFatPercentage)\n- Read lean body mass (HKQuantityTypeIdentifierLeanBodyMass)\n- Write logged weights to HealthKit\n- Deduplicate entries by source\n\n### 4. ML Insights (Task 8):\n- Correlate weight trends with:\n  - Calorie intake patterns\n  - Macronutrient ratios\n  - Exercise frequency\n  - Sleep quality\n- Generate insights: \"You lose more weight in weeks with 4+ workouts\"\n\n### 5. Weekly Reports (planned):\n- Include weight change in weekly summary\n- Progress toward goal percentage\n\n## Chart Implementation\n\nUse react-native-chart-kit (already installed) or Victory Native:\n\n```typescript\n// Weight trend chart data preparation\nconst prepareChartData = (records: WeightRecord[], showMovingAverage: boolean) => {\n  const sortedRecords = records.sort((a, b) => \n    new Date(a.recordedAt).getTime() - new Date(b.recordedAt).getTime()\n  );\n  \n  const labels = sortedRecords.map(r => format(new Date(r.recordedAt), 'MMM d'));\n  const data = sortedRecords.map(r => r.weight);\n  \n  // Calculate 7-day moving average\n  const movingAvg7d = data.map((_, i) => {\n    const start = Math.max(0, i - 6);\n    const slice = data.slice(start, i + 1);\n    return slice.reduce((a, b) => a + b, 0) / slice.length;\n  });\n  \n  return { labels, datasets: [{ data }, { data: movingAvg7d }] };\n};\n```\n\n## Design Specifications\n\n### Colors (extend `lib/theme/colors.ts`):\n```typescript\nweight: {\n  losing: '#10B981',      // Green - losing weight (toward goal)\n  gaining: '#EF4444',     // Red - gaining when trying to lose\n  maintaining: '#6B7280', // Gray - stable\n  goalLine: '#8B5CF6',    // Purple - goal target line\n  movingAverage: '#F59E0B', // Amber - trend line\n}\n```\n\n### Animations:\n- Weight change animates from old → new value\n- Chart draws progressively on load\n- Progress bar fills with spring animation\n- Entry deletion slides out\n\n## Error Handling\n\n- Network error: Cache locally, sync when online\n- Invalid weight: Show inline validation (e.g., \"Weight must be between 20-500 kg\")\n- Duplicate entry for date: Ask to update or add new\n- Smart scale sync errors: Show status, offer manual entry",
        "testStrategy": "## Testing Strategy\n\n### Backend Unit Tests (`server/src/__tests__/weight.test.ts`)\n\n1. **Service Tests**:\n   - createWeightRecord: Creates entry and updates user.currentWeight\n   - createWeightRecord: Validates weight bounds\n   - createWeightRecord: Handles body composition data\n   - getWeightTrends: Calculates moving averages correctly\n   - getWeightProgress: Returns correct progress percentage\n   - getWeightProgress: Handles edge cases (no goal, goal reached)\n   - setWeightGoal: Updates user goal fields\n   - deleteWeightRecord: Only owner can delete\n\n2. **Controller Tests**:\n   - POST /api/weight: 201 with valid data\n   - POST /api/weight: 400 with invalid weight\n   - GET /api/weight/trends: Returns correct period data\n   - GET /api/weight/progress: Calculates progress correctly\n   - PUT /api/user/weight-goal: Updates goal\n\n3. **Integration Tests**:\n   - Log multiple weights → Verify trends calculated correctly\n   - Set goal → Log weights → Verify progress updates\n\n### Mobile Tests\n\n1. **Component Tests**:\n   - WeightWidget: Displays current weight and change\n   - WeightEntryModal: Validates input, converts units\n   - WeightChart: Renders with various data sizes\n\n2. **Screen Tests** (`__tests__/screens/WeightScreen.test.tsx`):\n   - Loads latest weight on mount\n   - Chart renders with trend data\n   - Entry modal opens and saves\n   - Unit toggle converts display\n   - Goal progress shows correctly\n\n3. **Utility Tests**:\n   - Unit conversions: kg ↔ lb\n   - BMI calculation\n   - Moving average calculation\n\n### E2E Tests (Maestro)\n\n1. **Weight Logging Flow**:\n   - Open weight screen\n   - Tap log weight\n   - Enter weight\n   - Verify history updates\n   - Verify chart updates\n\n2. **Goal Setting Flow**:\n   - Navigate to goal setup\n   - Complete wizard\n   - Verify goal appears on main screen\n\n### Manual Testing\n\n- [ ] Weight displays in correct unit\n- [ ] Unit toggle converts correctly\n- [ ] Chart is scrollable/zoomable\n- [ ] Moving average line is smooth\n- [ ] Goal line shows at correct position\n- [ ] Progress percentage is accurate\n- [ ] Body composition fields save correctly\n- [ ] HealthKit sync works (if connected)",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement backend weight service, controller, validation schemas, and API routes",
            "description": "Create WeightService class with CRUD operations, trend analysis, goal progress calculations, and BMI utilities. Implement WeightController with error handling and Zod validation. Add weight-specific validation schemas and register routes in Express app.",
            "dependencies": [],
            "details": "FILES TO CREATE:\n- server/src/services/weightService.ts: Class-based service with methods:\n  - createWeightRecord(userId, data): Creates record and syncs User.currentWeight\n  - getWeightRecords(userId, startDate, endDate): Fetch records with date range\n  - getLatestWeight(userId): Get most recent entry\n  - updateWeightRecord(userId, recordId, data): Update existing record\n  - deleteWeightRecord(userId, recordId): Delete record\n  - getWeightTrends(userId, period): Calculate 7-day and 30-day moving averages\n  - getWeightProgress(userId): Calculate progress toward goalWeight (current vs goal vs start, percent complete, weekly/monthly rate of change, projected date)\n  - getWeightStats(userId): Min, max, average, total change\n  - setWeightGoal(userId, goalWeight): Update User.goalWeight\n  - calculateBMI(weightKg, heightCm): BMI calculation utility\n  - getHealthyWeightRange(heightCm): Return {min, max} for BMI 18.5-24.9\n\n- server/src/controllers/weightController.ts: Controller methods using withErrorHandling:\n  - createWeightRecord: POST /weight (validates with createWeightRecordSchema)\n  - getLatestWeight: GET /weight/latest\n  - getWeightRecords: GET /weight?startDate=&endDate=\n  - getWeightRecord: GET /weight/:id (use ErrorHandlers.withNotFound)\n  - updateWeightRecord: PUT /weight/:id\n  - deleteWeightRecord: DELETE /weight/:id (use ErrorHandlers.withNotFound)\n  - getWeightTrends: GET /weight/trends?period= (validates period enum)\n  - getWeightProgress: GET /weight/progress\n  - getWeightStats: GET /weight/stats\n  - setWeightGoal: PUT /user/weight-goal\n\n- server/src/validation/schemas.ts: Add schemas:\n  - createWeightRecordSchema: weight (20-500kg), recordedAt (optional datetime), notes (optional, max 500 chars)\n  - updateWeightRecordSchema: Partial of create schema\n  - weightGoalSchema: goalWeight (30-300kg)\n  - weightTrendsQuerySchema: period enum ('week' | 'month' | '3months' | '6months' | 'year' | 'all')\n\n- server/src/routes/weightRoutes.ts: Express router with authenticate middleware, register all endpoints\n\n- server/src/index.ts: Register weight routes as app.use('/api/weight', weightRoutes)\n\nFOLLOW EXISTING PATTERNS:\n- Service: Export singleton instance (export const weightService = new WeightService())\n- Controller: Class with methods using withErrorHandling, requireAuth\n- All methods must have zero 'any' types, use proper Prisma types\n- Use constants from config/constants.ts (HTTP_STATUS, ERROR_MESSAGES)\n- Use dateHelpers for date parsing\n- Service methods throw Error, controller catches with withErrorHandling\n- Update User.currentWeight in transaction when creating WeightRecord\n\nBMI CALCULATION:\n- Formula: weight(kg) / (height(m)^2)\n- Categories: <18.5 underweight, 18.5-24.9 normal, 25-29.9 overweight, >=30 obese\n- Healthy range: 18.5 * height(m)^2 to 24.9 * height(m)^2\n\nTREND ANALYSIS:\n- 7-day moving average: Average of last 7 data points\n- 30-day moving average: Average of last 30 data points\n- Weekly change: (current - weight_7_days_ago) / 1\n- Monthly change: (current - weight_30_days_ago) / 1\n- Trend direction: 'losing' if weekly change < -0.1, 'gaining' if > +0.1, else 'maintaining'\n\nGOAL PROGRESS:\n- Start weight: User.currentWeight when goal was set (or earliest WeightRecord if not tracked)\n- Current weight: Latest WeightRecord.weight\n- Goal weight: User.goalWeight\n- Weight lost/gained: startWeight - currentWeight (negative = gained)\n- Percent complete: ((startWeight - currentWeight) / (startWeight - goalWeight)) * 100\n- Projected goal date: Based on weekly rate of change, calculate weeks remaining\n\nTESTING REQUIREMENTS:\n- Unit tests in server/src/__tests__/weight.test.ts\n- Test service methods: CRUD, trends, progress, BMI\n- Test validation: invalid weights, date formats\n- Test User.currentWeight sync on create\n- Test goal progress calculation edge cases (no goal, already at goal)\n- Follow test patterns from __tests__/meal.test.ts",
            "status": "pending",
            "testStrategy": "Unit tests covering: createWeightRecord syncs User.currentWeight, weight validation (bounds 20-500kg), getWeightTrends calculates moving averages correctly, getWeightProgress calculates percent complete and projected date, BMI calculation accuracy, goal progress edge cases (no records, already at goal), CRUD operations with proper auth",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create mobile API client with TypeScript types for weight tracking",
            "description": "Add weight-related TypeScript interfaces to lib/types/index.ts and create weightApi client in lib/api/weight.ts following the object-based pattern used in mealsApi.",
            "dependencies": [
              1
            ],
            "details": "FILES TO CREATE/UPDATE:\n\n- lib/types/index.ts: Add interfaces:\n```typescript\nexport interface WeightRecord {\n  id: string;\n  userId: string;\n  weight: number;        // kg\n  recordedAt: string;    // ISO datetime\n  notes?: string;\n  createdAt: string;\n}\n\nexport interface CreateWeightRecordInput {\n  weight: number;        // kg\n  recordedAt?: string;   // ISO datetime, defaults to now\n  notes?: string;\n}\n\nexport interface WeightTrendDataPoint {\n  date: string;              // ISO date\n  weight: number;\n  movingAverage7d: number;   // 7-day moving average\n  movingAverage30d: number;  // 30-day moving average\n}\n\nexport interface WeightProgress {\n  currentWeight: number;\n  goalWeight: number;\n  startWeight: number;       // When goal was set\n  weightChange: number;      // Lost (negative) or gained (positive)\n  percentComplete: number;   // 0-100+\n  projectedGoalDate: string | null; // ISO date\n  weeklyChange: number;      // kg/week\n  monthlyChange: number;     // kg/month\n  trend: 'losing' | 'gaining' | 'maintaining';\n}\n\nexport interface WeightStats {\n  min: number;\n  max: number;\n  average: number;\n  totalChange: number;       // From first to latest record\n  recordCount: number;\n}\n\nexport interface WeightGoalInput {\n  goalWeight: number;        // kg\n}\n\nexport interface BMIInfo {\n  bmi: number;\n  category: 'underweight' | 'normal' | 'overweight' | 'obese';\n  healthyWeightRange: { min: number; max: number }; // kg\n}\n```\n\n- lib/api/weight.ts: Create API client following mealsApi pattern:\n```typescript\nimport api from './client';\nimport {\n  WeightRecord,\n  CreateWeightRecordInput,\n  WeightTrendDataPoint,\n  WeightProgress,\n  WeightStats,\n  WeightGoalInput,\n  BMIInfo,\n} from '../types';\n\nexport const weightApi = {\n  async createWeightRecord(data: CreateWeightRecordInput): Promise<WeightRecord> {\n    const response = await api.post<WeightRecord>('/weight', data);\n    return response.data;\n  },\n\n  async getLatestWeight(): Promise<WeightRecord | null> {\n    const response = await api.get<WeightRecord | null>('/weight/latest');\n    return response.data;\n  },\n\n  async getWeightRecords(startDate: string, endDate: string): Promise<WeightRecord[]> {\n    const response = await api.get<WeightRecord[]>('/weight', {\n      params: { startDate, endDate },\n    });\n    return response.data;\n  },\n\n  async getWeightRecord(id: string): Promise<WeightRecord> {\n    const response = await api.get<WeightRecord>(`/weight/${id}`);\n    return response.data;\n  },\n\n  async updateWeightRecord(\n    id: string,\n    data: Partial<CreateWeightRecordInput>\n  ): Promise<WeightRecord> {\n    const response = await api.put<WeightRecord>(`/weight/${id}`, data);\n    return response.data;\n  },\n\n  async deleteWeightRecord(id: string): Promise<void> {\n    await api.delete(`/weight/${id}`);\n  },\n\n  async getWeightTrends(\n    period: 'week' | 'month' | '3months' | '6months' | 'year' | 'all'\n  ): Promise<WeightTrendDataPoint[]> {\n    const response = await api.get<WeightTrendDataPoint[]>('/weight/trends', {\n      params: { period },\n    });\n    return response.data;\n  },\n\n  async getWeightProgress(): Promise<WeightProgress | null> {\n    const response = await api.get<WeightProgress | null>('/weight/progress');\n    return response.data;\n  },\n\n  async getWeightStats(): Promise<WeightStats> {\n    const response = await api.get<WeightStats>('/weight/stats');\n    return response.data;\n  },\n\n  async setWeightGoal(data: WeightGoalInput): Promise<void> {\n    await api.put('/user/weight-goal', data);\n  },\n\n  async calculateBMI(weightKg: number, heightCm: number): Promise<BMIInfo> {\n    const response = await api.get<BMIInfo>('/weight/bmi', {\n      params: { weightKg, heightCm },\n    });\n    return response.data;\n  },\n};\n```\n\nFOLLOW EXISTING PATTERNS:\n- Use api client from './client' (has JWT interceptor)\n- All dates as ISO strings for API communication\n- Proper TypeScript typing for all methods\n- Error handling via getErrorMessage in consuming components\n- Export as const object (not class)\n\nUNIT CONVERSION NOTES:\n- Backend stores weights in kg\n- Mobile can display in kg or lbs based on user preference\n- Conversion factors: 1 kg = 2.20462 lbs, 1 lb = 0.453592 kg\n- Always send kg to API, convert for display only\n\nTESTING:\n- Type-check with TypeScript compiler\n- Manual API integration tests with backend running\n- Error handling tests (network failures, 401, 404, validation errors)",
            "status": "pending",
            "testStrategy": "TypeScript compilation check (npx tsc --noEmit), manual integration tests with backend, test error handling for network failures and validation errors, verify all API methods match backend routes, test date/time ISO string conversions",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build weight tracking main screen with trend chart and history list",
            "description": "Create app/weight/index.tsx as the main weight tracking screen with header summary, progress card, trend line chart with moving averages, period selector, and swipeable history list following the pattern from health/[metricType].tsx.",
            "dependencies": [
              2
            ],
            "details": "FILE TO CREATE:\n\n- app/weight/index.tsx: Main weight tracking screen\n\nCOMPONENT STRUCTURE:\n\n```typescript\nimport { useState, useEffect, useCallback } from 'react';\nimport { View, Text, StyleSheet, ScrollView, TouchableOpacity, ActivityIndicator, RefreshControl } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport { Ionicons } from '@expo/vector-icons';\nimport { LineChart } from 'react-native-chart-kit';\nimport { weightApi } from '@/lib/api/weight';\nimport { WeightRecord, WeightTrendDataPoint, WeightProgress, WeightStats } from '@/lib/types';\nimport { SwipeableWeightCard } from '@/lib/components/SwipeableWeightCard'; // Create in subtask 4\nimport { showAlert } from '@/lib/utils/alert';\nimport { getErrorMessage } from '@/lib/utils/errorHandling';\nimport { colors, gradients, shadows, spacing, borderRadius, typography } from '@/lib/theme/colors';\nimport { useResponsive } from '@/hooks/useResponsive';\nimport { FORM_MAX_WIDTH } from '@/lib/responsive/breakpoints';\n\ntype DateRange = 'week' | 'month' | '3months' | '6months' | 'year' | 'all';\n\nexport default function WeightTrackingScreen() {\n  const router = useRouter();\n  const { isTablet, getSpacing, width: screenWidth } = useResponsive();\n  const responsiveSpacing = getSpacing();\n\n  const [trendData, setTrendData] = useState<WeightTrendDataPoint[]>([]);\n  const [progress, setProgress] = useState<WeightProgress | null>(null);\n  const [stats, setStats] = useState<WeightStats | null>(null);\n  const [recentRecords, setRecentRecords] = useState<WeightRecord[]>([]);\n  const [dateRange, setDateRange] = useState<DateRange>('month');\n  const [isLoading, setIsLoading] = useState(true);\n  const [refreshing, setRefreshing] = useState(false);\n  const [visibleEntriesCount, setVisibleEntriesCount] = useState(10);\n\n  const loadData = useCallback(async () => { /* Fetch trends, progress, stats, recent records */ });\n  const onRefresh = useCallback(async () => { /* Pull to refresh */ });\n  const handleDeleteRecord = async (id: string) => { /* Delete and reload */ };\n  const handleLoadMore = () => setVisibleEntriesCount(prev => prev + 10);\n\n  // ... implementation\n}\n```\n\nSCREEN SECTIONS:\n\n1. **HEADER SECTION** (sticky at top):\n   - LinearGradient background (gradients.primary)\n   - Title: \"Weight Tracking\"\n   - Current weight (large, bold): \"72.5 kg\"\n   - Change from last entry: \"+0.3 kg\" with up/down arrow icon (green if losing toward goal, red if gaining)\n   - Last weighed: \"Today\" or \"X days ago\"\n   - Settings icon (navigate to /weight/settings for goal setup)\n\n2. **PROGRESS CARD** (if User.goalWeight is set):\n   - Card with shadow\n   - Progress bar visualization:\n     - Three markers: Start (left) → Current (middle) → Goal (right)\n     - Filled bar showing progress\n   - \"X kg to go\" or \"Goal reached! 🎉\"\n   - Stats row:\n     - Weekly change: \"-0.5 kg/wk\"\n     - Percent complete: \"60% complete\"\n   - Projected completion: \"Estimated: Mar 15, 2025\" (if on track)\n   - Tap to navigate to /weight/goal for goal setup/editing\n\n3. **TREND CHART CARD**:\n   - Period selector buttons (week, month, 3months, 6months, year, all)\n   - LineChart from react-native-chart-kit:\n     - Dataset 1: Raw weight data points (color: colors.primary)\n     - Dataset 2: 7-day moving average (color: colors.amber, dashed)\n     - Dataset 3: 30-day moving average (color: colors.purple, dashed)\n     - Goal line (horizontal, color: colors.success, dashed)\n   - Chart config: responsive width (screenWidth - padding), height 220\n   - Y-axis: Weight in kg (user's unit preference)\n   - X-axis: Date labels (formatted)\n   - Tap data point to show details tooltip\n   - Empty state: \"No weight data yet. Add your first entry!\"\n\n4. **STATS CARD**:\n   - Grid layout (2 columns):\n     - Lowest: \"68.0 kg\" (with date)\n     - Highest: \"75.2 kg\" (with date)\n     - Average: \"71.5 kg\"\n     - Total change: \"-3.2 kg\"\n   - Styled with borders, icons, subtle backgrounds\n\n5. **HISTORY SECTION**:\n   - Title: \"Recent Entries\"\n   - List of SwipeableWeightCard components (create in subtask 4)\n   - Each card shows: date, weight, change from previous, notes\n   - Swipe left to delete (with confirmation)\n   - Tap to edit (navigate to /weight/edit/[id])\n   - Load more button at bottom if > 10 entries\n   - Empty state: \"No entries yet\"\n\n6. **FLOATING ACTION BUTTON (FAB)**:\n   - Fixed bottom-right position\n   - Icon: Ionicons \"add\" or \"scale\"\n   - Opens weight entry modal/screen: router.push('/weight/add')\n   - Styled with shadow, primary color gradient\n\nCHART DATA PREPARATION:\n```typescript\nconst prepareChartData = (data: WeightTrendDataPoint[], goalWeight?: number) => {\n  if (data.length === 0) return null;\n  \n  const labels = data.map(d => format(new Date(d.date), 'MMM d'));\n  const weights = data.map(d => d.weight);\n  const avg7d = data.map(d => d.movingAverage7d);\n  const avg30d = data.map(d => d.movingAverage30d);\n  const goalLine = goalWeight ? data.map(() => goalWeight) : undefined;\n  \n  return {\n    labels,\n    datasets: [\n      { data: weights, color: () => colors.primary, strokeWidth: 2 },\n      { data: avg7d, color: () => colors.amber, strokeWidth: 1.5, withDots: false },\n      { data: avg30d, color: () => colors.purple, strokeWidth: 1.5, withDots: false },\n      ...(goalLine ? [{ data: goalLine, color: () => colors.success, strokeWidth: 1, withDots: false }] : []),\n    ],\n  };\n};\n```\n\nRESPONSIVE DESIGN:\n- Use useResponsive hook for spacing, chart width\n- Tablet: 2-column layout for stats, wider chart\n- Phone: Single column, scrollable\n- Chart width calculation: screenWidth - (padding * 2) - (card padding * 2)\n- Max width on tablet: FORM_MAX_WIDTH\n\nERROR HANDLING:\n- Network errors: Show error message, retry button\n- Empty data: Friendly empty states with CTA to add first entry\n- Loading states: ActivityIndicator with shimmer effect\n\nANIMATIONS:\n- Pull-to-refresh with RefreshControl\n- Chart draws progressively on mount (built-in to react-native-chart-kit)\n- Card swipe delete animation\n- FAB scale animation on press\n\nACCESSIBILITY:\n- All touchables have accessibilityLabel\n- Chart has accessibilityLabel describing trend\n- Screen reader announces current weight and progress\n\nFOLLOW EXISTING PATTERNS:\n- Similar to app/health/[metricType].tsx structure\n- Use SafeAreaView from react-native-safe-area-context\n- Use colors, gradients, shadows from theme/colors.ts\n- Error handling with getErrorMessage utility\n- showAlert for confirmations and errors\n\nREGISTRATION:\n- Add to app/_layout.tsx with headerShown: false (custom header in component)\n- Add navigation from dashboard widget or profile screen",
            "status": "pending",
            "testStrategy": "Manual testing: verify chart renders with multiple data points, test period selector changes data, verify progress card calculations, test pull-to-refresh, test FAB navigation, verify empty states, test responsive layout on different screen sizes, verify accessibility labels, test swipe-to-delete functionality",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create weight entry modal, swipeable card component, and goal setup screen",
            "description": "Build reusable UI components: weight entry modal with numeric input and validation, swipeable weight record card for history lists, and goal setup wizard screen with step-by-step flow for setting weight goals.",
            "dependencies": [
              2
            ],
            "details": "FILES TO CREATE:\n\n1. **lib/components/WeightEntryModal.tsx** - Modal for adding/editing weight\n\nComponent structure:\n```typescript\nimport { useState } from 'react';\nimport { View, Text, TextInput, TouchableOpacity, Modal, StyleSheet, KeyboardAvoidingView, Platform } from 'react-native';\nimport { Ionicons } from '@expo/vector-icons';\nimport DateTimePicker from '@react-native-community/datetimepicker';\nimport { weightApi } from '@/lib/api/weight';\nimport { CreateWeightRecordInput, WeightRecord } from '@/lib/types';\nimport { showAlert } from '@/lib/utils/alert';\nimport { getErrorMessage } from '@/lib/utils/errorHandling';\nimport { colors, spacing, borderRadius, typography } from '@/lib/theme/colors';\n\ninterface WeightEntryModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onSaved: () => void;\n  initialData?: WeightRecord; // For editing existing record\n  lastWeight?: number;         // Pre-fill for quick adjustments\n}\n\nexport function WeightEntryModal({ visible, onClose, onSaved, initialData, lastWeight }: WeightEntryModalProps) {\n  const [weight, setWeight] = useState(initialData?.weight.toString() || lastWeight?.toString() || '');\n  const [recordedAt, setRecordedAt] = useState(initialData ? new Date(initialData.recordedAt) : new Date());\n  const [notes, setNotes] = useState(initialData?.notes || '');\n  const [showDatePicker, setShowDatePicker] = useState(false);\n  const [isSaving, setIsSaving] = useState(false);\n  \n  const handleSave = async () => {\n    // Validation: weight must be 20-500 kg\n    const weightNum = parseFloat(weight);\n    if (isNaN(weightNum) || weightNum < 20 || weightNum > 500) {\n      showAlert('Invalid Weight', 'Weight must be between 20 and 500 kg');\n      return;\n    }\n    \n    setIsSaving(true);\n    try {\n      const data: CreateWeightRecordInput = {\n        weight: weightNum,\n        recordedAt: recordedAt.toISOString(),\n        notes: notes.trim() || undefined,\n      };\n      \n      if (initialData) {\n        await weightApi.updateWeightRecord(initialData.id, data);\n      } else {\n        await weightApi.createWeightRecord(data);\n      }\n      \n      onSaved();\n      onClose();\n    } catch (error) {\n      showAlert('Error', getErrorMessage(error, 'Failed to save weight'));\n    } finally {\n      setIsSaving(false);\n    }\n  };\n  \n  return (\n    <Modal visible={visible} animationType=\"slide\" transparent>\n      <KeyboardAvoidingView behavior={Platform.OS === 'ios' ? 'padding' : 'height'} style={styles.overlay}>\n        <View style={styles.modalContent}>\n          {/* Header */}\n          <View style={styles.header}>\n            <Text style={styles.title}>{initialData ? 'Edit Weight' : 'Log Weight'}</Text>\n            <TouchableOpacity onPress={onClose}>\n              <Ionicons name=\"close\" size={28} color={colors.text} />\n            </TouchableOpacity>\n          </View>\n          \n          {/* Weight Input - Large, centered */}\n          <View style={styles.weightInputContainer}>\n            <TextInput\n              style={styles.weightInput}\n              value={weight}\n              onChangeText={setWeight}\n              keyboardType=\"decimal-pad\"\n              placeholder=\"0.0\"\n              autoFocus\n            />\n            <Text style={styles.unitLabel}>kg</Text>\n          </View>\n          \n          {/* Quick Adjustment Buttons */}\n          <View style={styles.quickButtons}>\n            <TouchableOpacity onPress={() => setWeight((prev) => (parseFloat(prev || '0') - 0.1).toFixed(1))}>\n              <Text style={styles.quickButton}>-0.1</Text>\n            </TouchableOpacity>\n            <TouchableOpacity onPress={() => setWeight((prev) => (parseFloat(prev || '0') + 0.1).toFixed(1))}>\n              <Text style={styles.quickButton}>+0.1</Text>\n            </TouchableOpacity>\n          </View>\n          \n          {/* Date/Time Picker */}\n          <TouchableOpacity style={styles.dateButton} onPress={() => setShowDatePicker(true)}>\n            <Ionicons name=\"calendar-outline\" size={20} color={colors.textSecondary} />\n            <Text style={styles.dateText}>{format(recordedAt, 'MMM d, yyyy h:mm a')}</Text>\n          </TouchableOpacity>\n          {showDatePicker && (\n            <DateTimePicker\n              value={recordedAt}\n              mode=\"datetime\"\n              onChange={(event, date) => {\n                setShowDatePicker(false);\n                if (date) setRecordedAt(date);\n              }}\n            />\n          )}\n          \n          {/* Notes Input */}\n          <TextInput\n            style={styles.notesInput}\n            value={notes}\n            onChangeText={setNotes}\n            placeholder=\"Notes (optional)\"\n            multiline\n            maxLength={500}\n          />\n          \n          {/* Save Button */}\n          <TouchableOpacity\n            style={[styles.saveButton, isSaving && styles.saveButtonDisabled]}\n            onPress={handleSave}\n            disabled={isSaving}\n          >\n            <Text style={styles.saveButtonText}>{isSaving ? 'Saving...' : 'Save'}</Text>\n          </TouchableOpacity>\n        </View>\n      </KeyboardAvoidingView>\n    </Modal>\n  );\n}\n```\n\n2. **lib/components/SwipeableWeightCard.tsx** - Swipeable card for weight record in history list\n\nComponent structure:\n```typescript\nimport { View, Text, StyleSheet, TouchableOpacity, Animated } from 'react-native';\nimport { Ionicons } from '@expo/vector-icons';\nimport Swipeable from 'react-native-gesture-handler/Swipeable';\nimport { WeightRecord } from '@/lib/types';\nimport { format } from 'date-fns';\nimport { colors, spacing, borderRadius, typography, shadows } from '@/lib/theme/colors';\n\ninterface SwipeableWeightCardProps {\n  record: WeightRecord;\n  previousWeight?: number;     // For showing change\n  onPress: () => void;         // Tap to edit\n  onDelete: () => void;        // Swipe to delete\n}\n\nexport function SwipeableWeightCard({ record, previousWeight, onPress, onDelete }: SwipeableWeightCardProps) {\n  const change = previousWeight ? record.weight - previousWeight : null;\n  const changeColor = change ? (change > 0 ? colors.error : colors.success) : colors.textSecondary;\n  const changeIcon = change ? (change > 0 ? 'arrow-up' : 'arrow-down') : null;\n  \n  const renderRightActions = (progress: Animated.AnimatedInterpolation<number>, dragX: Animated.AnimatedInterpolation<number>) => (\n    <TouchableOpacity style={styles.deleteAction} onPress={onDelete}>\n      <Ionicons name=\"trash-outline\" size={24} color=\"white\" />\n      <Text style={styles.deleteText}>Delete</Text>\n    </TouchableOpacity>\n  );\n  \n  return (\n    <Swipeable renderRightActions={renderRightActions}>\n      <TouchableOpacity style={styles.card} onPress={onPress} activeOpacity={0.7}>\n        <View style={styles.leftSection}>\n          <Text style={styles.date}>{format(new Date(record.recordedAt), 'MMM d, yyyy')}</Text>\n          <Text style={styles.time}>{format(new Date(record.recordedAt), 'h:mm a')}</Text>\n          {record.notes && <Text style={styles.notes} numberOfLines={1}>{record.notes}</Text>}\n        </View>\n        \n        <View style={styles.rightSection}>\n          <Text style={styles.weight}>{record.weight.toFixed(1)} kg</Text>\n          {change !== null && (\n            <View style={styles.changeContainer}>\n              {changeIcon && <Ionicons name={changeIcon} size={14} color={changeColor} />}\n              <Text style={[styles.change, { color: changeColor }]}>\n                {change > 0 ? '+' : ''}{change.toFixed(1)} kg\n              </Text>\n            </View>\n          )}\n        </View>\n      </TouchableOpacity>\n    </Swipeable>\n  );\n}\n```\n\n3. **app/weight/goal.tsx** - Goal setup wizard screen\n\nScreen structure:\n```typescript\nimport { useState } from 'react';\nimport { View, Text, TextInput, TouchableOpacity, ScrollView, StyleSheet } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport { Ionicons } from '@expo/vector-icons';\nimport { weightApi } from '@/lib/api/weight';\nimport { useAuth } from '@/lib/context/AuthContext';\nimport { showAlert } from '@/lib/utils/alert';\nimport { getErrorMessage } from '@/lib/utils/errorHandling';\nimport { colors, gradients, spacing, borderRadius, typography } from '@/lib/theme/colors';\n\ntype GoalType = 'lose' | 'gain' | 'maintain';\n\nexport default function WeightGoalScreen() {\n  const router = useRouter();\n  const { user } = useAuth();\n  const [step, setStep] = useState(1);\n  const [goalWeight, setGoalWeight] = useState(user?.goalWeight?.toString() || '');\n  const [goalType, setGoalType] = useState<GoalType>('lose');\n  const [isSaving, setIsSaving] = useState(false);\n  \n  const currentWeight = user?.currentWeight || 0;\n  const height = user?.height || 0;\n  const bmi = height > 0 ? currentWeight / Math.pow(height / 100, 2) : 0;\n  const targetBMI = height > 0 && goalWeight ? parseFloat(goalWeight) / Math.pow(height / 100, 2) : 0;\n  \n  const handleSaveGoal = async () => {\n    const goalWeightNum = parseFloat(goalWeight);\n    if (isNaN(goalWeightNum) || goalWeightNum < 30 || goalWeightNum > 300) {\n      showAlert('Invalid Goal', 'Goal weight must be between 30 and 300 kg');\n      return;\n    }\n    \n    setIsSaving(true);\n    try {\n      await weightApi.setWeightGoal({ goalWeight: goalWeightNum });\n      showAlert('Success', 'Weight goal set successfully!');\n      router.back();\n    } catch (error) {\n      showAlert('Error', getErrorMessage(error, 'Failed to set goal'));\n    } finally {\n      setIsSaving(false);\n    }\n  };\n  \n  return (\n    <SafeAreaView style={styles.container} edges={['top']}>\n      <LinearGradient colors={gradients.primary} style={styles.header}>\n        <TouchableOpacity onPress={() => router.back()}>\n          <Ionicons name=\"arrow-back\" size={24} color=\"white\" />\n        </TouchableOpacity>\n        <Text style={styles.headerTitle}>Set Weight Goal</Text>\n      </LinearGradient>\n      \n      <ScrollView style={styles.content}>\n        {step === 1 && (\n          <View>\n            <Text style={styles.stepTitle}>Current Weight</Text>\n            <Text style={styles.currentWeight}>{currentWeight.toFixed(1)} kg</Text>\n            {bmi > 0 && <Text style={styles.bmiText}>BMI: {bmi.toFixed(1)}</Text>}\n            <TouchableOpacity style={styles.nextButton} onPress={() => setStep(2)}>\n              <Text style={styles.nextButtonText}>Next</Text>\n            </TouchableOpacity>\n          </View>\n        )}\n        \n        {step === 2 && (\n          <View>\n            <Text style={styles.stepTitle}>Goal Type</Text>\n            <View style={styles.goalTypeButtons}>\n              <TouchableOpacity\n                style={[styles.goalTypeButton, goalType === 'lose' && styles.goalTypeButtonActive]}\n                onPress={() => setGoalType('lose')}\n              >\n                <Ionicons name=\"arrow-down\" size={32} color={goalType === 'lose' ? colors.primary : colors.textSecondary} />\n                <Text style={styles.goalTypeLabel}>Lose Weight</Text>\n              </TouchableOpacity>\n              {/* Similar buttons for 'gain' and 'maintain' */}\n            </View>\n            <TouchableOpacity style={styles.nextButton} onPress={() => setStep(3)}>\n              <Text style={styles.nextButtonText}>Next</Text>\n            </TouchableOpacity>\n          </View>\n        )}\n        \n        {step === 3 && (\n          <View>\n            <Text style={styles.stepTitle}>Target Weight</Text>\n            <TextInput\n              style={styles.goalInput}\n              value={goalWeight}\n              onChangeText={setGoalWeight}\n              keyboardType=\"decimal-pad\"\n              placeholder=\"Goal weight (kg)\"\n            />\n            {targetBMI > 0 && <Text style={styles.bmiText}>Target BMI: {targetBMI.toFixed(1)}</Text>}\n            <TouchableOpacity\n              style={[styles.saveButton, isSaving && styles.saveButtonDisabled]}\n              onPress={handleSaveGoal}\n              disabled={isSaving}\n            >\n              <Text style={styles.saveButtonText}>{isSaving ? 'Saving...' : 'Set Goal'}</Text>\n            </TouchableOpacity>\n          </View>\n        )}\n      </ScrollView>\n    </SafeAreaView>\n  );\n}\n```\n\nCOMMON PATTERNS:\n- Use theme colors, spacing, typography\n- Error handling with getErrorMessage\n- showAlert for confirmations and errors\n- Haptic feedback on button presses (Haptics.impactAsync)\n- Accessibility labels on all interactive elements\n\nREGISTRATION:\n- Add app/weight/goal.tsx to app/_layout.tsx with headerShown: false\n- Export components from lib/components/index.ts (if exists)",
            "status": "pending",
            "testStrategy": "Manual testing: test weight entry modal validation (min/max bounds), test quick adjustment buttons (+0.1, -0.1), test date picker, test notes input, test save/cancel, test swipeable card swipe-to-delete, test card tap to edit, test goal wizard step flow, test goal type selection, test goal weight validation, test BMI calculation display",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate weight tracking into dashboard and profile with widget and navigation",
            "description": "Add weight tracking widget to dashboard (app/(tabs)/index.tsx) showing current weight and quick-log action, add navigation to weight screens from profile, and integrate with existing user settings.",
            "dependencies": [
              3,
              4
            ],
            "details": "FILES TO UPDATE:\n\n1. **lib/components/WeightWidget.tsx** - Dashboard widget component\n\nCreate new component:\n```typescript\nimport { View, Text, StyleSheet, TouchableOpacity, ActivityIndicator } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { Ionicons } from '@expo/vector-icons';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport { Sparklines, SparklinesLine } from 'react-sparklines'; // Or custom sparkline implementation\nimport { WeightRecord } from '@/lib/types';\nimport { colors, gradients, spacing, borderRadius, typography, shadows } from '@/lib/theme/colors';\n\ninterface WeightWidgetProps {\n  currentWeight?: number;      // From user profile\n  goalWeight?: number;         // From user profile\n  recentRecords: WeightRecord[]; // Last 7-14 entries for sparkline\n  onLogPress: () => void;      // Open weight entry modal\n  onPress: () => void;         // Navigate to full weight screen\n  isLoading?: boolean;\n}\n\nexport function WeightWidget({ currentWeight, goalWeight, recentRecords, onLogPress, onPress, isLoading }: WeightWidgetProps) {\n  if (isLoading) {\n    return (\n      <View style={styles.loadingContainer}>\n        <ActivityIndicator color={colors.primary} />\n      </View>\n    );\n  }\n  \n  if (!currentWeight && recentRecords.length === 0) {\n    // Empty state - no weight logged yet\n    return (\n      <TouchableOpacity style={styles.emptyCard} onPress={onLogPress}>\n        <Ionicons name=\"scale-outline\" size={48} color={colors.primary} />\n        <Text style={styles.emptyTitle}>Track Your Weight</Text>\n        <Text style={styles.emptySubtitle}>Tap to log your first entry</Text>\n      </TouchableOpacity>\n    );\n  }\n  \n  const latestWeight = recentRecords[0]?.weight || currentWeight || 0;\n  const previousWeight = recentRecords[1]?.weight;\n  const change = previousWeight ? latestWeight - previousWeight : null;\n  const changeColor = change ? (change > 0 ? colors.error : colors.success) : colors.textSecondary;\n  const changeIcon = change ? (change > 0 ? 'arrow-up' : 'arrow-down') : null;\n  \n  // Prepare sparkline data (last 7 entries)\n  const sparklineData = recentRecords.slice(0, 7).reverse().map(r => r.weight);\n  \n  return (\n    <TouchableOpacity style={styles.card} onPress={onPress} activeOpacity={0.8}>\n      <LinearGradient colors={gradients.weight} style={styles.gradient}>\n        <View style={styles.header}>\n          <View style={styles.titleRow}>\n            <Ionicons name=\"scale\" size={24} color=\"white\" />\n            <Text style={styles.title}>Weight</Text>\n          </View>\n          <TouchableOpacity onPress={onLogPress} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}>\n            <Ionicons name=\"add-circle\" size={28} color=\"white\" />\n          </TouchableOpacity>\n        </View>\n        \n        <View style={styles.content}>\n          <View style={styles.leftSection}>\n            <Text style={styles.currentWeight}>{latestWeight.toFixed(1)} kg</Text>\n            {change !== null && (\n              <View style={styles.changeContainer}>\n                {changeIcon && <Ionicons name={changeIcon} size={16} color=\"white\" />}\n                <Text style={styles.changeText}>\n                  {change > 0 ? '+' : ''}{change.toFixed(1)} kg\n                </Text>\n              </View>\n            )}\n            {goalWeight && (\n              <Text style={styles.goalText}>Goal: {goalWeight.toFixed(1)} kg</Text>\n            )}\n          </View>\n          \n          <View style={styles.rightSection}>\n            {/* Mini sparkline chart */}\n            {sparklineData.length > 1 && (\n              <View style={styles.sparkline}>\n                {/* Implement simple sparkline with SVG or use library */}\n                <Text style={styles.sparklineLabel}>Last 7 days</Text>\n              </View>\n            )}\n          </View>\n        </View>\n      </LinearGradient>\n    </TouchableOpacity>\n  );\n}\n```\n\n2. **app/(tabs)/index.tsx** - Update dashboard to include weight widget\n\nAdd to imports:\n```typescript\nimport { WeightWidget } from '@/lib/components/WeightWidget';\nimport { weightApi } from '@/lib/api/weight';\nimport { WeightRecord } from '@/lib/types';\n```\n\nAdd state:\n```typescript\nconst [recentWeightRecords, setRecentWeightRecords] = useState<WeightRecord[]>([]);\nconst [showWeightModal, setShowWeightModal] = useState(false);\n```\n\nUpdate loadSummary to fetch weight data:\n```typescript\nconst loadSummary = useCallback(async () => {\n  if (!user) return;\n  \n  try {\n    const [mealsData, supplementsData, trendsData, weightRecords] = await Promise.all([\n      mealsApi.getDailySummary(),\n      supplementsApi.getTodayStatus().catch(() => null),\n      healthMetricsApi.getDashboardData(DASHBOARD_METRICS, 7).catch(() => null),\n      weightApi.getWeightRecords(\n        new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString(), // Last 14 days\n        new Date().toISOString()\n      ).catch(() => []),\n    ]);\n    \n    setSummary(mealsData);\n    setSupplementStatus(supplementsData);\n    setHealthTrends(trendsData);\n    setRecentWeightRecords(weightRecords.slice(0, 7)); // Last 7 for sparkline\n  } catch (error) {\n    console.error('Failed to load summary:', error);\n  } finally {\n    setIsLoading(false);\n  }\n}, [user]);\n```\n\nAdd widget to render:\n```typescript\n{/* After supplements section, before health trends */}\n<WeightWidget\n  currentWeight={user?.currentWeight}\n  goalWeight={user?.goalWeight}\n  recentRecords={recentWeightRecords}\n  onLogPress={() => setShowWeightModal(true)}\n  onPress={() => router.push('/weight')}\n  isLoading={isLoading}\n/>\n\n{/* Weight entry modal */}\n<WeightEntryModal\n  visible={showWeightModal}\n  onClose={() => setShowWeightModal(false)}\n  onSaved={() => {\n    setShowWeightModal(false);\n    loadSummary(); // Reload data\n  }}\n  lastWeight={recentWeightRecords[0]?.weight}\n/>\n```\n\n3. **app/(tabs)/profile.tsx** - Add navigation to weight tracking and goal setup\n\nAdd to profile menu items:\n```typescript\n<TouchableOpacity\n  style={styles.menuItem}\n  onPress={() => router.push('/weight')}\n>\n  <Ionicons name=\"scale\" size={24} color={colors.primary} />\n  <View style={styles.menuItemContent}>\n    <Text style={styles.menuItemTitle}>Weight Tracking</Text>\n    {user?.currentWeight && (\n      <Text style={styles.menuItemSubtitle}>\n        Current: {user.currentWeight.toFixed(1)} kg\n        {user.goalWeight && ` • Goal: ${user.goalWeight.toFixed(1)} kg`}\n      </Text>\n    )}\n  </View>\n  <Ionicons name=\"chevron-forward\" size={20} color={colors.textSecondary} />\n</TouchableOpacity>\n\n<TouchableOpacity\n  style={styles.menuItem}\n  onPress={() => router.push('/weight/goal')}\n>\n  <Ionicons name=\"flag\" size={24} color={colors.primary} />\n  <View style={styles.menuItemContent}>\n    <Text style={styles.menuItemTitle}>Weight Goal</Text>\n    <Text style={styles.menuItemSubtitle}>\n      {user?.goalWeight ? `Set your weight goal` : 'No goal set'}\n    </Text>\n  </View>\n  <Ionicons name=\"chevron-forward\" size={20} color={colors.textSecondary} />\n</TouchableOpacity>\n```\n\n4. **app/_layout.tsx** - Register weight screens\n\nAdd to stack screens:\n```typescript\n<Stack.Screen name=\"weight/index\" options={{ headerShown: false }} />\n<Stack.Screen name=\"weight/goal\" options={{ headerShown: false }} />\n<Stack.Screen name=\"weight/add\" options={{ headerShown: false }} />\n<Stack.Screen name=\"weight/edit/[id]\" options={{ headerShown: false }} />\n```\n\n5. **lib/theme/colors.ts** - Add weight-specific colors\n\nAdd to gradients:\n```typescript\nweight: ['#8B5CF6', '#6366F1'], // Purple to indigo\n```\n\nINTEGRATION POINTS:\n\n1. **Dashboard Widget**:\n   - Position after supplement tracker, before health trends\n   - Show current weight, change from last entry\n   - Mini sparkline of last 7 entries\n   - Quick-log button (+ icon)\n   - Tap to navigate to full weight screen\n\n2. **Profile Menu**:\n   - \"Weight Tracking\" item → /weight\n   - \"Weight Goal\" item → /weight/goal\n   - Show current and goal weights in subtitle\n\n3. **User Context Integration**:\n   - Weight widget uses user.currentWeight, user.goalWeight\n   - Backend syncs WeightRecord → User.currentWeight on create\n   - Goal setup updates user.goalWeight\n\n4. **Empty States**:\n   - Dashboard widget shows \"Track Your Weight\" CTA if no data\n   - Weight screen shows onboarding message if no entries\n\nACCESSIBILITY:\n- All touchables have accessibilityLabel and accessibilityRole\n- Widget announces current weight and change\n- Navigation items have descriptive labels\n\nERROR HANDLING:\n- Graceful degradation if weight API fails (don't crash dashboard)\n- Loading states with ActivityIndicator\n- Error states with retry buttons\n\nTESTING:\n- Test dashboard loads weight data\n- Test widget navigation to full screen\n- Test quick-log modal from widget\n- Test profile navigation to weight screens\n- Test empty states (no weight data)\n- Test loading states\n- Test error states (API failures)",
            "status": "pending",
            "testStrategy": "Manual testing: verify dashboard loads weight widget, test quick-log from widget, test navigation to full weight screen, test profile menu items navigate correctly, test widget shows sparkline with data, test empty state when no weight logged, test widget updates after logging new weight, verify gradient colors match design, test accessibility labels, verify responsive layout on different screen sizes",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-26T11:45:36.366Z"
      },
      {
        "id": 44,
        "title": "In-App Purchases & Subscription Management (StoreKit 2)",
        "description": "Implement comprehensive in-app purchase system using StoreKit 2 for iOS with subscription management, including premium feature gating, purchase restoration, receipt validation, and admin panel subscription analytics.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Subscription Service with StoreKit 2 API Integration",
            "description": "Create comprehensive backend subscription service with App Store Server API v2 integration, JWS token validation, receipt verification, and subscription status management using production-ready security practices.",
            "dependencies": [],
            "details": "Create `server/src/services/subscriptionService.ts` with:\n\n1. **App Store Server API v2 Client:**\n   - Implement JWT signing for App Store Server API requests using ES256 algorithm\n   - Configure API endpoints for production (https://api.storekit.itunes.apple.com) and sandbox (https://api.storekit-sandbox.itunes.apple.com)\n   - Add methods: getTransactionInfo(), getSubscriptionStatuses(), getTransactionHistory()\n   - Store App Store Connect API credentials securely in environment variables (APPLE_KEY_ID, APPLE_ISSUER_ID, APPLE_PRIVATE_KEY)\n\n2. **JWS Token Validation:**\n   - Implement signedPayload verification using Apple's public keys\n   - Decode and validate JWS tokens from purchase receipts\n   - Extract transaction data: originalTransactionId, productId, purchaseDate, expirationDate\n   - Verify signature chain and certificate validity\n\n3. **Subscription Management:**\n   - Create purchaseSubscription(userId, transactionId, receipt): Validate receipt, update User model (subscriptionTier, subscriptionStartDate, subscriptionEndDate, subscriptionBillingCycle, subscriptionPrice)\n   - Create restorePurchases(userId): Query App Store for active subscriptions, restore entitlements\n   - Create getSubscriptionStatus(userId): Return current subscription state with isActive, daysRemaining, tier, billingCycle\n   - Create syncSubscriptionStatus(transactionId): Fetch latest status from App Store Server API and sync to database\n\n4. **Integration with Existing Infrastructure:**\n   - Use existing User model fields (lines 39-44 in schema.prisma)\n   - Follow patterns from `adminSubscriptionService.ts` for database operations\n   - Add Zod validation schemas in `server/src/validation/schemas.ts`\n   - Create controller in `server/src/controllers/subscriptionController.ts`\n   - Add routes in `server/src/routes/subscription.ts`\n\n5. **Error Handling:**\n   - Handle App Store API errors (21000-21010 status codes)\n   - Implement retry logic with exponential backoff\n   - Log all subscription events for audit trail\n\n6. **Environment Variables (.env):**\n   - APPLE_KEY_ID, APPLE_ISSUER_ID, APPLE_PRIVATE_KEY (for App Store Server API)\n   - APPLE_BUNDLE_ID (com.nutri.app)\n   - APP_STORE_ENVIRONMENT (production/sandbox)",
            "status": "pending",
            "testStrategy": "Unit tests for:\n- JWS token validation with mock tokens\n- App Store API client methods (mock responses)\n- Subscription purchase flow (mock receipt validation)\n- Restore purchases logic\n- Error handling for invalid receipts\n\nIntegration tests:\n- End-to-end purchase flow with test transactions\n- Subscription status sync\n- Database updates on purchase/renewal\n\nManual testing with TestFlight and Sandbox environment:\n- Test all subscription tiers (monthly/annual)\n- Test purchase restoration\n- Test subscription expiration handling",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement App Store Server Notifications V2 Webhook Handler",
            "description": "Build secure webhook endpoint to receive and process App Store Server Notifications V2 with signature verification, event processing, and retry logic for subscription lifecycle events.",
            "dependencies": [
              1
            ],
            "details": "Create webhook handler in `server/src/controllers/webhookController.ts` and `server/src/services/webhookService.ts`:\n\n1. **Webhook Endpoint Setup:**\n   - Create POST /api/webhooks/appstore endpoint\n   - Disable rate limiting for Apple's servers (add IP allowlist: 17.0.0.0/8)\n   - Add raw body parser for signature verification\n   - Configure HTTPS-only access (App Store requirement)\n\n2. **Signature Verification:**\n   - Extract x-signature header from Apple's webhook requests\n   - Verify signature using Apple's root certificates\n   - Decode signedPayload JWS token\n   - Validate certificate chain and timestamp\n   - Reject requests with invalid signatures (return 401)\n\n3. **Event Processing (Using Existing AppStoreWebhookEvent Model):**\n   - Parse notificationType from payload (SUBSCRIBED, DID_RENEW, DID_CHANGE_RENEWAL_STATUS, DID_FAIL_TO_RENEW, EXPIRED, GRACE_PERIOD_EXPIRED, REFUND, etc.)\n   - Store event in `AppStoreWebhookEvent` table (lines 663-697 in schema.prisma) with PENDING status\n   - Process asynchronously to avoid blocking webhook response\n   - Update status to SUCCESS/FAILED after processing\n\n4. **Subscription Status Updates:**\n   - SUBSCRIBED: Create/update subscription, set tier to PRO_TRIAL or PRO\n   - DID_RENEW: Extend subscriptionEndDate based on renewal transaction\n   - DID_CHANGE_RENEWAL_STATUS: Handle auto-renew enabled/disabled\n   - EXPIRED/DID_FAIL_TO_RENEW: Set tier to FREE, mark subscription as ended\n   - REFUND: Revoke subscription immediately, log for support team\n   - GRACE_PERIOD_EXPIRED: Final subscription termination\n\n5. **User Lookup:**\n   - Use originalTransactionId to find user (may need to add transactionId field to User model or store in metadata JSON)\n   - Update userId field in AppStoreWebhookEvent after successful lookup\n   - Handle cases where user cannot be found (log warning, retry later)\n\n6. **Retry Logic:**\n   - Implement exponential backoff for failed event processing\n   - Store errorMessage and retryCount in AppStoreWebhookEvent\n   - Max retries: 5 attempts\n   - Use existing adminWebhookService patterns for retry implementation\n\n7. **Integration with Admin Panel:**\n   - Existing webhook table/detail views already implemented (admin-panel/components/webhooks/)\n   - Ensure webhook events are queryable via adminWebhookService\n\n8. **Configure in App Store Connect:**\n   - Set webhook URL: https://api.nutri.app/api/webhooks/appstore\n   - Enable notification types: Subscriptions (version 2)\n   - Test with sandbox environment first",
            "status": "pending",
            "testStrategy": "Unit tests:\n- Signature verification with valid/invalid signatures\n- JWS token decoding and validation\n- Event processing for each notification type\n- User lookup logic\n- Retry mechanism\n\nIntegration tests:\n- Mock webhook requests from Apple (use sample payloads from Apple docs)\n- Verify database updates for each event type\n- Test webhook event storage in AppStoreWebhookEvent table\n\nManual testing:\n- Use App Store Server API test endpoint to trigger test notifications\n- Verify events appear in admin panel\n- Test retry logic by simulating processing failures\n- Monitor webhook logs in production",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Mobile IAP with react-native-iap (StoreKit 2 Support)",
            "description": "Integrate react-native-iap v13+ for iOS in-app purchases with StoreKit 2 support, including product fetching, purchase flow, purchase restoration, and transaction handling with proper error management.",
            "dependencies": [
              1
            ],
            "details": "Create mobile IAP implementation in `lib/services/iap/`:\n\n1. **Install and Configure react-native-iap:**\n   - Install: `npm install react-native-iap@^13.0.0`\n   - Configure expo-build-properties in app.json for iOS deployment target 13.0+\n   - Add StoreKit configuration file for local testing (Configuration.storekit)\n   - Configure product IDs in constants: 'nutri_pro_monthly', 'nutri_pro_annual'\n\n2. **Create IAP Service (`lib/services/iap/IAPService.ts`):**\n   - Initialize IAP connection: initConnection(), endConnection()\n   - Fetch products: getProducts(['nutri_pro_monthly', 'nutri_pro_annual'])\n   - Purchase flow: requestPurchase(productId), finishTransaction(purchase)\n   - Restore purchases: getAvailablePurchases()\n   - Get purchase history: getPurchaseHistory()\n\n3. **Purchase Flow:**\n   - Call requestPurchase(productId) -> returns Purchase object with transactionReceipt\n   - Send receipt to backend: POST /api/subscriptions/verify with { transactionId, receipt }\n   - Backend validates with App Store Server API\n   - On success: Update local user state with new subscription tier\n   - Call finishTransaction() to complete purchase (CRITICAL: prevents refunds)\n   - Handle errors: User canceled, network errors, already purchased, etc.\n\n4. **Purchase Restoration:**\n   - Implement restorePurchases(): Call getAvailablePurchases()\n   - Send all valid receipts to backend for verification\n   - Update UI with restored subscription status\n   - Show success/error messages to user\n\n5. **Transaction Listener:**\n   - Set up purchaseUpdatedListener for pending transactions\n   - Handle transactions on app startup (clear pending transactions)\n   - Process queued transactions automatically\n   - Ensure all transactions are finished to avoid stuck purchases\n\n6. **Error Handling:**\n   - Handle StoreKit errors: E_USER_CANCELLED, E_NETWORK_ERROR, E_SERVICE_ERROR\n   - Display user-friendly error messages\n   - Retry logic for network failures\n   - Fallback to manual restoration if automatic fails\n\n7. **Context/Hook (`lib/context/SubscriptionContext.tsx` and `lib/hooks/useSubscription.ts`):**\n   - Provide subscription state: tier, isActive, expiresAt, billingCycle\n   - Methods: purchase(productId), restore(), checkStatus()\n   - Sync with backend subscription status on app launch\n   - Cache subscription status locally with SecureStore\n\n8. **Testing Configuration:**\n   - Configure Sandbox tester accounts in App Store Connect\n   - Create test products with various pricing\n   - Test interrupted purchases (background app, network loss)\n\n9. **Expo Configuration (app.json):**\n   - Add expo-build-properties for iOS 13.0+ target\n   - Configure bundle ID to match App Store Connect\n   - Add in-app purchase capability to iOS entitlements",
            "status": "pending",
            "testStrategy": "Unit tests:\n- IAP service methods (mock react-native-iap)\n- Purchase flow state management\n- Error handling for various StoreKit errors\n- Transaction listener logic\n\nIntegration tests:\n- Mock backend receipt validation\n- Test purchase -> verify -> finish flow\n- Test restoration flow\n\nManual testing (Sandbox):\n- Test purchase for monthly subscription\n- Test purchase for annual subscription\n- Test purchase restoration after reinstall\n- Test purchase cancellation (user cancels)\n- Test interrupted purchase (kill app mid-purchase)\n- Test subscription upgrade/downgrade\n- Test expired subscription handling\n- Test with multiple Sandbox accounts\n\nTestFlight testing:\n- Real device testing with Sandbox accounts\n- Verify receipt validation with live backend",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build Paywall and Subscription Management UI",
            "description": "Create beautiful, conversion-optimized paywall UI with feature comparison, pricing plans, trial information, and subscription management screens following iOS design guidelines and App Store requirements.",
            "dependencies": [
              3
            ],
            "details": "Create UI components for subscription management:\n\n1. **Paywall Screen (`app/paywall.tsx`):**\n   - Hero section with app value proposition\n   - Feature comparison table: Free vs Pro\n   - Pricing cards with monthly/annual toggle\n   - Highlight savings for annual plan (e.g., \"Save 2 months\")\n   - Show trial period prominently (if applicable)\n   - Clear CTA buttons: \"Start Free Trial\" or \"Subscribe Now\"\n   - Terms of service link (required by App Store)\n   - Privacy policy link (required by App Store)\n   - Restore purchases button (required by App Store)\n\n2. **Feature Comparison:**\n   Free tier:\n   - Basic meal tracking (last 30 days)\n   - Manual entry only\n   - Basic calorie/macro tracking\n   - Limited health metric history (7 days)\n   \n   Pro tier:\n   - Unlimited meal history\n   - AI-powered food recognition (barcode + image scanning)\n   - Advanced micronutrient tracking\n   - ML health predictions (RHR, HRV)\n   - Unlimited health metric history\n   - Nutrition-health correlations\n   - Supplement tracking\n   - Priority support\n\n3. **Pricing Plans Component:**\n   - Fetch products from IAP service: useProducts()\n   - Display localized prices from StoreKit\n   - Show billing cycle (per month / per year)\n   - Highlight \"Best Value\" for annual plan\n   - Show per-month cost for annual plan (e.g., \"$4.99/month, billed annually\")\n   - Loading states while fetching products\n   - Error states if products fail to load\n\n4. **Purchase Flow UI:**\n   - Show loading indicator during purchase\n   - Success modal with confetti/celebration animation\n   - Error handling with retry option\n   - Handle edge cases: already subscribed, restore needed, etc.\n\n5. **Subscription Management Screen (`app/(tabs)/profile.tsx` -> Manage Subscription):**\n   - Display current subscription tier and status\n   - Show expiration date and auto-renew status\n   - Show billing cycle (monthly/annual)\n   - Show price paid\n   - Button to manage subscription in App Store (deep link)\n   - Button to restore purchases\n   - Button to cancel subscription (deep link to App Store)\n   - Show subscription benefits/features\n\n6. **Subscription Status Badge (Profile Tab):**\n   - Show \"Free\", \"Pro Trial\", or \"Pro\" badge\n   - Show days remaining for trial/subscription\n   - Visual indicator for expiring soon (<7 days)\n\n7. **Restore Purchases UI:**\n   - Modal or screen for restoration flow\n   - Loading state during restoration\n   - Success message: \"Subscription restored!\"\n   - Error message: \"No purchases found\" or specific error\n\n8. **App Store Requirements:**\n   - Include terms link: https://nutri.app/terms\n   - Include privacy link: https://nutri.app/privacy\n   - Show auto-renewable subscription terms\n   - Include restore purchases option\n   - No alternative payment methods shown\n\n9. **Accessibility:**\n   - All interactive elements have accessibilityLabel\n   - Support Dynamic Type for text scaling\n   - VoiceOver friendly navigation\n   - Sufficient color contrast\n\n10. **Responsive Design:**\n    - Support iPhone (all sizes) and iPad\n    - Landscape and portrait orientations\n    - Use existing responsive utilities from lib/responsive/\n\n11. **Analytics Events (Future):**\n    - Track paywall views\n    - Track purchase attempts\n    - Track successful purchases\n    - Track restoration attempts",
            "status": "pending",
            "testStrategy": "Visual regression tests:\n- Screenshot paywall on various devices\n- Screenshot subscription management screen\n- Verify responsive layout on iPhone SE, Pro, Max, iPad\n\nUnit tests:\n- Feature comparison data rendering\n- Pricing calculation logic\n- Subscription status badge logic\n\nIntegration tests:\n- Purchase flow (mock IAP)\n- Restore flow (mock IAP)\n- Error handling UI\n\nManual testing:\n- Test paywall conversion flow on real device\n- Verify all deep links work (App Store subscription management)\n- Test with VoiceOver enabled\n- Test with Dynamic Type at various sizes\n- Verify terms/privacy links work\n- Test restore purchases flow\n- Test UI for various subscription states (free, trial, active, expired)\n\nA/B testing (future):\n- Test different paywall designs\n- Test different pricing presentation\n- Test different CTAs",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Premium Feature Gating System",
            "description": "Create comprehensive feature gating system to restrict premium features to Pro subscribers, including middleware, UI components, and graceful upgrade prompts throughout the app.",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement feature gating across the app:\n\n1. **Subscription Context Enhancement (`lib/context/SubscriptionContext.tsx`):**\n   - Add subscription state to context: tier, isActive, expiresAt, billingCycle\n   - Add methods: isPro(), isFree(), isTrialing(), daysRemaining()\n   - Sync subscription status from backend on app launch\n   - Refresh subscription status periodically (every 24 hours)\n   - Store locally with SecureStore for offline access\n\n2. **useSubscription Hook (`lib/hooks/useSubscription.ts`):**\n   - Access subscription state: `const { isPro, tier, isActive } = useSubscription()`\n   - Feature-specific checks: canAccessFeature('ml_predictions'), canAccessFeature('barcode_scan')\n   - Return upgrade prompt function: showUpgradePrompt(feature)\n\n3. **Feature Gate Component (`lib/components/FeatureGate.tsx`):**\n   ```tsx\n   <FeatureGate feature=\"ml_predictions\" fallback={<UpgradePrompt />}>\n     <MLPredictionsView />\n   </FeatureGate>\n   ```\n   - Show upgrade prompt if user doesn't have access\n   - Optionally show locked state with blur/overlay\n   - Track feature gate impressions for analytics\n\n4. **Upgrade Prompt Component (`lib/components/UpgradePrompt.tsx`):**\n   - Modal or inline prompt explaining premium feature\n   - Show specific benefits for the gated feature\n   - CTA button: \"Upgrade to Pro\"\n   - Navigate to paywall on CTA press\n   - Option to dismiss and continue as Free user\n\n5. **Feature Definitions (`lib/constants/features.ts`):**\n   ```ts\n   export const FEATURES = {\n     ML_PREDICTIONS: { tier: 'PRO', name: 'Health Predictions' },\n     BARCODE_SCAN: { tier: 'PRO', name: 'Barcode Scanning' },\n     IMAGE_RECOGNITION: { tier: 'PRO', name: 'AI Food Recognition' },\n     UNLIMITED_HISTORY: { tier: 'PRO', name: 'Unlimited History' },\n     ADVANCED_ANALYTICS: { tier: 'PRO', name: 'Advanced Analytics' },\n     SUPPLEMENT_TRACKING: { tier: 'PRO', name: 'Supplement Tracking' },\n   }\n   ```\n\n6. **Implement Feature Gates in Screens:**\n   - **Barcode Scanner (`app/scan-barcode.tsx`):** Gate entire screen, show upgrade prompt\n   - **Food Image Recognition (`app/scan-food.tsx`):** Gate entire screen\n   - **ML Predictions (Dashboard):** Show locked state with upgrade CTA\n   - **Meal History:** Limit to 30 days for Free, show upgrade banner\n   - **Health Metrics History:** Limit to 7 days for Free\n   - **Supplement Tracking (`app/supplements.tsx`):** Gate entire feature\n   - **Advanced Analytics:** Gate correlation charts and insights\n\n7. **Backend Enforcement (Critical!):**\n   - Add middleware: `server/src/middleware/subscriptionGuard.ts`\n   - Check subscription tier before processing premium API requests\n   - Return 402 Payment Required for gated features\n   - Add tier check to relevant endpoints:\n     - POST /api/food-analysis (image/barcode scanning)\n     - GET /api/ml/predictions\n     - GET /api/meals (limit results for Free tier)\n     - GET /api/health-metrics (limit results for Free tier)\n     - POST /api/supplements\n\n8. **Data Retention for Free Users:**\n   - Implement automatic data truncation for Free tier\n   - Keep last 30 days of meals, 7 days of health metrics\n   - Run cleanup job daily (cron job or scheduled task)\n   - Preserve data if user upgrades (don't delete old data)\n\n9. **Graceful Degradation:**\n   - Show preview of premium features with blur/lock icon\n   - Allow users to see what they're missing\n   - Provide context-specific upgrade messaging\n   - Never crash or show errors for gated features\n\n10. **Trial Period Handling:**\n    - PRO_TRIAL tier has full Pro access\n    - Show trial expiration countdown in UI\n    - Prompt to subscribe before trial ends\n    - Grace period after trial expiration (optional)\n\n11. **Subscription Expiration:**\n    - Check subscriptionEndDate on every request\n    - Downgrade to FREE tier if expired\n    - Show renewal prompt in UI\n    - Allow grace period for failed renewals (optional)\n\n12. **Offline Handling:**\n    - Cache subscription status locally\n    - Allow offline access based on cached status\n    - Sync on next online session\n    - Handle edge case: subscription expired while offline",
            "status": "pending",
            "testStrategy": "Unit tests:\n- useSubscription hook logic\n- Feature gate component rendering\n- canAccessFeature() logic for various tiers\n- Subscription status caching\n\nIntegration tests:\n- Backend middleware subscription checks\n- API returns 402 for gated features (Free user)\n- API allows access for Pro user\n- Feature gate UI rendering for Free vs Pro\n\nManual testing:\n- Test all gated features as Free user\n- Verify upgrade prompts appear correctly\n- Test upgrade flow from prompt\n- Test all features as Pro user\n- Test trial period countdown\n- Test subscription expiration (downgrade to Free)\n- Test offline access with cached subscription\n- Test data truncation for Free tier\n\nE2E tests (Maestro):\n- Free user tries to access barcode scanner -> sees upgrade prompt\n- Pro user accesses all features successfully\n- User upgrades from Free to Pro -> gains access to gated features\n- Trial user accesses Pro features -> sees trial countdown",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 45,
        "title": "Goal Progress Dashboard & Achievement Tracking",
        "description": "Implement comprehensive goal progress visualization dashboard showing daily/weekly/monthly progress towards nutrition, weight, and health goals with visual indicators, trend analysis, and motivational feedback.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create backend goal progress calculation service with historical tracking",
            "description": "Implement backend service methods to calculate daily, weekly, and monthly goal progress for calories and macros with trend analysis and percentage completion calculations.",
            "dependencies": [],
            "details": "Create new methods in `server/src/services/mealService.ts` to calculate goal progress metrics:\n\n1. `getGoalProgress(userId, date, period)` - Calculate progress for specified period (daily/weekly/monthly)\n2. `getGoalTrends(userId, days)` - Get historical goal achievement data for trend charts\n3. Calculate percentage completion for calories, protein, carbs, fat vs user goals\n4. Return streak data (consecutive days meeting goals)\n5. Calculate weekly/monthly averages and compare to goals\n6. Add achievement status (under/on-track/over)\n\nReturn structure:\n```typescript\n{\n  period: 'daily' | 'weekly' | 'monthly',\n  calories: { consumed: number, goal: number, percentage: number, status: string },\n  protein: { consumed: number, goal: number, percentage: number, status: string },\n  carbs: { consumed: number, goal: number, percentage: number, status: string },\n  fat: { consumed: number, goal: number, percentage: number, status: string },\n  streak: { days: number, type: 'all_goals' | 'calories_only' },\n  trend: Array<{ date: string, caloriesPercentage: number, proteinPercentage: number }>\n}\n```\n\nFollow existing pattern in `mealService.ts:118-153` for getDailySummary implementation.",
            "status": "pending",
            "testStrategy": "Unit tests in `server/src/__tests__/meal.test.ts`:\n- Test goal progress calculation with various consumption levels (under/on-track/over)\n- Test weekly/monthly aggregation with multiple days of data\n- Test trend calculation with 7-day and 30-day periods\n- Test streak calculation for consecutive goal achievements\n- Test edge cases: no meals, partial data, goals not set",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add goal progress API endpoints with date range filtering",
            "description": "Create REST API endpoints for retrieving goal progress data with support for daily, weekly, and monthly views, including trend history endpoints.",
            "dependencies": [
              1
            ],
            "details": "Add new routes in `server/src/routes/mealRoutes.ts` following existing pattern at line 12:\n\n```typescript\n// GET /api/meals/goals/progress?period=daily&date=2024-01-15\nrouter.get('/goals/progress', (req, res) => mealController.getGoalProgress(req, res));\n\n// GET /api/meals/goals/trends?days=7\nrouter.get('/goals/trends', (req, res) => mealController.getGoalTrends(req, res));\n\n// GET /api/meals/goals/streak\nrouter.get('/goals/streak', (req, res) => mealController.getGoalStreak(req, res));\n```\n\nCreate controller methods in `server/src/controllers/mealController.ts`:\n- Validate query parameters (period: daily/weekly/monthly, date, days: 7/30/90)\n- Call corresponding service methods\n- Return formatted response with HTTP 200\n- Handle errors with proper HTTP status codes\n\nAdd Zod validation schemas in `server/src/validation/schemas.ts` for query parameters.",
            "status": "pending",
            "testStrategy": "Integration tests in `server/src/__tests__/meal.test.ts`:\n- Test GET /goals/progress with different periods (daily/weekly/monthly)\n- Test GET /goals/trends with different day ranges (7/30/90)\n- Test authentication required for all endpoints\n- Test invalid query parameters return 400\n- Test date filtering works correctly\n- Test response format matches TypeScript types",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create reusable CircularProgress and GoalCard components",
            "description": "Build reusable React Native components for displaying circular progress rings and goal cards with animations, following existing design patterns in app/(tabs)/index.tsx.",
            "dependencies": [],
            "details": "Create `lib/components/CircularProgress.tsx`:\n- Circular progress ring using react-native-svg (already installed)\n- Props: size, strokeWidth, progress (0-100), color, backgroundColor, label, value\n- Animated progress with react-native-reanimated\n- Support gradient colors like existing calorieRing (lines 195-211 in index.tsx)\n- Responsive sizing using useResponsive hook\n\nCreate `lib/components/GoalCard.tsx`:\n- Card displaying goal progress with CircularProgress component\n- Props: title, current, goal, unit, progressColor, icon\n- Show percentage and \"On Track\" / \"Under\" / \"Over\" status\n- Match design of existing macroCard (lines 522-556 in index.tsx)\n- Include LinearGradient for progress bars\n- Support onPress for navigation to details\n\nFollow existing patterns:\n- Use colors, gradients, shadows from `lib/theme/colors.ts`\n- Use spacing, borderRadius, typography from theme\n- Add responsive design support\n- Include testID props for E2E testing",
            "status": "pending",
            "testStrategy": "Component tests using Jest + React Native Testing Library:\n- Test CircularProgress renders with correct progress percentage\n- Test CircularProgress animates on progress change\n- Test GoalCard displays correct status (on-track/under/over)\n- Test GoalCard calculates percentage correctly\n- Test responsive sizing on different device sizes\n- Test accessibility labels are present\n- Snapshot tests for visual regression",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate goal progress cards into dashboard home screen",
            "description": "Add goal progress visualization section to app/(tabs)/index.tsx dashboard, displaying daily progress for calories and macros with trend indicators.",
            "dependencies": [
              2,
              3
            ],
            "details": "Modify `app/(tabs)/index.tsx` to add Goal Progress section:\n\n1. Create API client method in `lib/api/meals.ts`:\n```typescript\ngetGoalProgress: async (period: 'daily' | 'weekly' | 'monthly', date?: Date) => {\n  const response = await client.get('/meals/goals/progress', { params: { period, date } });\n  return response.data;\n}\n```\n\n2. Add state and data fetching in index.tsx (around line 44):\n```typescript\nconst [goalProgress, setGoalProgress] = useState<GoalProgress | null>(null);\n// Fetch in loadSummary() alongside existing calls (line 84)\n```\n\n3. Insert Goal Progress section after Macros Container (after line 281):\n- Section header: \"Daily Goals\" with View All button\n- 2x2 grid of GoalCard components (Calories, Protein, Carbs, Fat)\n- Each card shows CircularProgress with current/goal values\n- Use existing isTablet responsive patterns (lines 227, 296)\n- Match styles from trendsSection (lines 559-633)\n\n4. Add navigation to detailed goals screen (next subtask) on card press\n\n5. Refresh on pull-to-refresh and screen focus (existing pattern lines 109-115)",
            "status": "pending",
            "testStrategy": "Integration and E2E tests:\n- Test goal progress section renders with correct data\n- Test cards display current vs goal values accurately\n- Test progress rings show correct percentages\n- Test status indicators (on-track/under/over) are correct\n- Test pull-to-refresh updates goal progress\n- Test navigation to detailed goals screen works\n- Test loading states and error handling\n- Maestro E2E test: navigate to home, verify goals visible",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build detailed goals screen with weekly/monthly trends and achievement history",
            "description": "Create comprehensive goals tracking screen at app/goals.tsx with line charts showing progress trends, achievement streaks, and historical performance using react-native-chart-kit.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create new screen `app/goals.tsx`:\n\n1. Setup screen structure:\n- Custom header with title \"Goal Progress\" (headerShown: false pattern)\n- Period selector: Daily / Weekly / Monthly tabs\n- ScrollView with sections\n\n2. Sections:\n- **Summary Cards**: 4 GoalCard components in 2x2 grid (Calories, Protein, Carbs, Fat) with current period progress\n- **Trend Chart**: LineChart from react-native-chart-kit showing 7-day/30-day/90-day progress trends for all macros\n- **Achievement Streak**: Card showing consecutive days meeting goals with flame icon\n- **Weekly Breakdown**: Bar chart showing daily performance for the week\n- **Goal History**: List of past achievements with dates and percentages\n\n3. Chart configuration using react-native-chart-kit:\n```typescript\nimport { LineChart, BarChart } from 'react-native-chart-kit';\n// Use existing color scheme from lib/theme/colors.ts\n// Follow responsive patterns from index.tsx\n```\n\n4. Data fetching:\n- Use getGoalProgress and getGoalTrends API calls\n- Update on period change (Daily/Weekly/Monthly)\n- Pull-to-refresh support\n\n5. Register route in `app/_layout.tsx` with headerShown: false\n\n6. Add navigation from dashboard \"View All\" button and GoalCard presses",
            "status": "pending",
            "testStrategy": "Component and E2E tests:\n- Test period selector switches between daily/weekly/monthly views\n- Test trend charts render with correct data points\n- Test charts display correct time ranges (7/30/90 days)\n- Test achievement streak calculation is accurate\n- Test goal history list displays past records\n- Test pull-to-refresh updates all sections\n- Test responsive layout on tablet devices\n- Maestro E2E test: navigate from home → goals screen, switch periods, verify charts render",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-26T11:45:36.467Z"
      },
      {
        "id": 46,
        "title": "Weekly & Monthly Nutrition Reports with Insights",
        "description": "Implement automated weekly and monthly nutrition reports with comprehensive analytics, trend visualization, AI-powered insights, and shareable report generation (PDF/image export).",
        "status": "pending",
        "dependencies": [
          "8"
        ],
        "priority": "high",
        "details": "## Existing Infrastructure to Leverage\n\n### MealService (server/src/services/mealService.ts:118-194)\n- `getDailySummary(userId, date)` - Returns totalCalories, totalProtein, totalCarbs, totalFat, totalFiber, totalSugar, mealCount, goals, meals\n- `getWeeklySummary(userId)` - Returns 7-day totals and daily averages for calories, protein, carbs, fat\n- Uses `getDayBoundaries()` and `getDaysAgo()` from utils/dateHelpers.ts\n- Accesses user goals via USER_GOALS_SELECT_FIELDS\n\n### HealthMetricService (server/src/services/healthMetricService.ts)\n- `getMetricStats(userId, metricType, days)` - Returns avg, min, max, stdDev, trend, percentChange\n- `getTimeSeries(userId, metricType, startDate, endDate)` - Returns time series data for charting\n- `getWeeklyAverage(userId, metricType)` - Returns 7-day rolling average\n- Private `calculateTrend(values)` - Compares first half vs second half\n\n### ActivityService (server/src/services/activityService.ts)\n- `getDailySummary(userId, date)` - Returns totalDuration, totalCalories, totalDistance, totalSteps\n- `getWeeklySummary(userId)` - Returns array of daily activity data grouped by date\n\n### Database Models (server/prisma/schema.prisma)\n- **Meal**: All macro/micronutrients (protein, carbs, fat, fiber, sugar, vitamins, minerals)\n- **User**: goalCalories, goalProtein, goalCarbs, goalFat\n- **HealthMetric**: 30+ metric types with values, sources, timestamps\n- **Activity**: activityType, duration, caloriesBurned, intensity\n- **MLInsight**: Used for AI-generated insights (insightType, priority, title, description, recommendation)\n\n### Theme & UI Patterns (lib/theme/colors.ts)\n- colors.primary.main: '#8B5CF6' (Purple)\n- colors.status.success: '#10B981', colors.status.error: '#EF4444'\n- gradients.primary: ['#8B5CF6', '#EC4899'] (Purple to Pink)\n- Chart config from app/health/[metricType].tsx lines 291-309\n- Use react-native-chart-kit (already installed)\n\n### Date Utilities (server/src/utils/dateHelpers.ts)\n- `getDayBoundaries(date)` - Returns startOfDay/endOfDay\n- `getDaysAgo(days, setToStartOfDay)` - Returns date N days ago\n- `getDateRangeForPastDays(days)` - Returns startDate/endDate\n\n## Implementation Plan\n\n### 1. Backend Report Types (server/src/types/reports.ts)\n```typescript\nexport interface DailyBreakdown {\n  date: string;\n  calories: number;\n  protein: number;\n  carbs: number;\n  fat: number;\n  fiber: number;\n  sugar: number;\n  goalCompletion: number; // 0-100%\n  mealCount: number;\n}\n\nexport interface NutritionTotals {\n  calories: number;\n  protein: number;\n  carbs: number;\n  fat: number;\n  fiber: number;\n  sugar: number;\n}\n\nexport interface GoalProgress {\n  caloriesGoal: number;\n  caloriesActual: number;\n  caloriesPercent: number;\n  proteinGoal: number;\n  proteinActual: number;\n  proteinPercent: number;\n  // ... similar for carbs, fat\n}\n\nexport interface TrendComparison {\n  calories: { current: number; previous: number; percentChange: number; trend: 'up' | 'down' | 'stable' };\n  protein: { current: number; previous: number; percentChange: number; trend: 'up' | 'down' | 'stable' };\n  // ... similar for other macros\n}\n\nexport interface WeeklyReport {\n  userId: string;\n  periodStart: string;\n  periodEnd: string;\n  dailyBreakdowns: DailyBreakdown[];\n  totals: NutritionTotals;\n  averages: NutritionTotals;\n  goalProgress: GoalProgress;\n  trends: TrendComparison;\n  topFoods: { name: string; count: number; calories: number }[];\n  healthMetricsSummary: { metricType: string; average: number; trend: string }[];\n  activitySummary: { totalDuration: number; totalCalories: number; activityCount: number };\n  insights: { id: string; title: string; description: string; priority: string }[];\n}\n\nexport interface MonthlyReport extends WeeklyReport {\n  weeklyBreakdowns: { weekNumber: number; startDate: string; averages: NutritionTotals }[];\n  bestDays: DailyBreakdown[];\n  worstDays: DailyBreakdown[];\n}\n```\n\n### 2. Backend Report Service (server/src/services/reportService.ts)\n```typescript\nimport { mealService } from './mealService';\nimport { healthMetricService } from './healthMetricService';\nimport { activityService } from './activityService';\nimport { getDayBoundaries, getDaysAgo } from '../utils/dateHelpers';\nimport prisma from '../config/database';\n\nexport class ReportService {\n  async generateWeeklyReport(userId: string, weekStartDate?: Date): Promise<WeeklyReport> {\n    // 1. Get 7 daily summaries using mealService.getDailySummary() pattern\n    // 2. Get health metrics summary via healthMetricService.getMetricStats()\n    // 3. Get activity summary via activityService.getWeeklySummary()\n    // 4. Calculate trends by comparing to previous week\n    // 5. Get top foods via GROUP BY meal.name with COUNT\n    // 6. Fetch relevant MLInsights from prisma for the period\n  }\n  \n  async generateMonthlyReport(userId: string, month: Date): Promise<MonthlyReport> {\n    // 1. Generate 4 weekly reports and aggregate\n    // 2. Calculate weekly breakdowns\n    // 3. Identify best/worst days by goal completion\n  }\n  \n  private async getTopFoods(userId: string, startDate: Date, endDate: Date, limit = 10) {\n    return prisma.$queryRaw`\n      SELECT name, COUNT(*) as count, SUM(calories) as total_calories\n      FROM \"Meal\"\n      WHERE \"userId\" = ${userId}\n      AND \"consumedAt\" >= ${startDate}\n      AND \"consumedAt\" <= ${endDate}\n      GROUP BY name\n      ORDER BY count DESC\n      LIMIT ${limit}\n    `;\n  }\n}\n```\n\n### 3. API Endpoints (server/src/routes/reportRoutes.ts)\n```\nGET /api/reports/weekly?date=YYYY-MM-DD      - Generate weekly report\nGET /api/reports/monthly?month=YYYY-MM       - Generate monthly report\nGET /api/reports/weekly/export?date=YYYY-MM-DD&format=pdf|image - Export report\n```\n\n### 4. Mobile API Client (lib/api/reports.ts)\nFollow pattern from lib/api/health-metrics.ts (lines 42-238):\n```typescript\nexport const reportsApi = {\n  async getWeeklyReport(date?: string): Promise<WeeklyReport> {\n    const response = await api.get('/reports/weekly', { params: { date } });\n    return response.data;\n  },\n  \n  async getMonthlyReport(month?: string): Promise<MonthlyReport> {\n    const response = await api.get('/reports/monthly', { params: { month } });\n    return response.data;\n  },\n  \n  async exportReport(type: 'weekly' | 'monthly', date: string, format: 'pdf' | 'image'): Promise<string> {\n    const response = await api.get(`/reports/${type}/export`, { params: { date, format } });\n    return response.data.url; // Pre-signed URL or base64\n  }\n};\n```\n\n### 5. Mobile Report Screen (app/reports/weekly.tsx)\nFollow UI patterns from app/health/[metricType].tsx:\n- SafeAreaView with custom header (lines 330-341)\n- Date range selector with LinearGradient buttons (lines 354-382)\n- Stats cards row (statsContainer pattern lines 730-762)\n- LineChart with chartConfig (lines 291-309, 416-432)\n- Trend indicators with getTrendColor() pattern (lines 161-175)\n- Loading/error states (lines 385-410)\n\n### 6. Export Service (server/src/services/reportExportService.ts)\nOptions for PDF/image generation:\n- **Puppeteer**: Render HTML template to PDF/PNG (recommended for quality)\n- **pdfmake**: Pure JS PDF generation (no browser dependency)\n- **Sharp + Canvas**: For image generation\n\nTemplate will include:\n- Summary header with period dates and Nutri branding (#8B5CF6)\n- Bar charts for daily calories\n- Pie chart for macro distribution\n- Trend arrows with color coding\n- AI insights section\n\n### 7. Share Functionality\n- Install expo-sharing: `npx expo install expo-sharing expo-file-system`\n- Use FileSystem.downloadAsync() to save exported file\n- Use Sharing.shareAsync() to share via native share sheet",
        "testStrategy": "### Unit Tests (server/src/__tests__/reports/)\n1. **reportService.test.ts**\n   - Test generateWeeklyReport returns correct structure\n   - Test dailyBreakdowns has exactly 7 entries for full week\n   - Test goalProgress percentages are calculated correctly\n   - Test trends compare current vs previous week accurately\n   - Test topFoods returns correct aggregation\n   - Test empty data case returns zeros not nulls\n\n2. **reportExportService.test.ts**\n   - Test PDF generation produces valid PDF buffer\n   - Test image generation produces valid PNG buffer\n   - Test templates include all report sections\n\n### Integration Tests\n1. **API endpoint tests**\n   - GET /reports/weekly returns 200 with valid report structure\n   - GET /reports/weekly with invalid date returns 400\n   - GET /reports/monthly returns correct number of weekly breakdowns\n   - Export endpoints return valid file URLs/data\n\n2. **Mobile tests (__tests__/screens/reports/)**\n   - WeeklyReport screen renders with mock data\n   - Date selector changes report period\n   - Share button triggers export API call\n   - Loading state shows during fetch\n   - Error state shows on API failure\n\n### Manual Testing\n1. Visual verification of report layout on iOS/Android\n2. Verify charts render correctly with real data\n3. Test share functionality on physical devices\n4. Verify PDF opens correctly in external viewers\n5. Test with edge cases: new user with <7 days data, user with no meals",
        "subtasks": [
          {
            "id": 1,
            "title": "Define report TypeScript types and interfaces",
            "description": "Create server/src/types/reports.ts with DailyBreakdown, NutritionTotals, GoalProgress, TrendComparison, WeeklyReport, and MonthlyReport interfaces",
            "dependencies": [],
            "details": "Follow existing type patterns from server/src/types/index.ts. Include all nutrition fields (calories, protein, carbs, fat, fiber, sugar), goal completion percentages, and trend data structures. Export all types for use in services and controllers.",
            "status": "pending",
            "testStrategy": "TypeScript compilation should pass with no errors. Verify types are properly exported and importable.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement ReportService backend service",
            "description": "Create server/src/services/reportService.ts with generateWeeklyReport() and generateMonthlyReport() methods leveraging existing MealService, HealthMetricService, and ActivityService",
            "dependencies": [
              1
            ],
            "details": "Use mealService.getMeals() pattern to fetch 7-day meal data. Calculate daily breakdowns using getDayBoundaries(). Get user goals via USER_GOALS_SELECT_FIELDS. Calculate trends by comparing to previous week's data. Include getTopFoods() private method using Prisma raw query with GROUP BY. Fetch MLInsights for the period using prisma.mLInsight.findMany().",
            "status": "pending",
            "testStrategy": "Unit test with mock Prisma client. Test 7-day report returns correct structure. Test trend calculations with known values.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create report Zod validation schemas",
            "description": "Add report-related Zod schemas to server/src/validation/schemas.ts for API input validation",
            "dependencies": [
              1
            ],
            "details": "Create schemas for: weeklyReportQuerySchema (optional date string in YYYY-MM-DD format), monthlyReportQuerySchema (optional month string in YYYY-MM format), exportReportQuerySchema (date, format enum of 'pdf'|'image'). Follow existing schema patterns in the file.",
            "status": "pending",
            "testStrategy": "Test schema validation with valid and invalid date formats. Verify error messages are descriptive.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement report controller and routes",
            "description": "Create server/src/controllers/reportController.ts and server/src/routes/reportRoutes.ts with GET endpoints for weekly/monthly reports and export",
            "dependencies": [
              2,
              3
            ],
            "details": "Follow pattern from mealController.ts and mealRoutes.ts. Add routes: GET /reports/weekly, GET /reports/monthly, GET /reports/weekly/export, GET /reports/monthly/export. Use Zod schemas for validation. Apply auth middleware to all routes.",
            "status": "pending",
            "testStrategy": "Integration tests for all endpoints. Test auth middleware blocks unauthenticated requests. Test 400 response for invalid dates.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create mobile API client for reports",
            "description": "Create lib/api/reports.ts with functions to fetch weekly/monthly reports and export functionality",
            "dependencies": [
              4
            ],
            "details": "Follow pattern from lib/api/health-metrics.ts. Export reportsApi object with getWeeklyReport(date?), getMonthlyReport(month?), exportWeeklyReport(date, format), exportMonthlyReport(month, format). Use api client from ./client.ts. Include proper TypeScript types for responses.",
            "status": "pending",
            "testStrategy": "Mock API responses and verify correct request URLs/params are sent.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create mobile report types",
            "description": "Create lib/types/reports.ts with TypeScript interfaces matching backend report types for mobile consumption",
            "dependencies": [],
            "details": "Mirror the backend types from server/src/types/reports.ts. Include WeeklyReport, MonthlyReport, DailyBreakdown, GoalProgress, TrendComparison interfaces. Ensure compatibility with API responses.",
            "status": "pending",
            "testStrategy": "TypeScript compilation verifies types are valid. Manual verification that types match API response structure.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Build WeeklyReport mobile screen UI",
            "description": "Create app/reports/weekly.tsx following UI patterns from app/health/[metricType].tsx with summary cards, charts, and trend indicators",
            "dependencies": [
              5,
              6
            ],
            "details": "Use SafeAreaView with custom header pattern (lines 330-341). Add week date selector with LinearGradient buttons. Show summary stats in row of cards (statsContainer pattern). Use LineChart/BarChart from react-native-chart-kit with chartConfig (lines 291-309). Display daily breakdown list. Show trend badges with colors (getTrendColor pattern). Include AI insights section. Follow theme colors from lib/theme/colors.ts.",
            "status": "pending",
            "testStrategy": "Component renders with mock data. Date selector changes week. Charts render correctly. Loading/error states display properly.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Build MonthlyReport mobile screen UI",
            "description": "Create app/reports/monthly.tsx with weekly breakdowns, best/worst days, and monthly trends",
            "dependencies": [
              7
            ],
            "details": "Similar structure to weekly report but with: month selector instead of week, weekly averages breakdown, best/worst days section with DailyBreakdown cards, monthly trend comparison. Reuse components from weekly report where possible.",
            "status": "pending",
            "testStrategy": "Component renders with mock data. Month selector works. Weekly breakdowns display correctly.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement PDF/image export service",
            "description": "Create server/src/services/reportExportService.ts using Puppeteer to generate shareable PDF and image exports",
            "dependencies": [
              2
            ],
            "details": "Install puppeteer: npm install puppeteer. Create HTML template with Nutri branding (#8B5CF6), summary stats, charts (use chart.js or d3 in template), and AI insights section. Methods: generatePdf(report: WeeklyReport | MonthlyReport), generateImage(report). Return buffer or save to temp file and return URL. Consider using Sharp for image optimization.",
            "status": "pending",
            "testStrategy": "Test PDF generation produces valid PDF. Test image is correct dimensions. Verify all report sections appear in output.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Add share functionality to mobile app",
            "description": "Install expo-sharing and implement share button on report screens to export and share reports via native share sheet",
            "dependencies": [
              7,
              8,
              9
            ],
            "details": "Run: npx expo install expo-sharing expo-file-system. Add share button to report header. On press: call exportReport API, download file with FileSystem.downloadAsync(), share with Sharing.shareAsync(). Show loading indicator during export. Handle errors gracefully with Alert.",
            "status": "pending",
            "testStrategy": "Manual test on physical device. Verify share sheet opens with correct file. Test error handling when export fails.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Add report navigation and entry points",
            "description": "Add reports tab or navigation entry point in app/(tabs) and update _layout.tsx with report routes",
            "dependencies": [
              7,
              8
            ],
            "details": "Add 'Reports' option in profile screen or create reports tab. Register app/reports/weekly.tsx and app/reports/monthly.tsx in app/_layout.tsx with headerShown: false. Add navigation from dashboard with link to weekly report. Consider adding report summary card on home screen.",
            "status": "pending",
            "testStrategy": "Navigation works from all entry points. Routes are properly registered. Deep linking works.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Write comprehensive backend tests",
            "description": "Create server/src/__tests__/reports/ with unit and integration tests for ReportService, controller, and routes",
            "dependencies": [
              4
            ],
            "details": "Test files: reportService.test.ts (mock Prisma, test calculations), reportController.test.ts (test request handling), reportRoutes.test.ts (integration tests). Use existing test utilities from __tests__/setup.ts (createTestUser, createTestMeal). Test edge cases: new user with no data, partial week data, date boundary conditions.",
            "status": "pending",
            "testStrategy": "All tests pass. Coverage >80% for report service and controller files.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 47,
        "title": "User Onboarding Flow with Personalization & Permissions",
        "description": "Implement comprehensive multi-step onboarding flow collecting user goals, dietary preferences, health data permissions, and notification preferences with smooth animations and progress persistence.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Gamification System: Streaks, Achievements & Badges",
        "description": "Implement comprehensive gamification system with daily streaks, achievements/badges, XP points, levels, and leaderboards to increase user engagement and retention.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Quick Add & Favorites System for Rapid Meal Logging",
        "description": "Implement quick-add functionality with favorite meals, recent foods, custom food creation, and meal templates for faster meal logging with minimal friction.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Recipe Database & Weekly Meal Planning System",
        "description": "Implement comprehensive recipe database with ingredient-level nutrition tracking, weekly meal planning calendar, shopping list generation, and recipe suggestions based on nutritional goals.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "iOS Home Screen & Lock Screen Widgets",
        "description": "Implement iOS WidgetKit widgets for home screen and lock screen showing daily nutrition progress, water intake, streaks, and quick-add functionality with proper App Groups data sharing.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Siri Shortcuts & App Intents Integration",
        "description": "Implement Siri Shortcuts and App Intents for voice-controlled meal logging, nutrition queries, water tracking, and custom automations using iOS 16+ App Intents framework.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Google Fit Integration for Android Health Data Sync",
        "description": "Implement Google Fit integration for Android devices to sync steps, heart rate, sleep, weight, and other health metrics bidirectionally with proper OAuth 2.0 authentication and Health Connect support.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Third-Party Wearable Integrations (Fitbit, Garmin, Oura, Whoop)",
        "description": "Implement OAuth-based integrations with major fitness wearable platforms (Fitbit, Garmin, Oura, Whoop) for syncing health metrics, sleep data, HRV, recovery scores, and activity data via their respective APIs.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Apple Watch Companion App with Complications",
        "description": "Implement native Apple Watch companion app with meal logging, water tracking, daily progress complications, workout integration, and real-time sync with the iPhone app using WatchConnectivity.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "Offline Mode with Local Database & Sync Queue",
        "description": "Implement comprehensive offline-first architecture with local SQLite database, background sync queue, conflict resolution, and seamless online/offline transitions for uninterrupted meal tracking.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 57,
        "title": "AI Nutrition Assistant Chatbot with Personalized Advice",
        "description": "Implement conversational AI assistant for nutrition guidance, meal suggestions, answering diet questions, and providing personalized recommendations based on user's goals, dietary restrictions, and historical data.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 58,
        "title": "Intermittent Fasting Timer with Protocols & Analytics",
        "description": "Implement comprehensive intermittent fasting feature with customizable protocols (16:8, 18:6, OMAD, 5:2), countdown timer, fasting history, streak tracking, and health metric correlations during fasting windows.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 59,
        "title": "Social Features: Friends, Challenges & Community",
        "description": "Implement social features including friend connections, group challenges, activity feeds, recipe sharing, leaderboards, and community engagement with proper privacy controls.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 60,
        "title": "Internationalization (i18n) & Multi-Language Support",
        "description": "Implement comprehensive internationalization system with multi-language support, RTL layouts, localized formats (dates, numbers, units), and translation management workflow for global app deployment.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 61,
        "title": "GDPR Compliance: Data Export, Deletion & Privacy Controls",
        "description": "Implement comprehensive GDPR compliance features including data export (right to portability), account deletion (right to erasure), consent management, data retention policies, and privacy dashboard for user control.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 62,
        "title": "Create Shared Button Component",
        "description": "Create a reusable Button component in lib/components/ui/Button.tsx that provides consistent button styling, accessibility, and interaction feedback across the entire application.",
        "details": "## Current Problem\n- Each screen implements buttons differently with inconsistent styling\n- No shared pressed state visual feedback\n- Missing accessibility props on most buttons\n- Gradient FABs are implemented inline in multiple places\n\n## Requirements\n\n### Variants\n- `primary`: Gradient purple/pink background (uses gradients.primary from theme)\n- `secondary`: Outlined with border, transparent background\n- `ghost`: Transparent background, text only\n- `destructive`: Red background (colors.status.error)\n\n### Sizes (with responsive scaling via useResponsive)\n- `sm`: Height 36px, padding horizontal 12px, fontSize 14\n- `md`: Height 44px (Apple HIG minimum), padding horizontal 16px, fontSize 16\n- `lg`: Height 52px, padding horizontal 24px, fontSize 18\n\n### States\n- Default, Pressed (scale to 0.97 or opacity 0.8), Disabled (opacity 0.5), Loading (ActivityIndicator)\n\n### Accessibility (CRITICAL)\n- `accessibilityRole=\"button\"`\n- Required `accessibilityLabel` prop\n- `accessibilityState={{ disabled, busy }}` for loading/disabled states\n\n### Props Interface\n```typescript\ninterface ButtonProps {\n  variant?: 'primary' | 'secondary' | 'ghost' | 'destructive';\n  size?: 'sm' | 'md' | 'lg';\n  label: string;\n  accessibilityLabel: string;\n  onPress: () => void;\n  disabled?: boolean;\n  loading?: boolean;\n  leftIcon?: React.ReactNode;\n  rightIcon?: React.ReactNode;\n  fullWidth?: boolean;\n}\n```\n\n### Implementation Notes\n- Use Pressable with style function for dynamic press states\n- Use Animated.View for smooth scale animations on press\n- Import colors, gradients, shadows, spacing, borderRadius from '@/lib/theme/colors'\n- Use useResponsive hook for responsive sizing\n- Export both Button component and ButtonProps type\n\n### File Location\n`lib/components/ui/Button.tsx`",
        "testStrategy": "1. Unit tests for all variants (primary, secondary, ghost, destructive)\n2. Test all sizes render correctly (sm, md, lg)\n3. Test loading state shows ActivityIndicator and prevents onPress\n4. Test disabled state has reduced opacity and prevents onPress\n5. Test pressed state visual feedback\n6. Test accessibility props are correctly set\n7. Snapshot tests for visual regression\n8. Test with screen reader (VoiceOver simulation)",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Button component base structure with variants",
            "description": "Set up the Button.tsx file with TypeScript interfaces, variant styles, and base Pressable implementation.",
            "dependencies": [],
            "details": "Create lib/components/ui/Button.tsx with ButtonProps interface, variant style mappings (primary with LinearGradient, secondary with border, ghost, destructive), and base Pressable component.",
            "status": "pending",
            "parentId": "62"
          },
          {
            "id": 2,
            "title": "Add size variants with responsive scaling",
            "description": "Implement sm, md, lg size variants using useResponsive hook for device-appropriate scaling.",
            "dependencies": [
              1
            ],
            "details": "Add size style mappings and integrate useResponsive hook to scale heights and padding based on device category (small/medium/large/tablet).",
            "status": "pending",
            "parentId": "62"
          },
          {
            "id": 3,
            "title": "Implement loading and disabled states",
            "description": "Add loading state with ActivityIndicator and disabled state with reduced opacity.",
            "dependencies": [
              1
            ],
            "details": "Show ActivityIndicator centered in button when loading=true, apply opacity 0.5 when disabled=true, prevent onPress callback in both states.",
            "status": "pending",
            "parentId": "62"
          },
          {
            "id": 4,
            "title": "Add press animation and accessibility props",
            "description": "Implement smooth press feedback animation and all required accessibility props.",
            "dependencies": [
              1
            ],
            "details": "Use Animated API for scale animation (0.97) on press, add accessibilityRole='button', accessibilityLabel (required), accessibilityState for disabled/busy states.",
            "status": "pending",
            "parentId": "62"
          },
          {
            "id": 5,
            "title": "Write comprehensive unit tests for Button component",
            "description": "Create test suite covering all variants, sizes, states, and accessibility.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create __tests__/components/ui/Button.test.tsx with tests for all variants, sizes, loading/disabled states, press callbacks, and accessibility props.",
            "status": "pending",
            "parentId": "62"
          }
        ]
      },
      {
        "id": 63,
        "title": "Create Shared Input Component",
        "description": "Create a reusable TextInput component with built-in label, error state, helper text, and accessibility support in lib/components/ui/Input.tsx.",
        "details": "## Current Problem\n- TextInput fields lack accessibility labels (CRITICAL accessibility gap)\n- No visual error states on invalid inputs\n- No helper text for password requirements or input hints\n- Placeholder text is the only label (invisible to screen readers when focused)\n\n## Requirements\n\n### Visual Elements\n- Floating or static label above input\n- Input field with consistent border styling\n- Error message area below input (red text, colors.status.error)\n- Helper text area below input (gray text, colors.text.tertiary)\n- Optional left/right icons\n\n### States\n- Default: Gray border (colors.border.secondary)\n- Focused: Purple border (colors.primary.main)\n- Error: Red border with error message (colors.status.error)\n- Disabled: Reduced opacity, non-editable\n\n### Accessibility (CRITICAL)\n- `accessibilityLabel` connected to visible label\n- `accessibilityHint` for additional context\n- Error state announced via `accessibilityLiveRegion`\n\n### Props Interface\n```typescript\ninterface InputProps {\n  label: string;\n  value: string;\n  onChangeText: (text: string) => void;\n  placeholder?: string;\n  error?: string;\n  helperText?: string;\n  secureTextEntry?: boolean;\n  keyboardType?: KeyboardTypeOptions;\n  autoCapitalize?: 'none' | 'sentences' | 'words' | 'characters';\n  disabled?: boolean;\n  leftIcon?: React.ReactNode;\n  rightIcon?: React.ReactNode;\n  maxLength?: number;\n  multiline?: boolean;\n  numberOfLines?: number;\n}\n```\n\n### Styling\n- Label: colors.text.secondary, fontSize: typography.fontSize.sm\n- Input: height 48px, backgroundColor: colors.background.tertiary, borderRadius: borderRadius.md\n- Error text: colors.status.error, fontSize: typography.fontSize.sm\n- Helper text: colors.text.tertiary, fontSize: typography.fontSize.xs\n\n### File Location\n`lib/components/ui/Input.tsx`",
        "testStrategy": "1. Test label renders and is connected to input for accessibility\n2. Test error state shows red border and error message\n3. Test helper text renders when provided\n4. Test focus state changes border color\n5. Test disabled state prevents input\n6. Test all keyboard types work correctly\n7. Test secure text entry hides characters\n8. Test accessibility with screen reader simulation",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Input component with label and base styling",
            "description": "Set up Input.tsx with TypeScript interfaces, label component, and styled TextInput.",
            "dependencies": [],
            "details": "Create lib/components/ui/Input.tsx with InputProps interface, label positioned above TextInput, consistent styling matching theme tokens.",
            "status": "pending",
            "parentId": "63"
          },
          {
            "id": 2,
            "title": "Add focus, error, and disabled states",
            "description": "Implement visual state changes for focus (purple border), error (red border + message), and disabled states.",
            "dependencies": [
              1
            ],
            "details": "Use useState for focus tracking, conditionally apply border colors, render error message below input when error prop provided.",
            "status": "pending",
            "parentId": "63"
          },
          {
            "id": 3,
            "title": "Add helper text and icon support",
            "description": "Implement optional helper text below input and left/right icon slots.",
            "dependencies": [
              1
            ],
            "details": "Render helperText when provided (hidden if error shown), position leftIcon/rightIcon inside input container with proper spacing.",
            "status": "pending",
            "parentId": "63"
          },
          {
            "id": 4,
            "title": "Implement comprehensive accessibility props",
            "description": "Add all required accessibility props including label connection and live regions for errors.",
            "dependencies": [
              1,
              2
            ],
            "details": "Set accessibilityLabel from label prop, accessibilityHint for context, accessibilityLiveRegion='polite' on error container for screen reader announcements.",
            "status": "pending",
            "parentId": "63"
          },
          {
            "id": 5,
            "title": "Write unit tests for Input component",
            "description": "Create comprehensive test suite for all Input states and accessibility.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create __tests__/components/ui/Input.test.tsx testing all states, text changes, accessibility, and icon rendering.",
            "status": "pending",
            "parentId": "63"
          }
        ]
      },
      {
        "id": 64,
        "title": "Create Shared Card Component",
        "description": "Create a reusable Card component with consistent styling, shadows, and optional press handling in lib/components/ui/Card.tsx.",
        "details": "## Current Problem\n- Each screen defines its own card styles with slightly different shadows, border radius, and padding\n- Inconsistent elevation/shadow values across screens\n- No shared pressable card pattern\n\n## Requirements\n\n### Variants\n- `elevated`: With shadow (default) - uses shadows.md\n- `outlined`: Border only, no shadow - uses colors.border.secondary\n- `filled`: Solid background, no border - uses colors.background.secondary\n\n### Props Interface\n```typescript\ninterface CardProps {\n  variant?: 'elevated' | 'outlined' | 'filled';\n  children: React.ReactNode;\n  onPress?: () => void;\n  style?: ViewStyle;\n  padding?: 'none' | 'sm' | 'md' | 'lg';\n  accessibilityLabel?: string;\n}\n```\n\n### Styling\n- Background: colors.background.card\n- Border radius: borderRadius.lg (16)\n- Shadows: Use shadows.md for elevated variant\n- Padding: spacing.sm (8), spacing.md (16), spacing.lg (24)\n\n### Behavior\n- If onPress provided, wrap in Pressable with opacity feedback\n- Pass through accessibility props when pressable\n\n### File Location\n`lib/components/ui/Card.tsx`",
        "testStrategy": "1. Test all variants render correctly (elevated, outlined, filled)\n2. Test padding options (none, sm, md, lg)\n3. Test pressable behavior when onPress provided\n4. Test non-pressable behavior when onPress not provided\n5. Test accessibility props passed through\n6. Snapshot tests for visual consistency",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 65,
        "title": "Create Shared ScreenHeader Component",
        "description": "Create a consistent header component for all screens with back navigation, title, and optional right actions in lib/components/ui/ScreenHeader.tsx.",
        "details": "## Current Problem\n- No consistent header pattern across screens\n- Back buttons implemented differently (sometimes Ionicons chevron, sometimes missing)\n- headerShown: false on all screens but no unified custom header\n\n## Requirements\n\n### Elements\n- Back button (chevron-left icon) - conditionally shown\n- Title (centered or left-aligned)\n- Optional right action buttons\n- Safe area handling for notch devices\n\n### Props Interface\n```typescript\ninterface ScreenHeaderProps {\n  title: string;\n  showBackButton?: boolean; // default true\n  onBackPress?: () => void; // defaults to router.back()\n  rightActions?: React.ReactNode;\n  transparent?: boolean;\n  titleAlign?: 'left' | 'center'; // default 'center'\n}\n```\n\n### Styling\n- Height: 56px (excluding safe area)\n- Background: colors.background.primary (or transparent if transparent=true)\n- Title: typography.fontSize.lg, fontWeight: '600'\n- Back icon: Ionicons chevron-back, size 24, colors.text.primary\n- SafeAreaView handling for top inset\n\n### Implementation\n- Use expo-router's useRouter for default back navigation\n- Use SafeAreaView from react-native-safe-area-context\n- Add accessibility labels to back button\n\n### File Location\n`lib/components/ui/ScreenHeader.tsx`",
        "testStrategy": "1. Test back button renders when showBackButton=true\n2. Test back button hidden when showBackButton=false\n3. Test custom onBackPress callback\n4. Test title alignment (left, center)\n5. Test rightActions render correctly\n6. Test transparent variant\n7. Test accessibility on back button",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 66,
        "title": "Create Shared EmptyState Component",
        "description": "Create a reusable empty state component for screens/sections with no data in lib/components/ui/EmptyState.tsx.",
        "details": "## Current Problem\n- Home screen has no empty state when no meals are logged\n- Activity list has no empty state\n- Supplements list has no empty state\n- Only Health screen has a proper empty state implementation\n\n## Requirements\n\n### Elements\n- Icon (customizable Ionicons name)\n- Title text\n- Description text\n- Optional CTA button (uses shared Button component)\n\n### Props Interface\n```typescript\ninterface EmptyStateProps {\n  icon: keyof typeof Ionicons.glyphMap;\n  title: string;\n  description: string;\n  actionLabel?: string;\n  onAction?: () => void;\n}\n```\n\n### Styling\n- Container: Centered, padding: spacing.xl\n- Icon: size 64, colors.text.disabled\n- Title: typography.fontSize.xl, colors.text.primary, fontWeight: '600', marginTop: spacing.md\n- Description: typography.fontSize.md, colors.text.tertiary, textAlign: 'center', marginTop: spacing.sm\n- Button: Primary variant, marginTop: spacing.lg\n\n### File Location\n`lib/components/ui/EmptyState.tsx`",
        "testStrategy": "1. Test icon renders with correct name\n2. Test title and description render\n3. Test CTA button renders when actionLabel provided\n4. Test CTA button onPress triggers onAction\n5. Test no button when actionLabel not provided\n6. Snapshot test for layout",
        "priority": "medium",
        "dependencies": [
          "62"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 67,
        "title": "Add Accessibility Labels to Auth Screens",
        "description": "Systematically add accessibility props to all interactive elements in auth screens (signin, signup, forgot-password, reset-password, welcome).",
        "details": "## Current Problem\n- TextInput fields lack accessibilityLabel (CRITICAL for screen readers)\n- Buttons missing accessibilityRole\n- No accessibilityHint for actions\n\n## Screens to Update\n\n### app/auth/signin.tsx\n- Email TextInput: accessibilityLabel=\"Email address\"\n- Password TextInput: accessibilityLabel=\"Password\"\n- Sign In button: accessibilityRole=\"button\", accessibilityLabel=\"Sign in to your account\"\n- Forgot Password link: accessibilityRole=\"link\", accessibilityLabel=\"Forgot password\"\n- Sign Up link: accessibilityRole=\"link\", accessibilityLabel=\"Create a new account\"\n\n### app/auth/signup.tsx\n- Name TextInput: accessibilityLabel=\"Full name\"\n- Email TextInput: accessibilityLabel=\"Email address\"\n- Password TextInput: accessibilityLabel=\"Password\", accessibilityHint=\"Must be at least 8 characters\"\n- Confirm Password TextInput: accessibilityLabel=\"Confirm password\"\n- Sign Up button: accessibilityRole=\"button\", accessibilityLabel=\"Create account\"\n- Sign In link: accessibilityRole=\"link\", accessibilityLabel=\"Sign in to existing account\"\n\n### app/auth/forgot-password.tsx\n- Email TextInput: accessibilityLabel=\"Email address for password reset\"\n- Submit button: accessibilityRole=\"button\", accessibilityLabel=\"Send password reset email\"\n- Back link: accessibilityRole=\"link\", accessibilityLabel=\"Return to sign in\"\n\n### app/auth/reset-password.tsx\n- New Password TextInput: accessibilityLabel=\"New password\"\n- Confirm Password TextInput: accessibilityLabel=\"Confirm new password\"\n- Reset button: accessibilityRole=\"button\", accessibilityLabel=\"Reset password\"\n\n### app/auth/welcome.tsx\n- Get Started button: accessibilityRole=\"button\", accessibilityLabel=\"Get started with Nutri\"\n- Sign In button: accessibilityRole=\"button\", accessibilityLabel=\"Sign in to existing account\"",
        "testStrategy": "1. Test each screen with accessibility inspector\n2. Verify all inputs have accessibilityLabel\n3. Verify all buttons have accessibilityRole\n4. Test with VoiceOver (iOS) or TalkBack (Android)\n5. Verify focus order is logical",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add accessibility props to signin.tsx",
            "description": "Add accessibilityLabel to email/password inputs and accessibilityRole to buttons/links.",
            "dependencies": [],
            "status": "pending",
            "parentId": "67"
          },
          {
            "id": 2,
            "title": "Add accessibility props to signup.tsx",
            "description": "Add accessibilityLabel to all form inputs and accessibilityRole to buttons/links.",
            "dependencies": [],
            "status": "pending",
            "parentId": "67"
          },
          {
            "id": 3,
            "title": "Add accessibility props to forgot-password.tsx",
            "description": "Add accessibilityLabel to email input and accessibilityRole to buttons.",
            "dependencies": [],
            "status": "pending",
            "parentId": "67"
          },
          {
            "id": 4,
            "title": "Add accessibility props to reset-password.tsx",
            "description": "Add accessibilityLabel to password inputs and accessibilityRole to reset button.",
            "dependencies": [],
            "status": "pending",
            "parentId": "67"
          },
          {
            "id": 5,
            "title": "Add accessibility props to welcome.tsx",
            "description": "Add accessibilityRole and accessibilityLabel to CTA buttons.",
            "dependencies": [],
            "status": "pending",
            "parentId": "67"
          }
        ]
      },
      {
        "id": 68,
        "title": "Add Accessibility Labels to Main Tab Screens",
        "description": "Add accessibility props to all interactive elements in main tab screens (index/home, health, profile).",
        "details": "## Screens to Update\n\n### app/(tabs)/index.tsx (Home)\n- Date navigation arrows: accessibilityLabel=\"Previous day\"/\"Next day\", accessibilityRole=\"button\"\n- Each meal card: accessibilityLabel=\"[Meal name] meal, [calories] calories\", accessibilityRole=\"button\", accessibilityHint=\"Double tap to view details, swipe for options\"\n- Add meal FAB: accessibilityLabel=\"Add new meal\", accessibilityRole=\"button\"\n- Macros section: accessibilityLabel=\"Daily nutrition summary\"\n\n### app/(tabs)/health.tsx\n- Each metric card: accessibilityLabel=\"[Metric name]: [value] [unit]\", accessibilityRole=\"button\", accessibilityHint=\"Double tap to view history\"\n- Time range buttons: accessibilityRole=\"button\", accessibilityState={{ selected: isActive }}\n- Add metric FAB: accessibilityLabel=\"Add health metric\", accessibilityRole=\"button\"\n\n### app/(tabs)/profile.tsx\n- Profile image: accessibilityLabel=\"Profile picture\", accessibilityHint=\"Double tap to change\"\n- Edit button: accessibilityLabel=\"Edit profile\", accessibilityRole=\"button\"\n- Each form field when editing: accessibilityLabel with field name\n- Save button: accessibilityLabel=\"Save profile changes\", accessibilityRole=\"button\"\n- Logout button: accessibilityLabel=\"Sign out\", accessibilityRole=\"button\"\n- Settings items: accessibilityRole=\"button\" with descriptive labels",
        "testStrategy": "1. Test each screen with accessibility inspector\n2. Verify logical focus order (tab navigation)\n3. Test with VoiceOver/TalkBack\n4. Verify dynamic content updates are announced\n5. Test swipe gestures have accessibility alternatives",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add accessibility props to Home screen (index.tsx)",
            "description": "Add labels to date nav, meal cards, FAB, and macros section.",
            "dependencies": [],
            "status": "pending",
            "parentId": "68"
          },
          {
            "id": 2,
            "title": "Add accessibility props to Health screen (health.tsx)",
            "description": "Add labels to metric cards, time range buttons, and add FAB.",
            "dependencies": [],
            "status": "pending",
            "parentId": "68"
          },
          {
            "id": 3,
            "title": "Add accessibility props to Profile screen (profile.tsx)",
            "description": "Add labels to all interactive elements including edit mode fields.",
            "dependencies": [],
            "status": "pending",
            "parentId": "68"
          }
        ]
      },
      {
        "id": 69,
        "title": "Implement Form Validation UX with Inline Errors",
        "description": "Replace Alert-based validation errors with inline error messages using the shared Input component.",
        "details": "## Current Problem\n- Forms use Alert.alert() for validation errors (disruptive UX)\n- No visual indication of which field has an error\n- No real-time validation feedback\n- No helper text for input requirements\n\n## Screens to Update\n\n### app/auth/signin.tsx\n- Email: Validate format on blur, show \"Please enter a valid email address\"\n- Password: Validate required on blur, show \"Password is required\"\n\n### app/auth/signup.tsx\n- Name: Validate required, show \"Name is required\"\n- Email: Validate format, show \"Please enter a valid email address\"\n- Password: Validate strength, show \"Password must be at least 8 characters\"\n- Confirm Password: Validate match, show \"Passwords do not match\"\n\n### app/auth/forgot-password.tsx\n- Email: Validate format, show \"Please enter a valid email address\"\n\n### app/auth/reset-password.tsx\n- Password: Validate strength\n- Confirm: Validate match\n\n### app/add-meal.tsx\n- Name: Validate required\n- Calories: Validate numeric and required\n- Other fields: Validate numeric if provided\n\n### app/(tabs)/profile.tsx (edit mode)\n- Email: Validate format\n- Numeric fields (weight, height, goals): Validate numeric\n\n## Validation Pattern\n```typescript\n// Validate on blur first time, then on change after first error\nconst [touched, setTouched] = useState<Record<string, boolean>>({});\nconst [errors, setErrors] = useState<Record<string, string>>({});\n\nconst validateField = (name: string, value: string) => {\n  // validation logic\n  setErrors(prev => ({ ...prev, [name]: error || '' }));\n};\n\nconst handleBlur = (name: string, value: string) => {\n  setTouched(prev => ({ ...prev, [name]: true }));\n  validateField(name, value);\n};\n\nconst handleChange = (name: string, value: string) => {\n  if (touched[name]) validateField(name, value);\n  // update value\n};\n```\n\n## Implementation Notes\n- Use shared Input component with error prop\n- Keep submit button enabled but show all errors on submit attempt\n- Clear field error when user fixes the input\n- Replace Alert.alert() validation with inline errors",
        "testStrategy": "1. Test error appears below field on blur\n2. Test error clears when input is corrected\n3. Test all errors shown on submit with invalid data\n4. Test successful submission when all valid\n5. Test real-time validation after first blur\n6. Test no Alert dialogs for validation",
        "priority": "high",
        "dependencies": [
          "63"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Migrate signin.tsx to use Input component with inline validation",
            "description": "Replace TextInputs with Input component and add inline error messages.",
            "dependencies": [],
            "status": "pending",
            "parentId": "69"
          },
          {
            "id": 2,
            "title": "Migrate signup.tsx to use Input component with inline validation",
            "description": "Replace all form fields with Input component and add validation for all fields.",
            "dependencies": [],
            "status": "pending",
            "parentId": "69"
          },
          {
            "id": 3,
            "title": "Migrate forgot-password.tsx and reset-password.tsx",
            "description": "Add inline validation to password reset flows.",
            "dependencies": [],
            "status": "pending",
            "parentId": "69"
          },
          {
            "id": 4,
            "title": "Migrate add-meal.tsx to use Input component",
            "description": "Replace nutrition inputs with Input component and add numeric validation.",
            "dependencies": [],
            "status": "pending",
            "parentId": "69"
          },
          {
            "id": 5,
            "title": "Migrate profile.tsx edit mode to use Input component",
            "description": "Add inline validation to profile editing fields.",
            "dependencies": [],
            "status": "pending",
            "parentId": "69"
          }
        ]
      },
      {
        "id": 70,
        "title": "Add Empty States to All Content Areas",
        "description": "Implement proper empty states using the shared EmptyState component for screens that can have no data.",
        "details": "## Screens Needing Empty States\n\n### app/(tabs)/index.tsx (Home Screen)\n- Condition: When no meals logged for selected date\n- Icon: \"restaurant-outline\"\n- Title: \"No meals logged yet\"\n- Description: \"Track your nutrition by logging your first meal for today.\"\n- CTA: \"Log a meal\" -> navigates to /add-meal\n\n### app/activity/index.tsx\n- Condition: When no activities exist\n- Icon: \"fitness-outline\"\n- Title: \"No activities tracked\"\n- Description: \"Start tracking your workouts and physical activities.\"\n- CTA: \"Add an activity\" -> navigates to /activity/add\n\n### app/supplements.tsx\n- Condition: When no supplements added\n- Icon: \"medical-outline\"\n- Title: \"No supplements tracked\"\n- Description: \"Keep track of your vitamins and supplements.\"\n- CTA: \"Add a supplement\" -> triggers add flow\n\n### app/health/[metricType].tsx\n- Condition: When no data for selected metric/date range\n- Icon: \"analytics-outline\"\n- Title: \"No data for this period\"\n- Description: \"Try selecting a different date range or add a new entry.\"\n- CTA: \"Add entry\" -> navigates to /health/add\n\n## Implementation\n- Import EmptyState from '@/lib/components/ui/EmptyState'\n- Conditionally render based on data.length === 0 (after loading)\n- Ensure loading state shows before empty state",
        "testStrategy": "1. Test empty state renders when data array is empty\n2. Test empty state hidden when data exists\n3. Test CTA button navigates correctly\n4. Test empty state not shown during loading\n5. Test each screen individually",
        "priority": "medium",
        "dependencies": [
          "66"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add empty state to Home screen for no meals",
            "description": "Show EmptyState when no meals for selected date.",
            "dependencies": [],
            "status": "pending",
            "parentId": "70"
          },
          {
            "id": 2,
            "title": "Add empty state to Activity list",
            "description": "Show EmptyState when no activities tracked.",
            "dependencies": [],
            "status": "pending",
            "parentId": "70"
          },
          {
            "id": 3,
            "title": "Add empty state to Supplements screen",
            "description": "Show EmptyState when no supplements added.",
            "dependencies": [],
            "status": "pending",
            "parentId": "70"
          },
          {
            "id": 4,
            "title": "Add empty state to Health metric detail for no data",
            "description": "Show EmptyState when no data for selected metric/range.",
            "dependencies": [],
            "status": "pending",
            "parentId": "70"
          }
        ]
      },
      {
        "id": 71,
        "title": "Create Loading Skeleton Components",
        "description": "Create skeleton loading components to improve perceived performance during data fetching.",
        "details": "## Current Problem\n- Screens show ActivityIndicator during loading\n- Content \"pops in\" suddenly when loaded\n- No visual hint of what content will appear\n\n## Components to Create\n\n### lib/components/ui/Skeleton.tsx (Base Component)\n```typescript\ninterface SkeletonProps {\n  width?: number | string;\n  height?: number;\n  borderRadius?: number;\n  style?: ViewStyle;\n}\n```\n- Animated shimmer effect using Animated API or react-native-reanimated\n- Gray background (colors.background.tertiary)\n- Shimmer highlight color (colors.background.secondary)\n\n### lib/components/ui/MealCardSkeleton.tsx\n- Matches MealCard dimensions and layout\n- Skeleton for: meal type badge, name text, calories, macros row\n- Used in Home screen during meal loading\n\n### lib/components/ui/MetricCardSkeleton.tsx\n- Matches health metric card dimensions\n- Skeleton for: icon area, label, value, trend\n- Used in Health screen during loading\n\n### lib/components/ui/ProfileSkeleton.tsx\n- Matches profile layout\n- Skeleton for: avatar, name, stats\n- Used during profile data loading\n\n## Shimmer Animation\n```typescript\nconst shimmerValue = useRef(new Animated.Value(0)).current;\n\nuseEffect(() => {\n  Animated.loop(\n    Animated.timing(shimmerValue, {\n      toValue: 1,\n      duration: 1500,\n      useNativeDriver: true,\n    })\n  ).start();\n}, []);\n\n// Use shimmerValue to animate gradient position\n```\n\n## Usage Pattern\n```typescript\n{isLoading ? (\n  <>\n    <MealCardSkeleton />\n    <MealCardSkeleton />\n    <MealCardSkeleton />\n  </>\n) : (\n  meals.map(meal => <MealCard key={meal.id} meal={meal} />)\n)}\n```",
        "testStrategy": "1. Test base Skeleton renders with correct dimensions\n2. Test shimmer animation runs\n3. Test MealCardSkeleton matches meal card layout\n4. Test MetricCardSkeleton matches metric card layout\n5. Test skeletons shown during loading, content shown after\n6. Visual regression tests for skeleton layouts",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create base Skeleton component with shimmer animation",
            "description": "Build reusable Skeleton with configurable dimensions and animated shimmer effect.",
            "dependencies": [],
            "status": "pending",
            "parentId": "71"
          },
          {
            "id": 2,
            "title": "Create MealCardSkeleton component",
            "description": "Build skeleton matching MealCard layout for home screen loading.",
            "dependencies": [
              1
            ],
            "status": "pending",
            "parentId": "71"
          },
          {
            "id": 3,
            "title": "Create MetricCardSkeleton component",
            "description": "Build skeleton matching health metric card for health screen loading.",
            "dependencies": [
              1
            ],
            "status": "pending",
            "parentId": "71"
          },
          {
            "id": 4,
            "title": "Integrate skeletons into Home and Health screens",
            "description": "Replace ActivityIndicator with skeleton loaders during data fetching.",
            "dependencies": [
              2,
              3
            ],
            "status": "pending",
            "parentId": "71"
          }
        ]
      },
      {
        "id": 72,
        "title": "Visual Consistency Audit and Fixes",
        "description": "Audit and fix visual inconsistencies across the app to ensure strict adherence to design tokens.",
        "details": "## Issues to Fix\n\n### Spacing Inconsistencies\n- Replace all hardcoded spacing values with design tokens\n- Audit: gap values in flex layouts (some use gap: 12, should use spacing.md)\n- Ensure consistent use of spacing scale (4, 8, 16, 24, 32, 40, 48, 64)\n\n### Border Radius Inconsistencies\n- Cards: standardize to borderRadius.lg (16)\n- Buttons: standardize to borderRadius.md (12)\n- Inputs: standardize to borderRadius.sm (8)\n- Remove any hardcoded borderRadius values\n\n### Shadow Inconsistencies\n- Use shadows.sm for subtle elevation\n- Use shadows.md for cards\n- Use shadows.lg for modals/overlays\n- Remove any inline shadow definitions\n\n### Typography Inconsistencies\n- Ensure all text uses typography presets from theme\n- Replace inline font sizes with responsive typography\n- Consistent use of font weights (400, 500, 600, 700)\n\n## Files to Audit\n- app/(tabs)/index.tsx\n- app/(tabs)/health.tsx\n- app/(tabs)/profile.tsx\n- app/auth/*.tsx (all auth screens)\n- app/add-meal.tsx\n- app/supplements.tsx\n- app/activity/*.tsx\n- lib/components/*.tsx\n\n## Audit Process\n1. Search for hardcoded numbers in StyleSheet.create()\n2. Replace with corresponding design token\n3. Verify visual appearance matches original\n4. Run on multiple device sizes to confirm responsive behavior",
        "testStrategy": "1. Visual comparison before/after for each screen\n2. Verify no hardcoded values in StyleSheet definitions\n3. Test on different device sizes\n4. Snapshot tests for visual regression\n5. Lint rule to prevent hardcoded values (optional)",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit and fix spacing in tab screens",
            "description": "Replace hardcoded spacing in index.tsx, health.tsx, profile.tsx with design tokens.",
            "dependencies": [],
            "status": "pending",
            "parentId": "72"
          },
          {
            "id": 2,
            "title": "Audit and fix spacing in auth screens",
            "description": "Replace hardcoded spacing in all auth/*.tsx files.",
            "dependencies": [],
            "status": "pending",
            "parentId": "72"
          },
          {
            "id": 3,
            "title": "Standardize border radius across all components",
            "description": "Replace all hardcoded borderRadius with design tokens.",
            "dependencies": [],
            "status": "pending",
            "parentId": "72"
          },
          {
            "id": 4,
            "title": "Standardize shadows across all components",
            "description": "Replace inline shadow definitions with shadows tokens.",
            "dependencies": [],
            "status": "pending",
            "parentId": "72"
          },
          {
            "id": 5,
            "title": "Audit and fix typography usage",
            "description": "Ensure all text uses typography presets, fix inline font sizes.",
            "dependencies": [],
            "status": "pending",
            "parentId": "72"
          }
        ]
      },
      {
        "id": 73,
        "title": "Add Haptic Feedback to Key Interactions",
        "description": "Implement haptic feedback using expo-haptics for improved tactile response on user interactions.",
        "details": "## Requirements\n\n### Install expo-haptics\n```bash\nnpx expo install expo-haptics\n```\n\n### Feedback Types\n```typescript\nimport * as Haptics from 'expo-haptics';\n\n// Light tap - for button presses\nHaptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n\n// Medium tap - for swipe actions\nHaptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n\n// Success - for successful actions\nHaptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n\n// Error - for failed actions\nHaptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n\n// Warning - for destructive action confirmations\nHaptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);\n```\n\n### Where to Add\n\n#### Button Component (lib/components/ui/Button.tsx)\n- Light impact on press for primary/secondary buttons\n- Add to onPressIn handler\n\n#### SwipeableMealCard (lib/components/SwipeableMealCard.tsx)\n- Medium impact when swipe threshold reached\n- Success notification on delete confirmation\n- Error notification on failed delete\n\n#### Form Submissions\n- Success notification on successful save (meals, health metrics, profile)\n- Error notification on validation/API errors\n\n#### Delete Confirmations\n- Warning notification when showing delete confirmation\n- Success notification after confirmed delete\n\n### Implementation Pattern\n```typescript\nconst handlePress = async () => {\n  await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  onPress?.();\n};\n```\n\n### Accessibility Note\nHaptic feedback should be optional for users who may find it distracting. Consider adding a setting to disable haptics.",
        "testStrategy": "1. Test haptic triggers on physical device (not simulator)\n2. Verify correct haptic type for each interaction\n3. Test haptic intensity appropriate for action\n4. Verify no haptic on disabled buttons\n5. Test performance (no lag from haptic calls)",
        "priority": "low",
        "dependencies": [
          "62"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install expo-haptics and add to Button component",
            "description": "Install package and add light impact feedback to Button onPress.",
            "dependencies": [],
            "status": "pending",
            "parentId": "73"
          },
          {
            "id": 2,
            "title": "Add haptic feedback to SwipeableMealCard",
            "description": "Add medium impact on swipe threshold, success/error on actions.",
            "dependencies": [
              1
            ],
            "status": "pending",
            "parentId": "73"
          },
          {
            "id": 3,
            "title": "Add haptic feedback to form submissions",
            "description": "Add success/error notifications to all form save operations.",
            "dependencies": [
              1
            ],
            "status": "pending",
            "parentId": "73"
          },
          {
            "id": 4,
            "title": "Add haptic feedback to delete confirmations",
            "description": "Add warning notification on delete dialogs, success on confirm.",
            "dependencies": [
              1
            ],
            "status": "pending",
            "parentId": "73"
          }
        ]
      },
      {
        "id": 74,
        "title": "Create Toast Notification System",
        "description": "Create a toast notification system for non-critical feedback messages that don't interrupt user flow.",
        "details": "## Current Problem\n- All feedback uses Alert.alert() which is disruptive\n- No way to show success messages without interrupting flow\n- Error messages require dismissal before continuing\n\n## Requirements\n\n### Toast Types\n- `success`: Green background (colors.status.success), checkmark icon\n- `error`: Red background (colors.status.error), X icon\n- `warning`: Yellow/amber background (colors.status.warning), warning icon\n- `info`: Blue background (colors.secondary.main), info icon\n\n### Behavior\n- Appears at top of screen below safe area\n- Auto-dismisses after 3 seconds (configurable)\n- Can be manually dismissed by swipe up or tap X\n- Queue system for multiple toasts (show one at a time)\n- Slide-in animation from top\n\n### Props/API\n```typescript\ninterface ToastOptions {\n  type: 'success' | 'error' | 'warning' | 'info';\n  message: string;\n  duration?: number; // ms, default 3000\n  action?: {\n    label: string;\n    onPress: () => void;\n  };\n}\n\n// Context API\ninterface ToastContextValue {\n  showToast: (options: ToastOptions) => void;\n  hideToast: () => void;\n}\n\n// Usage\nconst { showToast } = useToast();\nshowToast({ type: 'success', message: 'Meal saved successfully!' });\n```\n\n### File Structure\n- `lib/components/ui/Toast.tsx` - Toast component\n- `lib/context/ToastContext.tsx` - Toast provider and hook\n\n### Implementation\n1. Create ToastContext with queue state\n2. Create Toast component with animations\n3. Wrap app in ToastProvider in _layout.tsx\n4. Export useToast hook\n\n### Accessibility\n- Use accessibilityLiveRegion=\"polite\" for announcements\n- Provide close button with accessibilityLabel\n- Don't auto-dismiss for error toasts (give more time)",
        "testStrategy": "1. Test toast renders for each type (success, error, warning, info)\n2. Test auto-dismiss after duration\n3. Test manual dismiss via swipe/tap\n4. Test queue system with multiple toasts\n5. Test action button works\n6. Test accessibility announcements\n7. Test animation smoothness",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ToastContext with provider and useToast hook",
            "description": "Build context for toast state management with queue system.",
            "dependencies": [],
            "status": "pending",
            "parentId": "74"
          },
          {
            "id": 2,
            "title": "Create Toast component with variants and animations",
            "description": "Build Toast UI with all type variants, icons, and slide animation.",
            "dependencies": [
              1
            ],
            "status": "pending",
            "parentId": "74"
          },
          {
            "id": 3,
            "title": "Add auto-dismiss and manual dismiss functionality",
            "description": "Implement timer-based dismiss and swipe/tap to dismiss.",
            "dependencies": [
              2
            ],
            "status": "pending",
            "parentId": "74"
          },
          {
            "id": 4,
            "title": "Integrate ToastProvider into app layout",
            "description": "Add ToastProvider to _layout.tsx and test with sample toasts.",
            "dependencies": [
              1,
              2,
              3
            ],
            "status": "pending",
            "parentId": "74"
          },
          {
            "id": 5,
            "title": "Replace Alert.alert success messages with toast",
            "description": "Update form submissions to use showToast for success feedback.",
            "dependencies": [
              4
            ],
            "status": "pending",
            "parentId": "74"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-26T12:01:58.106Z",
      "taskCount": 73,
      "completedCount": 26,
      "tags": [
        "master"
      ],
      "created": "2025-12-26T12:02:06.190Z",
      "description": "Tasks for master context",
      "updated": "2025-12-26T12:02:06.190Z"
    }
  }
}